# ===================================================================
# IFVG - Ionflux' Volumetric Graphics Library
# Copyright © 2014 Jörn P. Meier
# mail@ionflux.org
# -------------------------------------------------------------------
# NodeIntersectionProcessor.conf           Class configuration.
# ===================================================================
# 
# This file is part of IFVG - Ionflux' Volumetric Graphics Library.
# 
# IFVG - Ionflux' Volumetric Graphics Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# IFVG - Ionflux' Volumetric Graphics Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with IFVG - Ionflux' Volumetric Graphics Library; if not, write to 
# the Free Software  Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
# MA 02111-1307 USA
# 
# ===================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
        '"ifvg/types.hpp"'
        '"ifvg/constants.hpp"'
        '"ifvg/Node.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"ifobject/utils.hpp"'
        '"ifobject/objectutils.hpp"'
        '"altjira/Color.hpp"'
        '"geoutils/Vector3.hpp"'
        '"ifvg/utils.hpp"'
        '"ifvg/IFVGError.hpp"'
        '"ifvg/Context.hpp"'
        '"ifvg/NodeFilter.hpp"'
    }
}

# forward declarations
forward = {
    'class Context'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = NodeIntersectionProcessor
	shortDesc = Node intersection processor
	title = Node intersection processor
	longDesc = A node processor for ray/node intersections. This processor can be used to set a data type and voxel class on nodes that are intersected by a ray. By default, the node intersection processor will only process leaf nodes and throw an exception if a node is passed in that is not a leaf node. This behavior can be changed by setting the \c leafStatus property. Depending on the configuration, this processor can cast ray votes for interior/exterior classification of nodes, identify boundary nodes and calculate and fix the wall thickness of connected sequences of 'filled' nodes along a ray.
	group.name = ifvg
	base = {
		## base classes from the IFObject hierarchy
		#ifobject[] = {
		#	name = IFObject
		#}
        # other base classes
        other[] = {
            name = Ionflux::VolGfx::ChainableNodeProcessor
            include = ifvg/ChainableNodeProcessor.hpp
            hasClassInfo = true
        }
	}
    features = {
        'copy'
        'upcast'
        'create'
        'classinfo'
        #'xmlio'
    }
    create = {
        allocationError = IFVGError("Could not allocate object")
        extendedCreate = true
    }
    xml = {
        elementName = nodeproc
    }
}

# Member variables.
variable.protected[] = {
    type = Ionflux::VolGfx::NodeIntersectionVector
    name = updatedIntersections
    desc = Updated node intersections
}

# Public static constants.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    style = vector
    name = intersections
    desc = Vector of intersections
    extendedAddFuncs = true
    element = {
        type = Ionflux::VolGfx::NodeIntersection
        name = Intersection
        addType = const Ionflux::VolGfx::NodeIntersection&
        findType = const Ionflux::VolGfx::NodeIntersection&
        removeType = const Ionflux::VolGfx::NodeIntersection&
        defaultValue = createNodeIntersection()
        createExpr = createNodeIntersection()
    }
}
property.protected[] = {
    type = Ionflux::VolGfx::Context*
    setFromType = Ionflux::VolGfx::Context*
    name = context
    desc = Voxel tree context
    managed = true
}
property.protected[] = {
    type = Ionflux::VolGfx::NodeDataType
    setFromType = Ionflux::VolGfx::NodeDataType
    name = hitDataType
    desc = node data type for ray hits
}
property.protected[] = {
    type = Ionflux::VolGfx::VoxelClassID
    setFromType = Ionflux::VolGfx::VoxelClassID
    name = voxelClassHit
    desc = voxel class mask for ray hits
}
property.protected[] = {
    type = Ionflux::VolGfx::LeafStatusID
    setFromType = Ionflux::VolGfx::LeafStatusID
    name = leafStatus
    desc = leaf status flag
}
property.protected[] = {
    type = Ionflux::GeoUtils::Line3*
    setFromType = Ionflux::GeoUtils::Line3*
    name = ray
    desc = Ray
    managed = true
    impl.set = <<<
if (ray == newRay)
    return;
if (newRay != 0)
{
    addLocalRef(newRay);
    rayAxis = newRay->getAxis();
}
if (ray != 0)
    removeLocalRef(ray);
ray = newRay;
>>>
}
property.protected[] = {
    type = bool
    setFromType = bool
    name = enableBoundaryData
    desc = boundary data enable flag
}
property.protected[] = {
    type = int
    setFromType = int
    name = targetDepth
    desc = target depth for inserting node intersections
}
property.protected[] = {
    type = bool
    setFromType = bool
    name = fillNewIntersections
    desc = fill nodes that are created for new intersections
}
property.protected[] = {
    type = bool
    setFromType = bool
    name = pruneEmptyNewIntersections
    desc = prune empty nodes that are created for new intersections
}
property.protected[] = {
    type = bool
    setFromType = bool
    name = enableIOB
    desc = enable inside/outside/boundary classification
}
property.protected[] = {
    type = bool
    setFromType = bool
    name = enableRayStabbing
    desc = mark nodes with zero intersections as outside (ray-stabbing)
}
property.protected[] = {
    type = bool
    setFromType = bool
    name = enableWallThickness
    desc = enable wall thickness calculation
}
property.protected[] = {
    type = Ionflux::VolGfx::VoxelClassID
    setFromType = Ionflux::VolGfx::VoxelClassID
    name = voxelClassFilled
    desc = voxel class for 'filled' voxels
}
property.protected[] = {
    type = Ionflux::VolGfx::VoxelClassID
    setFromType = Ionflux::VolGfx::VoxelClassID
    name = voxelClassInside
    desc = voxel class for 'inside' voxels
}
property.protected[] = {
    type = Ionflux::VolGfx::VoxelClassID
    setFromType = Ionflux::VolGfx::VoxelClassID
    name = voxelClassOutside
    desc = voxel class for 'outside' voxels
}
property.protected[] = {
    type = Ionflux::VolGfx::VoxelClassID
    setFromType = Ionflux::VolGfx::VoxelClassID
    name = voxelClassBoundary
    desc = voxel class for 'boundary' voxels
}
property.protected[] = {
    type = double
    setFromType = double
    name = tolerance
    desc = Tolerance for comparisons
}
property.protected[] = {
    type = Ionflux::GeoUtils::AxisID
    setFromType = Ionflux::GeoUtils::AxisID
    name = rayAxis
    desc = Ray axis
    protectedWrite = true
}
property.protected[] = {
    type = unsigned int
    setFromType = unsigned int
    name = minWallThickness
    desc = Minimum wall thickness
}
property.protected[] = {
    type = bool
    setFromType = bool
    name = fillInsideOnly
    desc = Fill 'inside' nodes only when fixing the minimum wall thickness
}
property.protected[] = {
    type = unsigned int
    setFromType = unsigned int
    name = maxNumWallThicknessPasses
    desc = Maximum number of passes for fixing wall thickness
}

# Protected static constants.

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = context
        value = 0
    }
    initializer[] = {
        name = hitDataType
        value = Node::DATA_TYPE_UNKNOWN
    }
    initializer[] = {
        name = voxelClassHit
        value = VOXEL_CLASS_UNDEFINED
    }
    initializer[] = {
        name = leafStatus
        value = NODE_LEAF
    }
    initializer[] = {
        name = ray
        value = 0
    }
    initializer[] = {
        name = enableBoundaryData
        value = false
    }
    initializer[] = {
        name = targetDepth
        value = DEPTH_UNSPECIFIED
    }
    initializer[] = {
        name = fillNewIntersections
        value = true
    }
    initializer[] = {
        name = pruneEmptyNewIntersections
        value = false
    }
    initializer[] = {
        name = enableIOB
        value = true
    }
    initializer[] = {
        name = enableRayStabbing
        value = false
    }
    initializer[] = {
        name = enableWallThickness
        value = false
    }
    initializer[] = {
        name = voxelClassFilled
        value = VOXEL_CLASS_FILLED
    }
    initializer[] = {
        name = voxelClassInside
        value = VOXEL_CLASS_INSIDE
    }
    initializer[] = {
        name = voxelClassOutside
        value = VOXEL_CLASS_OUTSIDE
    }
    initializer[] = {
        name = voxelClassBoundary
        value = VOXEL_CLASS_BOUNDARY
    }
    initializer[] = {
        name = tolerance
        value = DEFAULT_TOLERANCE
    }
    initializer[] = {
        name = rayAxis
        value = Ionflux::GeoUtils::AXIS_UNDEFINED
    }
    initializer[] = {
        name = minWallThickness
        value = 0
    }
    initializer[] = {
        name = fillInsideOnly
        value = true
    }
    initializer[] = {
        name = maxNumWallThicknessPasses
        value = 0
    }
    impl = 
}
constructor.public[] = {
    initializer[] = {
        name = context
        value = 0
    }
    initializer[] = {
        name = hitDataType
        value = initHitDataType
    }
    initializer[] = {
        name = voxelClassHit
        value = initVoxelClassHit
    }
    initializer[] = {
        name = leafStatus
        value = initLeafStatus
    }
    initializer[] = {
        name = ray
        value = 0
    }
    initializer[] = {
        name = enableBoundaryData
        value = initEnableBoundaryData
    }
    initializer[] = {
        name = targetDepth
        value = initTargetDepth
    }
    initializer[] = {
        name = fillNewIntersections
        value = initFillNewIntersections
    }
    initializer[] = {
        name = pruneEmptyNewIntersections
        value = initPruneEmptyNewIntersections
    }
    initializer[] = {
        name = enableIOB
        value = initEnableIOB
    }
    initializer[] = {
        name = enableRayStabbing
        value = initEnableRayStabbing
    }
    initializer[] = {
        name = enableWallThickness
        value = initEnableWallThickness
    }
    initializer[] = {
        name = voxelClassFilled
        value = initVoxelClassFilled
    }
    initializer[] = {
        name = voxelClassInside
        value = initVoxelClassInside
    }
    initializer[] = {
        name = voxelClassOutside
        value = initVoxelClassOutside
    }
    initializer[] = {
        name = voxelClassBoundary
        value = initVoxelClassBoundary
    }
    initializer[] = {
        name = tolerance
        value = initTolerance
    }
    initializer[] = {
        name = rayAxis
        value = Ionflux::GeoUtils::AXIS_UNDEFINED
    }
    initializer[] = {
        name = minWallThickness
        value = initMinWallThickness
    }
    initializer[] = {
        name = fillInsideOnly
        value = initFillInsideOnly
    }
    initializer[] = {
        name = maxNumWallThicknessPasses
        value = initMaxNumWallThicknessPasses
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = initContext
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = initHitDataType
        desc = node data type for ray hits
        default = Node::DATA_TYPE_UNKNOWN
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = initVoxelClassHit
        desc = voxel class for ray hits
        default = VOXEL_CLASS_UNDEFINED
    }
    param[] = {
        type = Ionflux::VolGfx::LeafStatusID
        name = initLeafStatus
        desc = leaf status
        default = NODE_LEAF
    }
    param[] = {
        type = Ionflux::GeoUtils::Line3*
        name = initRay
        desc = Ray
        default = 0
    }
    param[] = {
        type = bool
        name = initEnableBoundaryData
        desc = enable boundary data flag
        default = false
    }
    param[] = {
        type = int
        name = initTargetDepth
        desc = target depth
        default = DEPTH_UNSPECIFIED
    }
    param[] = {
        type = bool
        name = initFillNewIntersections
        desc = fill nodes that are created for new intersections
        default = true
    }
    param[] = {
        type = bool
        name = initPruneEmptyNewIntersections
        desc = prune empty nodes that are created for new intersections
        default = false
    }
    param[] = {
        type = bool
        name = initEnableIOB
        desc = Enable inside/outside/boundary classification
        default = true
    }
    param[] = {
        type = bool
        name = initEnableRayStabbing
        desc = mark nodes with zero intersections as outside (ray-stabbing)
        default = false
    }
    param[] = {
        type = bool
        name = initEnableWallThickness
        desc = enable wall thickness calculation
        default = false
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = initVoxelClassFilled
        desc = voxel class for 'filled' voxels
        default = VOXEL_CLASS_FILLED
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = initVoxelClassInside
        desc = voxel class for 'inside' voxels
        default = VOXEL_CLASS_INSIDE
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = initVoxelClassOutside
        desc = voxel class for 'outside' voxels
        default = VOXEL_CLASS_OUTSIDE
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = initVoxelClassBoundary
        desc = voxel class for 'boundary' voxels
        default = VOXEL_CLASS_BOUNDARY
    }
    param[] = {
        type = double
        name = initTolerance
        desc = tolerance for comparisons
        default = DEFAULT_TOLERANCE
    }
    param[] = {
        type = unsigned int
        name = initMinWallThickness
        desc = Minimum wall thickness
        default = 0
    }
    param[] = {
        type = bool
        name = initFillInsideOnly
        desc = Fill 'inside' nodes only when fixing the minimum wall thickness
        default = true
    }
    param[] = {
        type = unsigned int
        name = initMaxNumWallThicknessPasses
        desc = Maximum number of passes for fixing wall thickness
        default = 0
    }
    impl = <<<
if (initContext != 0)
    setContext(initContext);
if (initRay != 0)
    setRay(initRay);
>>>
}

# Destructor.
destructor.impl = 

# copy assignment operator
function.copy.impl = <<<
if (this == &other)
    return *this;
clearIntersections();
for (NodeIntersectionVector::const_iterator i = 
    other.intersections.begin(); i != other.intersections.end(); i++)
    intersections.push_back(*i);
setContext(other.context);
setHitDataType(other.hitDataType);
setVoxelClassHit(other.voxelClassHit);
setLeafStatus(other.leafStatus);
setLeafStatus(other.leafStatus);
setRay(other.ray);
setEnableBoundaryData(other.enableBoundaryData);
setPruneEmptyNewIntersections(other.targetDepth);
setEnableIOB(other.enableIOB);
setEnableRayStabbing(other.enableRayStabbing);
setVoxelClassFilled(other.voxelClassFilled);
setVoxelClassInside(other.voxelClassInside);
setVoxelClassOutside(other.voxelClassOutside);
setVoxelClassBoundary(other.voxelClassBoundary);
setTolerance(other.tolerance);
setMinWallThickness(other.minWallThickness);
setFillInsideOnly(other.fillInsideOnly);
setMaxNumWallThicknessPasses(other.maxNumWallThicknessPasses);
>>>

# protected member functions
function.protected[] = {
	spec = virtual
	type = void
	name = updateIntersections
	shortDesc = Update node intersections
	longDesc = Update the current sequence of node intersections from the updated sequence of node intersections.
    param[] = {
        type = bool
        name = reverse
        desc = reverse the order of intersections
        default = false
    }
	impl = <<<
// <---- DEBUG ----- //
for (unsigned int i = 0; i < updatedIntersections.size(); i++)
{
    NodeIntersection ci0 = updatedIntersections[i];
    NodeImpl* ni0 = ci0.nodeImpl;
    LeafStatusID ls0 = Node::getImplLeafStatus(ni0);
    NodeID nid0 = Node::getImplNodeID(ni0, context);
    if ((leafStatus != NODE_ANY) 
        && (ls0 != leafStatus))
    {
        std::ostringstream status;
        status << "Leaf status flag mismatch for updated node #" << i 
            << " " << ni0 << " [" << getNodeIDValueString(nid0, 
                false, true, true, context) << "]" 
            << " (current: " << getLeafStatusValueString(ls0) 
            << ", expected: " << getLeafStatusValueString(leafStatus) 
            << ").";
        throw IFVGError(getErrorString(status.str(), 
            "updateIntersections"));
    }
}
// ----- DEBUG ----> */
if (updatedIntersections.size() > intersections.size())
{
    if (!reverse)
        intersections = updatedIntersections;
    else
    {
        clearIntersections();
        unsigned int n0 = updatedIntersections.size();
        for (unsigned int i = 0; i < n0; i++)
        {
            NodeIntersection ci0 = updatedIntersections[n0 - i - 1];
            intersections.push_back(ci0);
        }
    }
}
updatedIntersections.clear();
>>>
}
function.protected[] = {
	spec = virtual
	type = Ionflux::VolGfx::NodeProcessingResultID
	name = processImpl
	shortDesc = Process node implementation
	longDesc = Process a node implementation. \c userData is expected to contain a pointer to a NodeIntersection data record for \c nodeImpl.
	param[] = {
	    type = Ionflux::VolGfx::NodeImpl*
	    name = nodeImpl
	    desc = Node implementation
	}
	param[] = {
	    type = void*
	    name = userData
	    desc = User data
	    default = 0
	}
	impl = <<<
if (userData == 0)
    return RESULT_OK;
const NodeIntersection* ni = 
    reinterpret_cast<const NodeIntersection*>(userData);
processIntersection(*ni, userData);
>>>
    return = {
        value = RESULT_OK
        desc = result
    }
}
function.protected[] = {
	spec = virtual
	type = void
	name = processIntersectionsIOB
	shortDesc = Process node intersections (inside/outside/boundary)
	longDesc = Process node intersections from a vector.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersectionVector&
	    name = intersections0
	    desc = node intersections
	}
	param[] = {
	    type = Ionflux::VolGfx::VoxelClassID&
	    name = state
	    desc = current state
	}
	param[] = {
	    type = unsigned int&
	    name = numIntersections0
	    desc = current number of intersections
	}
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags
	    name = processingFlags
	    desc = processing flags
	}
	param[] = {
	    type = unsigned int*
	    name = wallThickness
	    desc = current wall thickness
	    default = 0
	}
	param[] = {
	    type = unsigned int*
	    name = maxWallThickness
	    desc = current maximum wall thickness
	    default = 0
	}
	impl = <<<
unsigned int n0 = intersections0.size();
if (n0 == 0)
    return;
if (processingFlags.enableWallThickness)
{
    Ionflux::ObjectBase::nullPointerCheck(wallThickness, this,  
        "processIntersectionsWallThickness", "Wall thickness counter");
    Ionflux::ObjectBase::nullPointerCheck(maxWallThickness, this,  
        "processIntersectionsWallThickness", 
        "Maximum wall thickness counter");
}
if (!processingFlags.directionBackward)
{
    for (unsigned int i = 0; i < n0; i++)
    {
        NodeIntersection ci0 = intersections0[i];
        processIOBStep(ci0, state, numIntersections0, processingFlags, 
            wallThickness, maxWallThickness);
    }
} else
{
    for (unsigned int i = n0; i > 0; i--)
    {
        NodeIntersection ci0 = intersections0[i - 1];
        processIOBStep(ci0, state, numIntersections0, processingFlags, 
            wallThickness, maxWallThickness);
    }
}
>>>
}
function.protected[] = {
	spec = virtual
	type = void
	name = createAndProcessIntersectionsIOB
	shortDesc = Insert and process node intersections (inside/outside/boundary)
	longDesc = Create new node intersections by inserting a node at the near or far intersection point for the specified intersections and process the new intersections recursively.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersection&
	    name = intersection0
	    desc = node intersection
	}
	param[] = {
	    type = bool
	    name = createNear
	    desc = Create node for near intersection
	}
	param[] = {
	    type = bool
	    name = createFar
	    desc = Create node for far intersection
	}
	param[] = {
	    type = Ionflux::VolGfx::VoxelClassID&
	    name = state
	    desc = current state
	}
	param[] = {
	    type = unsigned int&
	    name = numIntersections0
	    desc = current number of intersections
	}
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags
	    name = processingFlags
	    desc = processing flags
	}
	param[] = {
	    type = unsigned int*
	    name = wallThickness
	    desc = current wall thickness
	    default = 0
	}
	param[] = {
	    type = unsigned int*
	    name = maxWallThickness
	    desc = current maximum wall thickness
	    default = 0
	}
	impl = <<<
NodeIntersectionVector niv0;
unsigned int n0 = createIntersections(intersection0, 
    niv0, createNear, createFar);
if (n0 == 0)
{
    throw IFVGError(getErrorString(
        "Could not create new node intersections.", 
        "createAndProcessIntersectionsIOB"));
}
// process new intersections recursively
processIntersectionsIOB(niv0, state, numIntersections0, 
    processingFlags, wallThickness, maxWallThickness);
>>>
}
function.protected[] = {
	spec = virtual
	type = void
	name = processIOBStep
	shortDesc = Process inside/outside/boundary data step
	longDesc = Process a single step of the inside/outside/boundary data iteration. This function is used by setIOBData() and should not be called directly.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersection&
	    name = intersection0
	    desc = node intersection data
	}
	param[] = {
	    type = Ionflux::VolGfx::VoxelClassID&
	    name = state
	    desc = current state
	}
	param[] = {
	    type = unsigned int&
	    name = numIntersections0
	    desc = current number of intersections
	}
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags
	    name = processingFlags
	    desc = processing flags
	}
	param[] = {
	    type = unsigned int*
	    name = wallThickness
	    desc = current wall thickness
	    default = 0
	}
	param[] = {
	    type = unsigned int*
	    name = maxWallThickness
	    desc = current maximum wall thickness
	    default = 0
	}
	impl = <<<
if (processingFlags.enableBoundaryData 
    || processingFlags.enableWallThickness)
{
    Ionflux::ObjectBase::nullPointerCheck(
        context, this, "processIOBStep", "Context");
}
NodeImpl* ni = Ionflux::ObjectBase::nullPointerCheck(
    intersection0.nodeImpl, this, "processIOBStep", 
    "Node implementation");
int maxNumLevels = DEPTH_UNSPECIFIED;
bool createNear = false;
bool createFar = false;
if (processingFlags.enableBoundaryData)
{
    // parameters required for boundary voxel classification
    maxNumLevels = context->getMaxNumLevels();
    if ((targetDepth < 0) 
        || (targetDepth >= maxNumLevels))
        targetDepth = maxNumLevels - 1;
    if (!processingFlags.directionBackward)
    {
        // ray enters boundary voxel at near intersection point
        createNear = true;
        createFar = false;
    } else
    {
        // ray leaves boundary voxel at far intersection point
        createNear = false;
        createFar = true;
    }
}
LeafStatusID ls0 = Node::getImplLeafStatus(ni);
if ((leafStatus != NODE_ANY) 
    && (ls0 != leafStatus))
{
    std::ostringstream status;
    status << "Leaf status flag mismatch (current: " 
        << getLeafStatusValueString(ls0) << ", expected: " 
        << getLeafStatusValueString(leafStatus) << ").";
    throw IFVGError(getErrorString(status.str(), "processIOBStep"));
}
unsigned int wtStep = 0;
if (processingFlags.enableWallThickness)
{
    if (rayAxis == Ionflux::GeoUtils::AXIS_UNDEFINED)
    {
        processingFlags.enableWallThickness = false;
    } else 
    {
        // parameters required for wall thickness calculation
        wtStep = context->getDepthMask(intersection0.depth).to_ulong();
    }
}
VoxelClassID vc = Node::getImplVoxelClass(ni);
/* <---- DEBUG ----- //
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "processIOBStep", "Context");
NodeID nid0 = Node::getImplNodeID(ni, context);
std::cerr << "[NodeIntersectionProcessor::processIOBStep] DEBUG: ";
if (directionBackward)
    std::cerr << "(backward) ";
std::cerr << "node: [" << getNodeIDValueString(nid0, 
    true, true, true, context) 
    << "] voxelClass = " << getVoxelClassValueString(vc) 
    << ", state = " << getVoxelClassValueString(state) 
    << ", numIntersections = " << numIntersections0;
if (enableWallThickness0)
{
    std::cerr << ", rayAxis = " 
        << Ionflux::GeoUtils::axisToString(rayAxis)
        << ", wallThickness = " << *wallThickness 
        << ", maxWallThickness = " << *maxWallThickness 
        << ", wtStep = " << wtStep;
}
std::cerr << std::endl;
// ----- DEBUG ----> */
/* set current state according to previous state and current 
   voxel class */
VoxelClassID ps = state;
bool split0 = false;
bool boundary = false;
VoxelDataIOB* d0 = 0;
if (ps == VOXEL_CLASS_UNDEFINED)
{
    if (checkVoxelClass(vc, voxelClassFilled))
    {
        state = VOXEL_CLASS_INSIDE;
        if (processingFlags.enableWallThickness)
        {
            // initialize wall thickness data for inside voxel
            *wallThickness = wtStep;
            d0 = getIOBData(intersection0);
            *maxWallThickness = getIOBDataWallThickness(*d0, rayAxis);
            /* <---- DEBUG ----- //
            std::cerr << "[NodeIntersectionProcessor::"
                "processIOBStep] DEBUG: "
                << "(undefined -> inside) "
                    "initializing wall thickness data (" 
                << "wallThickness = " << *wallThickness 
                << ", maxWallThickness = " << *maxWallThickness << ")" 
                << std::endl;
            // ----- DEBUG ----> */
        }
    } else
        state = VOXEL_CLASS_OUTSIDE;
} else
if (ps == VOXEL_CLASS_INSIDE)
{
    if (!checkVoxelClass(vc, voxelClassFilled))
    {
        // inside -> outside
        if (processingFlags.enableWallThickness)
        {
            // reset wall thickness data
            *wallThickness = 0;
            *maxWallThickness = 0;
            /* <---- DEBUG ----- //
            std::cerr << "[NodeIntersectionProcessor::"
                "processIOBStep] DEBUG: "
                << "(inside -> outside) resetting wall thickness data (" 
                << "wallThickness = " << *wallThickness 
                << ", maxWallThickness = " << *maxWallThickness << ")" 
                << std::endl;
            // ----- DEBUG ----> */
        }
        if (processingFlags.enableBoundaryData)
        {
            if (intersection0.depth == targetDepth)
            {
                // boundary voxel at target depth
                boundary = true;
            } else
            {
                // insert boundary voxel at target depth
                createAndProcessIntersectionsIOB(intersection0, 
                    createNear, createFar, state, numIntersections0, 
                    processingFlags, wallThickness, maxWallThickness);
                split0 = true;
            }
        }
        if (!split0)
        {
            state = VOXEL_CLASS_OUTSIDE;
            numIntersections0++;
        }
    } else
    {
        // inside -> inside
        if (processingFlags.enableWallThickness)
        {
            *wallThickness += wtStep;
            /* <---- DEBUG ----- //
            std::cerr << "[NodeIntersectionProcessor::"
                "processIOBStep] DEBUG: "
                << "(inside -> inside) " 
                << "wallThickness = " << *wallThickness 
                << ", maxWallThickness = " << *maxWallThickness 
                << std::endl;
            // ----- DEBUG ----> */
        }
    }
} else
if (ps == VOXEL_CLASS_OUTSIDE)
{
    if (checkVoxelClass(vc, voxelClassFilled))
    {
        // outside -> inside
        state = VOXEL_CLASS_INSIDE;
        if (processingFlags.enableWallThickness)
        {
            // initialize wall thickness data for inside voxel
            *wallThickness = wtStep;
            d0 = getIOBData(intersection0);
            *maxWallThickness = getIOBDataWallThickness(*d0, rayAxis);
            /* <---- DEBUG ----- //
            std::cerr << "[NodeIntersectionProcessor::"
                "processIOBStep] DEBUG: "
                << "(outside -> inside) initializing wall thickness "
                    "for inside voxel (" 
                << "wallThickness = " << *wallThickness 
                << ", maxWallThickness = " << *maxWallThickness << ")"
                << std::endl;
            // ----- DEBUG ----> */
        }
    }
}
if (split0)
{
    // node intersection has been split and processed recursively
    return;
}
// update the node data
if (d0 == 0)
    d0 = getIOBData(intersection0);
if (!processingFlags.directionBackward)
{
    // foward iteration
    d0->numInts0 = numIntersections0;
    if (boundary)
    {
        // set boundary faces
        d0->boundaryFaces |= intersection0.intersection.nearPlane;
    }
} else
{
    // backward iteration
    d0->numInts1 = numIntersections0;
    if (processingFlags.enableRayStabbing 
        && ((d0->numInts0 == 0)
            || (d0->numInts1 == 0)))
    {
        // set node with zero intersections to outside (ray-stabbing)
        vc |= voxelClassOutside;
    }
    if (processingFlags.castVotes)
    {
        // set ray votes
        if ((d0->numInts0 % 2) == 0)
            d0->votesOutside++;
        else
            d0->votesInside++;
        if ((d0->numInts1 % 2) == 0)
            d0->votesOutside++;
        else
            d0->votesInside++;
    }
    if (boundary)
    {
        // set boundary faces
        d0->boundaryFaces |= intersection0.intersection.farPlane;
    }
}
if (boundary)
    setVoxelClass(voxelClassBoundary, vc);
setVoxelClass(vc, d0->voxelClass);
if (processingFlags.enableWallThickness)
{
    unsigned int wt0 = *wallThickness;
    if (*maxWallThickness > wt0)
        wt0 = *maxWallThickness;
    /* <---- DEBUG ----- //
    std::cerr << "[NodeIntersectionProcessor::"
        "processIOBStep] DEBUG: setting wall thickness = " 
        << wt0 << std::endl;
    // ----- DEBUG ----> */
    setIOBDataWallThickness(*d0, rayAxis, wt0);
}
/* <---- DEBUG ----- //
NodeID nid0 = Node::getImplNodeID(ni, context);
std::cerr << "[NodeIntersectionProcessor::"
    "processIOBStep] DEBUG: ";
if (processingFlags.directionBackward)
    std::cerr << "(backward) ";
std::cerr << "finished node: " << ni 
    << " [" << getNodeIDValueString(nid0, 
        false, true, true, context) 
    << "] voxelClass = " << getVoxelClassValueString(vc) 
    << ", state = " << getVoxelClassValueString(state);
std::cerr << std::endl;
// ----- DEBUG ----> */
updatedIntersections.push_back(intersection0);
>>>
}
function.protected[] = {
	spec = virtual
	type = void
	name = processIntersectionsWallThickness
	shortDesc = Process node intersections (wall thickness)
	longDesc = Process node intersections from a vector. This function assigns wall thickness values to nodes intersected by the ray. The function will also fix the minimum wall thickness of sequences of filled nodes if \c minWallThickness is greater than zero.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersectionVector&
	    name = intersections0
	    desc = node intersections
	}
	param[] = {
	    type = Ionflux::VolGfx::VoxelClassID&
	    name = state
	    desc = current state
	}
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags
	    name = processingFlags
	    desc = processing flags
	}
	param[] = {
	    type = unsigned int&
	    name = wallThickness
	    desc = current wall thickness
	}
	param[] = {
	    type = unsigned int&
	    name = maxWallThickness
	    desc = current maximum wall thickness
	}
	param[] = {
	    type = unsigned int
	    name = minWallThickness0
	    desc = minimum wall thickness
	    default = 0
	}
	param[] = {
	    type = unsigned int
	    name = maxNumFillNodes
	    desc = maximum number of nodes to be filled per component and direction
	    default = 0
	}
	param[] = {
	    type = bool
	    name = insideOnly
	    desc = only fill nodes that are classified as 'inside'
	    default = true
	}
	param[] = {
	    type = unsigned int*
	    name = numThinComponents
	    desc = number of components that have a wall thickness below the minimum
	    default = 0
	}
	param[] = {
	    type = unsigned int*
	    name = numNodesFilled
	    desc = number of nodes filled for the current component and direction
	    default = 0
	}
	impl = <<<
unsigned int n0 = intersections0.size();
if (n0 == 0)
    return;
if (minWallThickness > 0)
{
    Ionflux::ObjectBase::nullPointerCheck(numThinComponents, this,  
        "processIntersectionsWallThickness", "Thin component counter");
    Ionflux::ObjectBase::nullPointerCheck(numNodesFilled, this,  
        "processIntersectionsWallThickness", "Filled nodes counter");
}
if (!processingFlags.directionBackward)
{
    for (unsigned int i = 0; i < n0; i++)
    {
        NodeIntersection ci0 = intersections0[i];
        processWallThicknessStep(ci0, state, processingFlags, 
            wallThickness, maxWallThickness, minWallThickness0, 
            maxNumFillNodes, insideOnly, numThinComponents, 
            numNodesFilled);
    }
} else
{
    for (unsigned int i = n0; i > 0; i--)
    {
        NodeIntersection ci0 = intersections0[i - 1];
        processWallThicknessStep(ci0, state, processingFlags, 
            wallThickness, maxWallThickness, minWallThickness0, 
            maxNumFillNodes, insideOnly, numThinComponents, 
            numNodesFilled);
    }
}
>>>
}
function.protected[] = {
	spec = virtual
	type = void
	name = createAndProcessIntersectionsWallThickness
	shortDesc = Insert and process node intersections (wall thickness)
	longDesc = Create new node intersections by inserting a node at the near or far intersection point for the specified intersections and process the new intersections recursively.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersection&
	    name = intersection0
	    desc = node intersection
	}
	param[] = {
	    type = bool
	    name = createNear
	    desc = Create node for near intersection
	}
	param[] = {
	    type = bool
	    name = createFar
	    desc = Create node for far intersection
	}
	param[] = {
	    type = Ionflux::VolGfx::VoxelClassID&
	    name = state
	    desc = current state
	}
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags
	    name = processingFlags
	    desc = processing flags
	}
	param[] = {
	    type = unsigned int&
	    name = wallThickness
	    desc = current wall thickness
	}
	param[] = {
	    type = unsigned int&
	    name = maxWallThickness
	    desc = current maximum wall thickness
	}
	param[] = {
	    type = unsigned int
	    name = minWallThickness0
	    desc = minimum wall thickness
	    default = 0
	}
	param[] = {
	    type = unsigned int
	    name = maxNumFillNodes
	    desc = maximum number of nodes to be filled per component and direction
	    default = 0
	}
	param[] = {
	    type = bool
	    name = insideOnly
	    desc = only fill nodes that are classified as 'inside'
	    default = true
	}
	param[] = {
	    type = unsigned int*
	    name = numThinComponents
	    desc = number of components that have a wall thickness below the minimum
	    default = 0
	}
	param[] = {
	    type = unsigned int*
	    name = numNodesFilled
	    desc = number of nodes filled for the current component and direction
	    default = 0
	}
	impl = <<<
NodeIntersectionVector niv0;
unsigned int n0 = createIntersections(intersection0, 
    niv0, createNear, createFar);
if (n0 == 0)
{
    throw IFVGError(getErrorString(
        "Could not create new node intersections.", 
        "createAndProcessIntersectionsWallThickness"));
}
// process new intersections recursively
processIntersectionsWallThickness(niv0, state, processingFlags, 
    wallThickness, maxWallThickness, minWallThickness0, maxNumFillNodes, 
    insideOnly, numThinComponents, numNodesFilled);
>>>
}
function.protected[] = {
	spec = virtual
	type = void
	name = processWallThicknessStep
	shortDesc = Process wall thickness step
	longDesc = Process a single step of the wall thickness iteration. If \c minWallThickness is greater than zero, the function will attempt to fill nodes at the target depth level to increase the wall thickness, according to the specified constraints. If \c maxNumFillNodes is greater than zero, this value specifies the maximum number of nodes filled per component and direction to increase the wall thickness. If \c insideOnly is set to \c true, only nodes that are classified as 'inside' will be filled. This function is used by processWallThickness() and should not be called directly.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersection&
	    name = intersection0
	    desc = node intersection data
	}
	param[] = {
	    type = Ionflux::VolGfx::VoxelClassID&
	    name = state
	    desc = current state
	}
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags
	    name = processingFlags
	    desc = processing flags
	}
	param[] = {
	    type = unsigned int&
	    name = wallThickness
	    desc = current wall thickness
	}
	param[] = {
	    type = unsigned int&
	    name = maxWallThickness
	    desc = current maximum wall thickness
	}
	param[] = {
	    type = unsigned int
	    name = minWallThickness0
	    desc = minimum wall thickness
	    default = 0
	}
	param[] = {
	    type = unsigned int
	    name = maxNumFillNodes
	    desc = maximum number of nodes to be filled per component and direction
	    default = 0
	}
	param[] = {
	    type = bool
	    name = insideOnly
	    desc = only fill nodes that are classified as 'inside'
	    default = true
	}
	param[] = {
	    type = unsigned int*
	    name = numThinComponents
	    desc = number of components that have a wall thickness below the minimum
	    default = 0
	}
	param[] = {
	    type = unsigned int*
	    name = numNodesFilled
	    desc = number of nodes filled for the current component and direction
	    default = 0
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(
    context, this, "processWallThicknessStep", "Context");
NodeImpl* ni = Ionflux::ObjectBase::nullPointerCheck(
    intersection0.nodeImpl, this, "processWallThicknessStep", 
    "Node implementation");
int maxNumLevels = context->getMaxNumLevels();
bool createNear = false;
bool createFar = false;
if ((targetDepth < 0) 
    || (targetDepth >= maxNumLevels))
    targetDepth = maxNumLevels - 1;
if (!processingFlags.directionBackward)
{
    // ray enters boundary voxel at near intersection point
    createNear = true;
    createFar = false;
} else
{
    // ray leaves boundary voxel at far intersection point
    createNear = false;
    createFar = true;
}
LeafStatusID ls0 = Node::getImplLeafStatus(ni);
if ((leafStatus != NODE_ANY) 
    && (ls0 != leafStatus))
{
    std::ostringstream status;
    status << "Leaf status flag mismatch (current: " 
        << getLeafStatusValueString(ls0) << ", expected: " 
        << getLeafStatusValueString(leafStatus) << ").";
    throw IFVGError(getErrorString(status.str(), 
        "processWallThicknessStep"));
}
if (rayAxis == Ionflux::GeoUtils::AXIS_UNDEFINED)
{
    throw IFVGError(getErrorString("Ray axis is undefined", 
        "processWallThicknessStep"));
}
unsigned int wtStep = context->getDepthMask(
    intersection0.depth).to_ulong();
bool fillNodes = false;
if (minWallThickness0 > 0)
    fillNodes = true;
VoxelClassID vc = Node::getImplVoxelClass(ni);
/* <---- DEBUG ----- //
NodeID nid0 = Node::getImplNodeID(ni, context);
// ----- DEBUG ----> */
/* <---- DEBUG ----- //
std::cerr << "[NodeIntersectionProcessor::"
    "processWallThicknessStep] DEBUG: ";
if (processingFlags.directionBackward)
    std::cerr << "(backward) ";
std::cerr << "begin node: [" << getNodeIDValueString(nid0, 
    false, true, true, context) 
    << "] voxelClass = " << getVoxelClassValueString(vc) 
    << ", state = " << getVoxelClassValueString(state) 
    << ", wallThickness = " << wallThickness 
    << ", minWallThickness = " << minWallThickness
    << ", maxWallThickness = " << maxWallThickness
    << ", numNodesFilled = " << *numNodesFilled
    << ", numThinComponents = " << *numThinComponents
    << ", fillNodes = " 
        << Ionflux::ObjectBase::getBooleanValueString(fillNodes);
std::cerr << std::endl;
// ----- DEBUG ----> */
/* set current state according to previous state and current 
   voxel class */
VoxelClassID ps = state;
bool split0 = false;
bool filled = false;
bool boundary = false;
VoxelDataIOB* d0 = 0;
if (ps == VOXEL_CLASS_UNDEFINED)
{
    if (checkVoxelClass(vc, voxelClassFilled))
    {
        state = VOXEL_CLASS_INSIDE;
        // initialize wall thickness data for inside voxel
        wallThickness = wtStep;
        d0 = getIOBData(intersection0);
        maxWallThickness = getIOBDataWallThickness(*d0, rayAxis);
        if (fillNodes)
            *numNodesFilled = 0;
        /* <---- DEBUG ----- //
        std::cerr << "[NodeIntersectionProcessor::"
            "processWallThicknessStep] DEBUG: "
            << "(undefined -> inside) "
                "initializing wall thickness data (" 
            << "wallThickness = " << wallThickness 
            << ", maxWallThickness = " << maxWallThickness 
            << ", numNodesFilled = " << *numNodesFilled << ")" 
            << std::endl;
        // ----- DEBUG ----> */
    } else
        state = VOXEL_CLASS_OUTSIDE;
} else
if (ps == VOXEL_CLASS_INSIDE)
{
    if (!checkVoxelClass(vc, voxelClassFilled))
    {
        // inside -> outside
        unsigned int wt0 = wallThickness;
        if (maxWallThickness > wt0)
            wt0 = maxWallThickness;
        if (fillNodes 
            && (wt0 < minWallThickness0))
        {
            // thin component
            if ((!insideOnly 
                    || checkVoxelClass(vc, voxelClassInside)) 
                && ((maxNumFillNodes == 0) 
                    || (*numNodesFilled < maxNumFillNodes)))
            {
                // current node can be filled
                if (intersection0.depth == targetDepth)
                {
                    // voxel at target depth
                    /* <---- DEBUG ----- //
                    std::cerr << "[NodeIntersectionProcessor::"
                        "processWallThicknessStep] DEBUG: "
                        << "(inside -> outside) "
                            "filling node at target depth (" 
                        << "wallThickness = " << wallThickness 
                        << ", wt0 = " << wt0 
                        << ", minWallThickness = " << minWallThickness 
                        << ", maxWallThickness = " << maxWallThickness 
                        << ", numNodesFilled = " << *numNodesFilled 
                        << ", maxNumFillNodes = " << maxNumFillNodes
                        << ")" << std::endl;
                    // ----- DEBUG ----> */
                    filled = true;
                } else
                {
                    // insert voxel at target depth
                    /* <---- DEBUG ----- //
                    std::cerr << "[NodeIntersectionProcessor::"
                        "processWallThicknessStep] DEBUG: "
                        << "(inside -> outside) "
                            "inserting node at target depth (" 
                        << "wallThickness = " << wallThickness 
                        << ", wt0 = " << wt0 
                        << ", minWallThickness = " << minWallThickness 
                        << ", maxWallThickness = " << maxWallThickness 
                        << ", numNodesFilled = " << *numNodesFilled 
                        << ", maxNumFillNodes = " << maxNumFillNodes
                        << ")" << std::endl;
                    // ----- DEBUG ----> */
                    createAndProcessIntersectionsWallThickness(
                        intersection0, createNear, createFar, state, 
                        processingFlags, wallThickness, maxWallThickness, 
                        minWallThickness0, maxNumFillNodes, insideOnly, 
                        numThinComponents, numNodesFilled);
                    split0 = true;
                }
            }
        }
        if (!split0)
        {
            if (!filled)
            {
                if (processingFlags.enableBoundaryData)
                {
                    if (intersection0.depth == targetDepth)
                    {
                        // boundary voxel at target depth
                        /* <---- DEBUG ----- //
                        std::cerr << "[NodeIntersectionProcessor::"
                            "processWallThicknessStep] DEBUG: "
                            << "(inside -> outside) "
                                "boundary node at target depth" 
                            << std::endl;
                        // ----- DEBUG ----> */
                        boundary = true;
                    } else
                    {
                        // insert boundary voxel at target depth
                        /* <---- DEBUG ----- //
                        std::cerr << "[NodeIntersectionProcessor::"
                            "processWallThicknessStep] DEBUG: "
                            << "(inside -> outside) "
                                "inserting boundary node at target depth" 
                            << std::endl;
                        // ----- DEBUG ----> */
                        createAndProcessIntersectionsWallThickness(
                            intersection0, createNear, createFar, state, 
                            processingFlags, wallThickness, maxWallThickness, 
                            minWallThickness0, maxNumFillNodes, insideOnly, 
                            numThinComponents, numNodesFilled);
                        split0 = true;
                    }
                }
                if (!split0)
                {
                    // reset wall thickness data
                    wallThickness = 0;
                    maxWallThickness = 0;
                    if (wt0 < minWallThickness0)
                        (*numThinComponents)++;
                    /* <---- DEBUG ----- //
                    std::cerr << "[NodeIntersectionProcessor::"
                        "processWallThicknessStep] DEBUG: "
                        << "(inside -> outside) resetting wall thickness "
                            "data (" 
                        << "wallThickness = " << wallThickness 
                        << ", maxWallThickness = " << maxWallThickness 
                        << ", numThinComponents = " << *numThinComponents 
                        << ")" << std::endl;
                    // ----- DEBUG ----> */
                    state = VOXEL_CLASS_OUTSIDE;
                }
            } else
            {
                // still inside because the current node has been filled
                wallThickness += wtStep;
                /* <---- DEBUG ----- //
                std::cerr << "[NodeIntersectionProcessor::"
                    "processWallThicknessStep] DEBUG: "
                    << "(inside -> inside) node filled (" 
                    << "wallThickness = " << wallThickness 
                    << ", maxWallThickness = " << maxWallThickness 
                    << ", numNodesFilled = " << *numNodesFilled 
                    << ", maxNumFillNodes = " << maxNumFillNodes
                    << ")" << std::endl;
                // ----- DEBUG ----> */
            }
        }
    } else
    {
        // inside -> inside
        wallThickness += wtStep;
        /* <---- DEBUG ----- //
        std::cerr << "[NodeIntersectionProcessor::"
            "processWallThicknessStep] DEBUG: "
            << "(inside -> inside) " 
            << "wallThickness = " << wallThickness 
            << ", maxWallThickness = " << maxWallThickness 
            << std::endl;
        // ----- DEBUG ----> */
    }
} else
if (ps == VOXEL_CLASS_OUTSIDE)
{
    if (checkVoxelClass(vc, voxelClassFilled))
    {
        // outside -> inside
        state = VOXEL_CLASS_INSIDE;
        // initialize wall thickness data for inside voxel
        wallThickness = wtStep;
        d0 = getIOBData(intersection0);
        maxWallThickness = getIOBDataWallThickness(*d0, rayAxis);
        if (fillNodes)
            *numNodesFilled = 0;
        /* <---- DEBUG ----- //
        std::cerr << "[NodeIntersectionProcessor::"
            "processWallThicknessStep] DEBUG: "
            << "(outside -> inside) initializing wall thickness "
                "for inside voxel (" 
            << "wallThickness = " << wallThickness 
            << ", maxWallThickness = " << maxWallThickness << ")" 
            << std::endl;
        // ----- DEBUG ----> */
    }
}
if (split0)
{
    // node intersection has been split and processed recursively
    return;
}
// update wall thickness for the node
if (d0 == 0)
    d0 = getIOBData(intersection0);
if (filled)
{
    setVoxelClass(voxelClassInside | voxelClassOutside 
        | voxelClassBoundary | VOXEL_CLASS_EMPTY, vc, false);
    setVoxelClass(voxelClassFilled, vc);
    d0->boundaryFaces = FACE_UNDEFINED;
    (*numNodesFilled)++;
} else
if (boundary)
{
    setVoxelClass(voxelClassBoundary, vc);
    if (!processingFlags.directionBackward)
        d0->boundaryFaces |= intersection0.intersection.nearPlane;
    else
        d0->boundaryFaces |= intersection0.intersection.farPlane;
}
d0->voxelClass = vc;
unsigned int wt0 = wallThickness;
if (maxWallThickness > wt0)
    wt0 = maxWallThickness;
setIOBDataWallThickness(*d0, rayAxis, wt0);
/* <---- DEBUG ----- //
std::cerr << "[NodeIntersectionProcessor::"
    "processWallThicknessStep] DEBUG: ";
if (processingFlags.directionBackward)
    std::cerr << "(backward) ";
std::cerr << "finished node: [" << getNodeIDValueString(nid0, 
    false, true, true, context) 
    << "] voxelClass = " << getVoxelClassValueString(vc) 
    << ", state = " << getVoxelClassValueString(state) 
    << ", wallThickness = " << wallThickness 
    << ", maxWallThickness = " << maxWallThickness
    << ", numNodesFilled = " << *numNodesFilled
    << ", numThinComponents = " << *numThinComponents
    << ", wt0 = " << wt0;
std::cerr << std::endl;
// ----- DEBUG ----> */
updatedIntersections.push_back(intersection0);
>>>
}
function.protected[] = {
	spec = virtual
	type = void
	name = processIntersectionsBoundary
	shortDesc = Process node intersections (boundary)
	longDesc = Process node intersections from a vector.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersectionVector&
	    name = intersections0
	    desc = node intersections
	}
	param[] = {
	    type = Ionflux::VolGfx::VoxelClassID&
	    name = state
	    desc = current state
	}
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags
	    name = processingFlags
	    desc = processing flags
	}
	param[] = {
	    type = Ionflux::VolGfx::ColorIndex*
	    name = colorIndex
	    desc = color index
	    default = 0
	}
	impl = <<<
unsigned int n0 = intersections0.size();
if (n0 == 0)
    return;
if (!processingFlags.directionBackward)
{
    for (unsigned int i = 0; i < n0; i++)
    {
        NodeIntersection ci0 = intersections0[i];
        processBoundaryStep(ci0, state, processingFlags, colorIndex);
    }
} else
{
    for (unsigned int i = n0; i > 0; i--)
    {
        NodeIntersection ci0 = intersections0[i - 1];
        processBoundaryStep(ci0, state, processingFlags, colorIndex);
    }
}
>>>
}
function.protected[] = {
	spec = virtual
	type = void
	name = createAndProcessIntersectionsBoundary
	shortDesc = Insert and process node intersections (boundary)
	longDesc = Create new node intersections by inserting a node at the near or far intersection point for the specified intersections and process the new intersections recursively.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersection&
	    name = intersection0
	    desc = node intersection
	}
	param[] = {
	    type = bool
	    name = createNear
	    desc = Create node for near intersection
	}
	param[] = {
	    type = bool
	    name = createFar
	    desc = Create node for far intersection
	}
	param[] = {
	    type = Ionflux::VolGfx::VoxelClassID&
	    name = state
	    desc = current state
	}
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags
	    name = processingFlags
	    desc = processing flags
	}
	param[] = {
	    type = Ionflux::VolGfx::ColorIndex*
	    name = colorIndex
	    desc = color index
	    default = 0
	}
	impl = <<<
NodeIntersectionVector niv0;
unsigned int n0 = createIntersections(intersection0, 
    niv0, createNear, createFar);
if (n0 == 0)
{
    throw IFVGError(getErrorString(
        "Could not create new node intersections.", 
        "createAndProcessIntersectionsBoundary"));
}
// process new intersections recursively
processIntersectionsBoundary(niv0, state, processingFlags, colorIndex);
>>>
}
function.protected[] = {
	spec = virtual
	type = void
	name = processBoundaryStep
	shortDesc = Process boundary step
	longDesc = Process a single step of the boundary iteration.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersection&
	    name = intersection0
	    desc = node intersection data
	}
	param[] = {
	    type = Ionflux::VolGfx::VoxelClassID&
	    name = state
	    desc = current state
	}
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags
	    name = processingFlags
	    desc = processing flags
	}
	param[] = {
	    type = Ionflux::VolGfx::ColorIndex*
	    name = colorIndex
	    desc = color index
	    default = 0
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(
    context, this, "processBoundaryStep", "Context");
NodeImpl* ni = Ionflux::ObjectBase::nullPointerCheck(
    intersection0.nodeImpl, this, "processBoundaryStep", 
    "Node implementation");
int maxNumLevels = context->getMaxNumLevels();
bool createNear = false;
bool createFar = false;
if ((targetDepth < 0) 
    || (targetDepth >= maxNumLevels))
    targetDepth = maxNumLevels - 1;
if (!processingFlags.directionBackward)
{
    // ray enters boundary voxel at near intersection point
    createNear = true;
    createFar = false;
} else
{
    // ray leaves boundary voxel at far intersection point
    createNear = false;
    createFar = true;
}
LeafStatusID ls0 = Node::getImplLeafStatus(ni);
if ((leafStatus != NODE_ANY) 
    && (ls0 != leafStatus))
{
    std::ostringstream status;
    status << "Leaf status flag mismatch (current: " 
        << getLeafStatusValueString(ls0) << ", expected: " 
        << getLeafStatusValueString(leafStatus) << ").";
    throw IFVGError(getErrorString(status.str(), 
        "processBoundaryStep"));
}
if (rayAxis == Ionflux::GeoUtils::AXIS_UNDEFINED)
{
    throw IFVGError(getErrorString("Ray axis is undefined", 
        "processBoundaryStep"));
}
VoxelClassID vc = Node::getImplVoxelClass(ni);
/* <---- DEBUG ----- //
NodeID nid0 = Node::getImplNodeID(ni, context);
// ----- DEBUG ----> */
/* <---- DEBUG ----- //
std::cerr << "[NodeIntersectionProcessor::"
    "processBoundaryStep] DEBUG: ";
if (processingFlags.directionBackward)
    std::cerr << "(backward) ";
std::cerr << "begin node: [" << getNodeIDValueString(nid0, 
    false, true, true, context) 
    << "] voxelClass = " << getVoxelClassValueString(vc) 
    << ", state = " << getVoxelClassValueString(state) 
    << ", wallThickness = " << wallThickness 
    << ", minWallThickness = " << minWallThickness
    << ", maxWallThickness = " << maxWallThickness
    << ", numNodesFilled = " << *numNodesFilled
    << ", numThinComponents = " << *numThinComponents
    << ", fillNodes = " 
        << Ionflux::ObjectBase::getBooleanValueString(fillNodes);
std::cerr << std::endl;
// ----- DEBUG ----> */
/* set current state according to previous state and current 
   voxel class */
VoxelClassID ps = state;
bool split0 = false;
bool boundary = false;
VoxelDataIOB* d0 = 0;
if (ps == VOXEL_CLASS_UNDEFINED)
{
    // initialize voxel class and color index
    if (checkVoxelClass(vc, voxelClassFilled))
    {
        state = VOXEL_CLASS_INSIDE;
        if (colorIndex != 0)
            *colorIndex = COLOR_INDEX_UNSPECIFIED;
    } else
    {
        state = VOXEL_CLASS_OUTSIDE;
        if (colorIndex != 0)
            *colorIndex = COLOR_INDEX_UNSPECIFIED;
    }
} else
if (ps == VOXEL_CLASS_INSIDE)
{
    if (!checkVoxelClass(vc, voxelClassFilled))
    {
        // inside -> outside
        if (intersection0.depth == targetDepth)
        {
            // boundary voxel at target depth
            /* <---- DEBUG ----- //
            std::cerr << "[NodeIntersectionProcessor::"
                "processBoundaryStep] DEBUG: "
                << "(inside -> outside) "
                    "boundary node at target depth" 
                << std::endl;
            // ----- DEBUG ----> */
            boundary = true;
        } else
        {
            // insert boundary voxel at target depth
            /* <---- DEBUG ----- //
            std::cerr << "[NodeIntersectionProcessor::"
                "processBoundaryStep] DEBUG: "
                << "(inside -> outside) "
                    "inserting boundary node at target depth" 
                << std::endl;
            // ----- DEBUG ----> */
            createAndProcessIntersectionsBoundary(
                intersection0, createNear, createFar, state, 
                processingFlags, colorIndex);
            split0 = true;
        }
        if (!split0)
            state = VOXEL_CLASS_OUTSIDE;
    } else
    {
        // inside -> inside
        if (colorIndex != 0)
        {
            // update color index
            d0 = getIOBData(intersection0);
            *colorIndex = d0->color;
        }
    }
} else
if (ps == VOXEL_CLASS_OUTSIDE)
{
    if (checkVoxelClass(vc, voxelClassFilled))
    {
        // outside -> inside
        state = VOXEL_CLASS_INSIDE;
        if (colorIndex != 0)
        {
            // initialize color index
            d0 = getIOBData(intersection0);
            *colorIndex = d0->color;
        }
    }
}
if (split0)
{
    // node intersection has been split and processed recursively
    return;
}
// update wall thickness for the node
if (d0 == 0)
    d0 = getIOBData(intersection0);
if (boundary)
{
    setVoxelClass(voxelClassBoundary, vc);
    if (!processingFlags.directionBackward)
        d0->boundaryFaces |= intersection0.intersection.nearPlane;
    else
        d0->boundaryFaces |= intersection0.intersection.farPlane;
    if ((colorIndex != 0) 
        && (*colorIndex != COLOR_INDEX_UNSPECIFIED))
    {
        // assign color index
        d0->color = *colorIndex;
        *colorIndex = COLOR_INDEX_UNSPECIFIED;
    }
}
d0->voxelClass = vc;
/* <---- DEBUG ----- //
std::cerr << "[NodeIntersectionProcessor::"
    "processBoundaryStep] DEBUG: ";
if (processingFlags.directionBackward)
    std::cerr << "(backward) ";
std::cerr << "finished node: [" << getNodeIDValueString(nid0, 
    false, true, true, context) 
    << "] voxelClass = " << getVoxelClassValueString(vc) 
    << ", state = " << getVoxelClassValueString(state) 
    << ", wallThickness = " << wallThickness 
    << ", maxWallThickness = " << maxWallThickness
    << ", numNodesFilled = " << *numNodesFilled
    << ", numThinComponents = " << *numThinComponents
    << ", wt0 = " << wt0;
std::cerr << std::endl;
// ----- DEBUG ----> */
updatedIntersections.push_back(intersection0);
>>>
}

# public member functions
function.public[] = {
	spec = virtual
	type = void
	name = clear
	shortDesc = Clear
	longDesc = Clear state of the node intersection processor.
	impl = <<<
clearIntersections();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = begin
	shortDesc = Begin processing
	longDesc = Start processing of a new batch of intersections (e.g. for a ray). By default, this clears the current set of intersections.
	impl = <<<
clear();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = finish
	shortDesc = Finish processing
	longDesc = Finish processing of a batch of intersections (e.g. for a ray). By default, this sets the inside/outside/boundary data on the intersections. If \c minWallThickness is not equal to zero, this function will also invoke the wall thickness calculation and fixing stage.
	impl = <<<
bool fillNodes = false;
if (enableWallThickness 
    && (minWallThickness > 0))
    fillNodes = true;
if (enableIOB)
{
    NodeIntersectionProcessingFlags pf0 = 
        createNodeIntersectionProcessingFlags(false, 
            false, false, enableRayStabbing, 
            enableWallThickness && !fillNodes);
    setIOBData(&pf0);
}
if (fillNodes 
    || (!enableIOB && enableWallThickness))
{
    NodeIntersectionProcessingFlags pf0 = 
        createNodeIntersectionProcessingFlags(false, 
            false, false, enableRayStabbing, true);
    processWallThickness(&pf0);
}
if (enableBoundaryData)
    processBoundary();
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::NodeProcessingResultID
	name = processIntersection
	shortDesc = Process intersection
	longDesc = Apply the filter to a node implementation. This should be overridden by derived classes.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersection&
	    name = newIntersection
	    desc = Node intersection
	}
	param[] = {
	    type = void*
	    name = userData
	    desc = User data
	    default = 0
	}
	impl = <<<
NodeImpl* ni = Ionflux::ObjectBase::nullPointerCheck(
    newIntersection.nodeImpl, this, "processIntersection", 
    "Node implementation");
/* <---- DEBUG ----- //
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "processIntersection", "Context");
std::cerr << "[NodeIntersectionProcessor::processIntersection] DEBUG: " 
    "processing intersection: " << ni << " [" 
    << getNodeIntersectionValueString(*context, newIntersection) 
    << "]" << std::endl;
// ----- DEBUG ----> */
if (hitDataType != Node::DATA_TYPE_UNKNOWN)
{
    if (Node::hasImplDataType(ni, Node::DATA_TYPE_NULL))
        Node::getImplData(ni, hitDataType);
}
if ((voxelClassHit != VOXEL_CLASS_UNDEFINED) 
    && Node::hasImplVoxelClassInfo(ni))
{
    Node::setImplVoxelClass(ni, voxelClassHit);
}
addIntersection(newIntersection);
>>>
    return = {
        value = RESULT_OK
        desc = result
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setIOBData
	shortDesc = Set inside/outside/boundary data
	longDesc = <<<
Set inside/outside/boundary data for the current set of intersections. This calculates the number of surface intersections each node in the intersection set and updates the interection and vote counts accordingly. A data record of type VoxelDataIOB will be attached to each node contained in the intersection set, unless it already has data of that type attached. Existing voxel classes that are attached to the nodes will be merged into to the new data records.

See Nooruddin, Turk (2003) "Simplification and repair of polygonal models using volumetric techniques" for details on the inside/outside calculation.
>>>
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags*
	    name = processingFlags
	    desc = processing flags
	    default = 0
	}
	impl = <<<
updatedIntersections.clear();
// forward pass
VoxelClassID cs = VOXEL_CLASS_UNDEFINED;
unsigned int numInts0 = 0;
unsigned int wallThickness0 = 0;
unsigned int maxWallThickness0 = 0;
NodeIntersectionProcessingFlags pf0;
if (processingFlags == 0)
{
    pf0 = createNodeIntersectionProcessingFlags(false, 
        enableBoundaryData, false, enableRayStabbing, 
        enableWallThickness);
} else
    pf0 = *processingFlags;
processIntersectionsIOB(intersections, cs, numInts0, pf0, 
    &wallThickness0, &maxWallThickness0);
pf0.castVotes = true;
if ((numInts0 % 2) != 0)
{
    // Invalid ray does not vote.
    pf0.castVotes = false;
    if (!enableBoundaryData && !enableRayStabbing 
        && !enableWallThickness)
        return;
}
// use updated intersections for backward pass
updateIntersections();
// backward pass
cs = VOXEL_CLASS_UNDEFINED;
numInts0 = 0;
pf0.directionBackward = true;
processIntersectionsIOB(intersections, cs, numInts0, pf0, 
    &wallThickness0, &maxWallThickness0);
// update intersections from backward pass
updateIntersections(true);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = processWallThickness
	shortDesc = Process wall thickness
	longDesc = <<<
Assign wall thickness values to nodes intersected by the ray. The function will also fix the minimum wall thickness of sequences of filled nodes if \c minWallThickness is greater than zero.
>>>
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags*
	    name = processingFlags
	    desc = processing flags
	    default = 0
	}
	impl = <<<
updatedIntersections.clear();
VoxelClassID cs = VOXEL_CLASS_UNDEFINED;
unsigned int wallThickness0 = 0;
unsigned int maxWallThickness0 = 0;
unsigned int numThinComponents0 = 0;
unsigned int numNodesFilled0 = 0;
NodeIntersectionProcessingFlags pf0;
if (processingFlags == 0)
{
    pf0 = createNodeIntersectionProcessingFlags(false, 
        enableBoundaryData, false, enableRayStabbing, 
        enableWallThickness);
} else
    pf0 = *processingFlags;
// forward pass (fill inside only)
processIntersectionsWallThickness(intersections, cs, pf0, 
    wallThickness0, maxWallThickness0, minWallThickness, 0, true, 
    &numThinComponents0, &numNodesFilled0);
// use updated intersections for backward pass
updateIntersections();
// backward pass (fill inside only)
cs = VOXEL_CLASS_UNDEFINED;
pf0.directionBackward = true;
numThinComponents0 = 0;
numNodesFilled0 = 0;
processIntersectionsWallThickness(intersections, cs, pf0, 
    wallThickness0, maxWallThickness0, minWallThickness, 0, true, 
    &numThinComponents0, &numNodesFilled0);
// update intersections from backward pass
updateIntersections(true);
if (minWallThickness > 0)
{
    /* in case some nodes were filled in the backward pass, we need an 
       additional forward pass to propagate the wall thickness */
    cs = VOXEL_CLASS_UNDEFINED;
    pf0.directionBackward = false;
    numThinComponents0 = 0;
    numNodesFilled0 = 0;
    processIntersectionsWallThickness(intersections, cs, pf0, 
        wallThickness0, maxWallThickness0, minWallThickness, 0, true, 
        &numThinComponents0, &numNodesFilled0);
    updateIntersections();
    if (!fillInsideOnly) 
    {
        unsigned int numPasses = 0;
        while ((numThinComponents0 > 0) 
            && ((maxNumWallThicknessPasses == 0) 
                || (numPasses < maxNumWallThicknessPasses)))
        {
            // forward pass (1)
            cs = VOXEL_CLASS_UNDEFINED;
            pf0.directionBackward = false;
            numThinComponents0 = 0;
            numNodesFilled0 = 0;
            processIntersectionsWallThickness(intersections, cs, pf0, 
                wallThickness0, maxWallThickness0, minWallThickness, 1, 
                false, &numThinComponents0, &numNodesFilled0);
            updateIntersections();
            // backward pass
            cs = VOXEL_CLASS_UNDEFINED;
            pf0.directionBackward = true;
            numThinComponents0 = 0;
            numNodesFilled0 = 0;
            processIntersectionsWallThickness(intersections, cs, pf0, 
                wallThickness0, maxWallThickness0, minWallThickness, 1, 
                false, &numThinComponents0, &numNodesFilled0);
            updateIntersections(true);
            // forward pass (2)
            cs = VOXEL_CLASS_UNDEFINED;
            pf0.directionBackward = false;
            numThinComponents0 = 0;
            numNodesFilled0 = 0;
            processIntersectionsWallThickness(intersections, cs, pf0, 
                wallThickness0, maxWallThickness0, minWallThickness, 1, 
                false, &numThinComponents0, &numNodesFilled0);
            updateIntersections();
            numPasses++;
        }
    }
}
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = processBoundary
	shortDesc = Process boundary
	longDesc = Mark boundary nodes intersected by the ray.
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionProcessingFlags*
	    name = processingFlags
	    desc = processing flags
	    default = 0
	}
	impl = <<<
updatedIntersections.clear();
VoxelClassID cs = VOXEL_CLASS_UNDEFINED;
ColorIndex colorIndex0 = COLOR_INDEX_UNSPECIFIED;
NodeIntersectionProcessingFlags pf0;
if (processingFlags == 0)
{
    pf0 = createNodeIntersectionProcessingFlags(false, 
        enableBoundaryData, false, enableRayStabbing, 
        enableWallThickness);
} else
    pf0 = *processingFlags;
// forward pass
processIntersectionsBoundary(intersections, cs, pf0, &colorIndex0);
// use updated intersections for backward pass
updateIntersections();
// backward pass
cs = VOXEL_CLASS_UNDEFINED;
pf0.directionBackward = true;
colorIndex0 = COLOR_INDEX_UNSPECIFIED;
processIntersectionsBoundary(intersections, cs, pf0, &colorIndex0);
// update intersections from backward pass
updateIntersections(true);
>>>
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = createIntersections
	shortDesc = Create node intersections
	longDesc = Create node intersections at the target depth level for the specified node intersection.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersection&
	    name = intersection0
	    desc = Node intersection
	}
	param[] = {
	    type = Ionflux::VolGfx::NodeIntersectionVector&
	    name = newIntersections
	    desc = Where to store the node intersections for the subdivided node
	}
	param[] = {
	    type = bool
	    name = createNear
	    desc = Create node for near intersection
	    default = false
	}
	param[] = {
	    type = bool
	    name = createFar
	    desc = Create node for far intersection
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(
    context, this, "createIntersections", "Context");
Ionflux::ObjectBase::nullPointerCheck(
    ray, this, "createIntersections", "Ray");
NodeImpl* ci = Ionflux::ObjectBase::nullPointerCheck(
    intersection0.nodeImpl, this, "createIntersections", 
    "Node implementation");
VoxelClassID vc = Node::getImplVoxelClass(ci);
int maxNumLevels = context->getMaxNumLevels();
if ((targetDepth < 0) 
    || (targetDepth >= maxNumLevels))
    targetDepth = maxNumLevels - 1;
int depth = Node::getImplDepth(ci, context);
if (depth >= targetDepth)
{
    // Nothing to be done for this node.
    return 0;
}
VoxelDataIOB* d0 = 0;
if (Node::hasImplDataType(ci, Node::DATA_TYPE_VOXEL_IOB))
    d0 = getIOBData(intersection0);
NodeID nid0;
nid0.loc = ci->loc;
nid0.depth = depth;
Region3 r0;
if (!context->getIntersectionLoc(nid0, *ray, 
    intersection0.intersection, r0))
{
    std::ostringstream status;
    status << "Invalid node intersection: [" 
        << getNodeIntersectionValueString(*context, intersection0) 
        << "].";
    throw IFVGError(getErrorString(status.str(), 
        "createIntersections"));
}
unsigned int n0 = 0;
if (createNear)
{
    // insert node at near intersection point
    /* <---- DEBUG ----- //
    Ionflux::GeoUtils::Vector3 tl0;
    context->getLocation(r0.l0, tl0);
    Ionflux::GeoUtils::Range3 tr0;
    context->getVoxelRange(r0.l0, targetDepth, tr0);
    Ionflux::GeoUtils::Vector3 trMin = tr0.getRMin();
    Ionflux::GeoUtils::Vector3 trMax = tr0.getRMax();
    std::cerr << "[NodeIntersectionProcessor::createIntersections] "
        "DEBUG: inserting node at near intersection point " 
        << " (loc = [" << getLocString(r0.l0) << ", (" 
        << tl0.getValueString() <<")], range = [(" 
        << trMin.getValueString() << "), (" << trMax.getValueString() 
        << ")], targetDepth = " << targetDepth << ", voxelSize = "
        << context->getVoxelSize(targetDepth) << ")." << std::endl;
    // ----- DEBUG ----> */
    Ionflux::ObjectBase::nullPointerCheck(
        Node::insertImplChild(ci, context, r0.l0, 
        targetDepth, true), this, 
        "createIntersections", 
        "Node implementation (near intersection point)");
    n0++;
}
if (createFar)
{
    // insert node at far intersection point
    /* <---- DEBUG ----- //
    Ionflux::GeoUtils::Vector3 tl0;
    context->getLocation(r0.l0, tl0);
    Ionflux::GeoUtils::Range3 tr0;
    context->getVoxelRange(r0.l0, targetDepth, tr0);
    Ionflux::GeoUtils::Vector3 trMin = tr0.getRMin();
    Ionflux::GeoUtils::Vector3 trMax = tr0.getRMax();
    std::cerr << "[NodeIntersectionProcessor::createIntersections] "
        "DEBUG: inserting node at far intersection point " 
        << " (loc = [" << getLocString(r0.l0) << ", (" 
        << tl0.getValueString() <<")], range = [(" 
        << trMin.getValueString() << "), (" << trMax.getValueString() 
        << ")], targetDepth = " << targetDepth << ", voxelSize = "
        << context->getVoxelSize(targetDepth) << ")." << std::endl;
    // ----- DEBUG ----> */
    Ionflux::ObjectBase::nullPointerCheck(
        Node::insertImplChild(ci, context, r0.l1, 
        targetDepth, true), this, 
        "createIntersections", 
        "Node implementation (far intersection point)");
    n0++;
}
// calculate new node intersections
NodeIntersectionProcessor proc0(context, hitDataType, 
    voxelClassHit, NODE_LEAF, ray);
NodeFilter nf0(context, DEPTH_UNSPECIFIED, 
    targetDepth, NODE_LEAF);
/* <---- DEBUG ----- //
std::cerr << "[NodeIntersectionProcessor::createIntersections] "
    "DEBUG: filter: [" << nf0.getValueString() << "]" 
    << std::endl;
// ----- DEBUG ----> */
unsigned int n1 = Node::intersectRayImpl(ci, context, *ray, 
    &proc0, &nf0, true, tolerance, &intersection0, 
    fillNewIntersections, pruneEmptyNewIntersections);
if (n1 < n0)
{
    std::ostringstream status;
    status << "Unexpected number of child node intersections "
        "(expected: " << n0 << ", current: " << n1 << ").";
    throw IFVGError(getErrorString(status.str(), 
        "createIntersections"));
}
newIntersections = proc0.getIntersections();
// propagate parent voxel class to leaf child nodes
setVoxelClass(voxelClassHit, vc, false);
Node::setImplVoxelClass(ci, context, vc, true, &nf0, true, 
    Node::DATA_TYPE_VOXEL_IOB);
if (d0 != 0)
{
    // propagate number of intersections to intersected nodes
    for (unsigned int i = 0; i < newIntersections.size(); i++)
    {
        NodeIntersection ci0 = newIntersections[i];
        VoxelClassID vc0 = Node::getImplVoxelClass(ci0.nodeImpl);
        VoxelDataIOB* cd0 = getIOBData(ci0);
        cd0->voxelClass = vc0;
        cd0->numInts0 = d0->numInts0;
        cd0->numInts1 = d0->numInts1;
    }
}
/* <---- DEBUG ----- //
std::cerr << "[NodeIntersectionProcessor::createIntersections] "
    "DEBUG: new intersections (node: " << ci << " [" 
        << getNodeIDValueString(nid0, false, true, true, context) 
            << "]):" << std::endl;
for (unsigned int i = 0; i < newIntersections.size(); i++)
{
    NodeIntersection ci0 = newIntersections[i];
    NodeImpl* ni0 = ci0.nodeImpl;
    LeafStatusID ls0 = Node::getImplLeafStatus(ni0);
    nid0 = Node::getImplNodeID(ni0, context);
    std::cerr << "  [" << std::setw(3) << std::setfill('0') 
        << i << "] " << getNodeIntersectionValueString(*context, ci0) 
        << " [" << getNodeIDValueString(nid0, 
            false, true, true, context) << "]" 
        << " (" << getLeafStatusValueString(ls0) << ")" 
        << std::endl;
}
// ----- DEBUG ----> */
>>>
    return = {
        value = newIntersections.size()
        desc = Number of new intersections created
    }
}

# public member functions overridden from IFObject
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object.
	impl = <<<
ostringstream status;
status << "context: ";
if (context == 0)
    status << "<null>";
else
    status << "[" << context->getValueString() << "]";
status << "; hitDataType = " << Node::getDataTypeString(hitDataType) 
    << ", voxelClassHit = " << getVoxelClassValueString(voxelClassHit) 
    << ", leafStatus = " << getLeafStatusValueString(leafStatus) 
    << ", enableBoundaryData = " 
        << Ionflux::ObjectBase::getBooleanValueString(
            enableBoundaryData) 
    << ", targetDepth = " << getDepthString(leafStatus) 
    << ", fillNewIntersections = " 
        << Ionflux::ObjectBase::getBooleanValueString(
            fillNewIntersections) 
    << ", pruneEmptyNewIntersections = " 
        << Ionflux::ObjectBase::getBooleanValueString(
            pruneEmptyNewIntersections) 
    << ", enableIOB = " 
        << Ionflux::ObjectBase::getBooleanValueString(enableIOB) 
    << ", enableRayStabbing = " 
        << Ionflux::ObjectBase::getBooleanValueString(
            enableRayStabbing) 
    << ", enableWallThickness = " 
        << Ionflux::ObjectBase::getBooleanValueString(
            enableWallThickness) 
    << ", voxelClassFilled = " 
        << getVoxelClassValueString(voxelClassFilled) 
    << ", voxelClassInside = " 
        << getVoxelClassValueString(voxelClassInside) 
    << ", voxelClassOutside = " 
        << getVoxelClassValueString(voxelClassOutside) 
    << ", voxelClassBoundary = " 
        << getVoxelClassValueString(voxelClassBoundary) 
    << ", minWallThickness = " << minWallThickness 
    << ", fillInsideOnly = " 
        << Ionflux::ObjectBase::getBooleanValueString(
            fillInsideOnly) 
    << ", maxNumWallThicknessPasses = " << maxNumWallThicknessPasses 
    << ", tolerance = " << tolerance 
    << ", numIntersections = " << intersections.size();
status << "; ray: ";
if (ray == 0)
    status << "<null>";
else
{
    status << "[" << ray->getValueString() << "]";
    if (rayAxis != Ionflux::GeoUtils::AXIS_UNDEFINED)
    {
        status << " (" << Ionflux::GeoUtils::axisToString(rayAxis) 
            << ")";
    }
}
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}

# Static member functions.
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::VoxelDataIOB*
	name = getIOBData
	shortDesc = Get node implementation inside/outside/boundary data record
	longDesc = Get the inside/outside/boundary (IOB) data record for the specified node intersection. If the node implementation does not have an IOB record and it cannot be created, an exception will be thrown.
	param[] = {
	    type = const Ionflux::VolGfx::NodeIntersection&
	    name = intersection0
	    desc = Node intersection
	}
	impl = <<<
NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
    intersection0.nodeImpl, "NodeIntersectionProcessor::getImplIOBData", 
    "Node implementation");
NodeDataImpl* dp = Ionflux::ObjectBase::nullPointerCheck(
    Node::getImplData(cn0, Node::DATA_TYPE_VOXEL_IOB), 
    "NodeIntersectionProcessor::getImplIOBData", "Node data");
VoxelDataIOB* d0 = Ionflux::ObjectBase::nullPointerCheck(
    static_cast<VoxelDataIOB*>(dp->data), 
    "NodeIntersectionProcessor::getImplIOBData", 
    "Voxel inside/outside/boundary data");
>>>
    return = {
        value = d0
        desc = Inside/outside/boundary data record
    }
}

# Pure virtual member functions.

# operations

# Global functions.

