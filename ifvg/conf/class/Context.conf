# ===================================================================
# IFVG - Ionflux' Volumetric Graphics Library
# Copyright © 2014 Jörn P. Meier
# mail@ionflux.org
# -------------------------------------------------------------------
# Context.conf              Class configuration.
# ===================================================================
# 
# This file is part of IFVG - Ionflux' Volumetric Graphics Library.
# 
# IFVG - Ionflux' Volumetric Graphics Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# IFVG - Ionflux' Volumetric Graphics Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with IFVG - Ionflux' Volumetric Graphics Library; if not, write 
# to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307 USA
# 
# ===================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/types.hpp"'
        '"ifmapping/Point.hpp"'
        '"altjira/ColorSet.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/Vector3.hpp"'
        '"geoutils/Range3.hpp"'
        '"geoutils/Face.hpp"'
        '"geoutils/Mesh.hpp"'
        '"geoutils/NFace.hpp"'
        '"geoutils/VertexAttribute.hpp"'
        '"ifvg/types.hpp"'
        '"ifvg/constants.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '<cfloat>'
        '"ifobject/utils.hpp"'
        '"ifobject/objectutils.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/imageutils.hpp"'
        '"geoutils/Vertex3.hpp"'
        '"ifvg/IFVGError.hpp"'
        '"ifvg/Node.hpp"'
        '"ifvg/utils.hpp"'
    }
}

# forward declarations
forward = {
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Context
	shortDesc = Voxel tree context
	title = Voxel tree context
	longDesc = A context that contains all relevent metadata for a voxel tree. The context is shared by all Nodes of a tree and is used to obtain global information about the structure of the tree, such as the maximum depth of the tree and the scale of the root node.
	group.name = ifvg
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
		}
	}
    features = {
        'copy'
        'upcast'
        'create'
        'classinfo'
        #'xmlio'
    }
    create = {
        allocationError = IFVGError("Could not allocate object")
        extendedCreate = true
    }
}

# Member variables.
variable.protected[] = {
    type = Ionflux::VolGfx::NodeLoc*
    name = depthMask
    desc = Masks for single location code bit at each depth
}
variable.protected[] = {
    type = Ionflux::VolGfx::NodeLoc*
    name = locMask
    desc = Masks for all location code bits up to and including each depth
}
variable.protected[] = {
    type = double*
    name = voxelSize
    desc = Voxel size for each depth
}
variable.protected[] = {
    spec = static
    type = Ionflux::GeoUtils::Vector3*
    name = voxelDiag
    desc = Voxel diagonal vectors
    value = 0
}
variable.protected[] = {
    spec = static
    type = Ionflux::GeoUtils::Vector3*
    name = voxelNormal
    desc = Voxel face normals
    value = 0
}

# Public static constants.
constant.public[] = {
    type = int
    name = MAX_NUM_LEVELS
    desc = Maximum number of tree levels
    value = 16
}
constant.public[] = {
    type = int
    name = DEFAULT_MAX_NUM_LEVELS
    desc = Default maximum number of tree levels
    value = 10
}
constant.public[] = {
    type = int
    name = DEFAULT_ORDER
    desc = Default order
    value = 2
}
constant.public[] = {
    type = double
    name = DEFAULT_BOX_INSET
    desc = Default box inset
    value = 0.05
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    type = int
    setFromType = int
    name = maxNumLevels
    desc = Maximum number of levels
}
property.protected[] = {
    type = int
    setFromType = int
    name = order
    desc = Order (number of children per non-leaf node and dimension)
}
property.protected[] = {
    type = double
    setFromType = double
    name = tolerance
    desc = Tolerance for comparisons
}
property.protected[] = {
    type = Ionflux::VolGfx::NodeLoc
    setFromType = const Ionflux::VolGfx::NodeLoc&
    name = validBits
    desc = Mask for valid bits from a location code
}
property.protected[] = {
    type = int
    setFromType = int
    name = maxNumLeafChildNodesPerNode
    desc = Maximum number of leaf child nodes per node
    protectedWrite = true
}
property.protected[] = {
    type = int
    setFromType = int
    name = maxNumLeafChildNodesPerDimension
    desc = Maximum number of leaf child nodes per dimension
    protectedWrite = true
}
property.protected[] = {
    type = double
    setFromType = double
    name = scale
    desc = Length scale factor
}

# Protected static constants.

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = depthMask
        value = 0
    }
    initializer[] = {
        name = locMask
        value = 0
    }
    initializer[] = {
        name = voxelSize
        value = 0
    }
    initializer[] = {
        name = maxNumLevels
        value = DEFAULT_MAX_NUM_LEVELS
    }
    initializer[] = {
        name = order
        value = DEFAULT_ORDER
    }
    initializer[] = {
        name = tolerance
        value = DEFAULT_TOLERANCE
    }
    initializer[] = {
        name = validBits
        value = 0
    }
    initializer[] = {
        name = maxNumLeafChildNodesPerNode
        value = 0
    }
    initializer[] = {
        name = maxNumLeafChildNodesPerDimension
        value = 0
    }
    initializer[] = {
        name = scale
        value = 1.
    }
    impl = update();
}
constructor.public[] = {
    initializer[] = {
        name = depthMask
        value = 0
    }
    initializer[] = {
        name = locMask
        value = 0
    }
    initializer[] = {
        name = voxelSize
        value = 0
    }
    initializer[] = {
        name = maxNumLevels
        value = initMaxNumLevels
    }
    initializer[] = {
        name = order
        value = initOrder
    }
    initializer[] = {
        name = tolerance
        value = initTolerance
    }
    initializer[] = {
        name = maxNumLeafChildNodesPerNode
        value = 0
    }
    initializer[] = {
        name = maxNumLeafChildNodesPerDimension
        value = 0
    }
    initializer[] = {
        name = scale
        value = initScale
    }
    param[] = {
        type = int
        name = initMaxNumLevels
        desc = Maximum number of levels
    }
    param[] = {
        type = int
        name = initOrder
        desc = Order
        default = DEFAULT_ORDER
    }
    param[] = {
        type = double
        name = initScale
        desc = Length scale factor
        default = 1.
    }
    param[] = {
        type = double
        name = initTolerance
        desc = Tolerance for comparisons
        default = DEFAULT_TOLERANCE
    }
    impl = update();
}

# Destructor.
destructor.impl = <<<
clearMasks();
clearVoxelSize();
>>>

# Protected member functions.
function.protected[] = {
	spec = virtual
	type = void
	name = clearMasks
	shortDesc = Clear masks
	longDesc = Clear bit masks.
	impl = <<<
if (depthMask != 0)
{
    delete[] depthMask;
    depthMask = 0;
}
if (locMask != 0)
{
    delete[] locMask;
    locMask = 0;
}
>>>
}
function.protected[] = {
	spec = virtual
	type = void
	name = clearVoxelSize
	shortDesc = Clear voxel size buffer
	longDesc = Clear voxel size buffer.
	impl = <<<
if (voxelSize != 0)
{
    delete[] voxelSize;
    voxelSize = 0;
}
>>>
}

# Public member functions.
function.copy.impl = <<<
if (this == &other)
    return *this;
setMaxNumLevels(other.maxNumLevels);
setOrder(other.order);
setTolerance(other.tolerance);
update();
>>>
function.public[] = {
	spec = virtual
	type = void
	name = clear
	shortDesc = Clear
	longDesc = Clear all data in the context.
	impl = <<<
maxNumLevels = DEFAULT_MAX_NUM_LEVELS;
order = DEFAULT_ORDER;
maxNumLeafChildNodesPerNode = 0;
maxNumLeafChildNodesPerDimension = 0;
clearMasks();
clearVoxelSize();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = update
	shortDesc = Update
	longDesc = Update the context metadata.
	impl = <<<
clearMasks();
clearVoxelSize();
if (maxNumLevels > MAX_NUM_LEVELS)
{
    std::ostringstream status;
    status << "Maximum number of levels exceeds allowed "
        "maximum number of levels (maxNumLevels: " << maxNumLevels 
        << ", max. allowed: " << MAX_NUM_LEVELS << ")";
    throw IFVGError(getErrorString(status.str(), "update"));
}
maxNumLeafChildNodesPerNode = order * order * order;
maxNumLeafChildNodesPerDimension = 0;
if (maxNumLevels > 1)
{
    maxNumLeafChildNodesPerDimension = order;
    for (int i = 0; i < maxNumLevels - 2; i++)
        maxNumLeafChildNodesPerDimension *= order;
}
// Initialize bit masks and voxel size buffer.
depthMask = new NodeLoc[maxNumLevels];
if (depthMask == 0)
{
    throw IFVGError("Context::update"
        "Could not allocate depth masks.");
}
locMask = new NodeLoc[maxNumLevels];
if (locMask == 0)
{
    throw IFVGError("Context::update"
        "Could not allocate node location masks.");
}
voxelSize = new double[maxNumLevels];
if (voxelSize == 0)
{
    throw IFVGError("Context::update"
        "Could not allocate voxel size buffer.");
}
LocInt cm = 0;
double vs = 1.;
for (int i = 0; i < maxNumLevels; i++)
{
    LocInt cb = 1 << (maxNumLevels - i - 1);
    cm |= cb;
    depthMask[i] = cb;
    locMask[i] = cm;
    voxelSize[i] = vs * scale;
    vs /= order;
}
validBits = cm;
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::NodeLoc
	name = createLoc
	shortDesc = Create node location code
	longDesc = Create a node location code for the specified value.
	param[] = {
	    type = double
	    name = v
	    desc = value
	}
	param[] = {
	    type = bool
	    name = checkBounds0
	    desc = check bounds
	    default = true
	}
	impl = <<<
double v0 = v / scale;
if (checkBounds0 
    && ((v0 < 0.) || (v0 >= 1.)))
{
    std::ostringstream status;
    status << "Location value out of bounds (v = " << v << ")";
    throw IFVGError(getErrorString(status.str(), "createLoc"));
}
>>>
    return = {
        value = static_cast<NodeLoc>(v * maxNumLeafChildNodesPerDimension)
        desc = Node location code
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::NodeLoc3
	name = createLoc
	shortDesc = Create node location code (3D)
	longDesc = Create a node location code for the specified coordinate values.
	param[] = {
	    type = double
	    name = x
	    desc = X coordinate
	}
	param[] = {
	    type = double
	    name = y
	    desc = Y coordinate
	}
	param[] = {
	    type = double
	    name = z
	    desc = Z coordinate
	}
	param[] = {
	    type = bool
	    name = checkBounds0
	    desc = check bounds
	    default = true
	}
	impl = <<<
double x0 = x / scale;
double y0 = y / scale;
double z0 = z / scale;
if (checkBounds0 
    && ((x0 < 0.) || (x0 >= 1.) 
        || (y0 < 0.) || (y0 >= 1.)
        || (z0 < 0.) || (z0 >= 1.)))
{
    std::ostringstream status;
    status << "Location value out of bounds (x = " << x 
        << ", y = " << y << ", z = " << z 
        << ", scale = " << scale << ")";
    throw IFVGError(getErrorString(status.str(), "createLoc"));
}
NodeLoc3 result;
result.x = static_cast<NodeLoc>(x0 * maxNumLeafChildNodesPerDimension);
result.y = static_cast<NodeLoc>(y0 * maxNumLeafChildNodesPerDimension);
result.z = static_cast<NodeLoc>(z0 * maxNumLeafChildNodesPerDimension);
>>>
    return = {
        value = result
        desc = Node location code
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::NodeLoc3
	name = createLoc
	shortDesc = Create node location code (3D)
	longDesc = Create a node location code for the specified coordinate vector.
	param[] = {
	    type = const Ionflux::GeoUtils::Vector3&
	    name = v
	    desc = Vector
	}
	param[] = {
	    type = bool
	    name = checkBounds0
	    desc = check bounds
	    default = true
	}
	impl = 
    return = {
        value = <<<
createLoc(v.getElement(0), v.getElement(1), v.getElement(2), 
    checkBounds0)
>>>
        desc = Node location code
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::NodeLoc3
	name = createLoc
	shortDesc = Create node location code (3D)
	longDesc = Create a node location code for the specified coordinate vector.
	param[] = {
	    type = const Ionflux::Mapping::Point&
	    name = p
	    desc = Point
	}
	param[] = {
	    type = bool
	    name = checkBounds0
	    desc = check bounds
	    default = true
	}
	impl = 
    return = {
        value = createLoc(p.getX(), p.getY(), p.getZ(), checkBounds0)
        desc = Node location code
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Region3
	name = createRegion
	shortDesc = Create region (3D)
	longDesc = Create a region for the specified range.
	param[] = {
	    type = const Ionflux::GeoUtils::Range3&
	    name = r
	    desc = Range
	}
	impl = <<<
Region3 result;
if (!checkRange(r))
{
    std::ostringstream status;
    status << "Range out of bounds: [" << r.getValueString() << "]";
    throw IFVGError(getErrorString(status.str(), "createRegion"));
}
result.l0 = createLoc(r.getRMin());
result.l1 = createLoc(r.getRMax());
>>>
    return = {
        value = result
        desc = Node location code
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = locEqual
	shortDesc = Location equality check
	longDesc = Check whether two node location codes are equal. If \c maxDepth is larger than -1, the location codes will be compared only up to and including this depth.
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc&
	    name = loc0
	    desc = Node location code (0)
	}
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc&
	    name = loc1
	    desc = Node location code (1)
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
if ((maxDepth > (maxNumLevels - 1))
    || (maxDepth < 0))
    maxDepth = maxNumLevels - 1;
Ionflux::ObjectBase::nullPointerCheck(locMask, this, "locEqual", 
    "Location mask");
NodeLoc m0 = locMask[maxDepth];
if ((loc0 & validBits & m0) == (loc1 & validBits & m0))
    return true;
>>>
    return = {
        value = false
        desc = \c true if the location codes are equal, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = locEqual
	shortDesc = Location equality check (3D)
	longDesc = Check whether two node location codes are equal. If \c maxDepth is larger than -1, the location codes will be compared only up to and including this depth.
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc0
	    desc = Node location code (0)
	}
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc1
	    desc = Node location code (1)
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
if ((maxDepth > (maxNumLevels - 1))
    || (maxDepth < 0))
    maxDepth = maxNumLevels - 1;
Ionflux::ObjectBase::nullPointerCheck(locMask, this, "locEqual", 
    "Location mask");
NodeLoc m0 = locMask[maxDepth];
if (((loc0.x & validBits & m0) == (loc1.x & validBits & m0)) 
    && ((loc0.y & validBits & m0) == (loc1.y & validBits & m0)) 
    && ((loc0.z & validBits & m0) == (loc1.z & validBits & m0)))
    return true;
>>>
    return = {
        value = false
        desc = \c true if the location codes are equal, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = getChildOrderIndex
	const = true
	shortDesc = Get child order index
	longDesc = Get the index of the child node with the specified location code on the specified depth level.
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc
	    desc = Location code
	}
	param[] = {
	    type = int
	    name = depth
	    desc = Depth level
	}
	impl = <<<
if (order != 2)
{
    throw IFVGError(getErrorString("Location codes not "
        "supported for tree order != 2.", 
        "getChildOrderIndex"));
}
if (depth == 0)
{
    // Nodes on level 0 are never child nodes.
    /* <---- DEBUG ----- //
    std::cout << "[Context::getChildOrderIndex] DEBUG: "
        << "Node on level 0 is not a child node (loc = " 
        << getLocString(loc) << ")." << std::endl;
    // <---- DEBUG ----- */
    return Node::CHILD_INDEX_INVALID;
}
NodeLoc m0 = getDepthMask(depth);
int n0 = maxNumLevels - depth - 1;
/* <---- DEBUG ----- //
std::cout << "[Context::getChildOrderIndex] DEBUG: "
    << "loc = " << getLocString(loc) << ", depth = " 
    << depth << "; location bits: (" 
    << ((loc.x & m0) >> n0).to_ulong() << ", " 
    << ((loc.y & m0) >> n0).to_ulong() << ", " 
    << ((loc.z & m0) >> n0).to_ulong() << ")." << std::endl;
// <---- DEBUG ----- */
LocInt oi = (((loc.x & m0) >> n0) 
    | (((loc.y & m0) >> n0) << 1)
    | (((loc.z & m0) >> n0) << 2)).to_ulong();
/* <---- DEBUG ----- //
std::cout << "[Context::getChildOrderIndex] DEBUG: "
    << "loc = " << getLocString(loc) << ", depth = " 
    << depth << ", orderIndex = " << oi << "." << std::endl;
// <---- DEBUG ----- */
if (oi >= maxNumLeafChildNodesPerNode)
{
    std::ostringstream status;
    status << "Child node index out of range: " << oi;
    throw IFVGError(getErrorString(status.str(), 
        "getChildOrderIndex"));
}
>>>
    return = {
        value = oi
        desc = \c true if the child with the specified index is a leaf node, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = getCommonAncestorLevel
	const = true
	shortDesc = Get common ancestor level
	longDesc = Get the level of the deepest common ancestor of the two location codes. If \c maxDepth not negative, this level will be returned instead, if the actual level of the deepest common ancestor node is below that level.
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc0
	    desc = Location code (0)
	}
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc1
	    desc = Location code (1)
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
if (order != 2)
{
    throw IFVGError(getErrorString("Location codes not "
        "supported for tree order != 2.", 
        "getCommonAncestorLevel"));
}
if ((maxDepth < 0) 
    || (maxDepth >= maxNumLevels))
    maxDepth = maxNumLevels - 1;
/* <---- DEBUG ----- //
std::cout << "[Context::getCommonAncestorLevel] DEBUG: "
    "loc0 = " << getLocString(loc0) << ", loc1 = " 
    << getLocString(loc1) << ", maxDepth = " << maxDepth 
    << std::endl;
// <---- DEBUG ----- */
NodeLoc3 rx;
rx.x = loc0.x ^ loc1.x;
rx.y = loc0.y ^ loc1.y;
rx.z = loc0.z ^ loc1.z;
NodeLoc tl = rx.x | rx.y | rx.z;
/* <---- DEBUG ----- //
std::cout << "[Node::getCommonAncestorLevel] DEBUG: "
    "rx = " << getLocString(rx) << ", tl = " << getLocString(tl) 
    << std::endl;
// <---- DEBUG ----- */
int n0 = maxNumLeafChildNodesPerNode;
int i = 0;
bool found = false;
while ((i < n0) 
    && !found)
{
    if (tl.test(maxNumLevels - i - 1))
        found = true;
    i++;
}
int l0 = 0;
if ((found) && (i >= 2))
    l0 = i - 2;
if ((maxDepth > 0) 
    && (maxDepth < l0))
    l0 = maxDepth;
/* <---- DEBUG ----- //
std::cout << "[Node::getCommonAncestorLevel] DEBUG: "
    "target level = " << l0 << std::endl;
// <---- DEBUG ----- */
>>>
    return = {
        value = l0
        desc = Level of the deepest common ancestor node of the specified locations
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = getCommonAncestorLevel
	const = true
	shortDesc = Get common ancestor level
	longDesc = Get the level of the deepest common ancestor of the two location codes. If \c maxDepth is not negative, this level will be returned instead, if the actual level of the deepest common ancestor node is below that level.
	param[] = {
	    type = const Ionflux::VolGfx::Region3&
	    name = region
	    desc = Region
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = 
    return = {
        value = getCommonAncestorLevel(region.l0, region.l1, maxDepth)
        desc = Level of the deepest common ancestor node of the specified locations
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::NodeLoc
	name = getDepthMask
	const = true
	shortDesc = Get depth mask
	longDesc = Get the depth mask for the specified depth.
	param[] = {
	    type = int
	    name = depth
	    desc = Depth
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(depthMask, this, "getDepthMask", 
    "Depth mask");
if ((depth < 0) || (depth > (maxNumLevels - 1)))
{
    std::ostringstream status;
    status << "Depth out of range (maxNumLevels: " 
        << maxNumLevels << ", depth: " << depth << ")";
    throw IFVGError(getErrorString(status.str(), "getDepthMask"));
}
>>>
    return = {
        value = depthMask[depth]
        desc = Depth mask
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::NodeLoc
	name = getLocMask
	shortDesc = Get location mask
	longDesc = Get the location mask for the specified depth.
	param[] = {
	    type = int
	    name = depth
	    desc = Depth
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(depthMask, this, "getLocMask", 
    "Location mask");
if ((depth < 0) || (depth > (maxNumLevels - 1)))
{
    std::ostringstream status;
    status << "Depth out of range (maxNumLevels: " 
        << maxNumLevels << ", depth: " << depth << ")";
    throw IFVGError(getErrorString(status.str(), "getLocMask"));
}
>>>
    return = {
        value = locMask[depth]
        desc = Location mask
    }
}
function.public[] = {
	spec = virtual
	type = double
	name = getVoxelSize
	shortDesc = Get voxel size
	longDesc = Get the size (edge length) of a voxel at the specified depth.
	param[] = {
	    type = int
	    name = depth
	    desc = Depth
	    default = 0
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(voxelSize, this, "getVoxelSize", 
    "Voxel size buffer");
if (depth < 0)
    depth = 0;
if (depth >= maxNumLevels)
{
    double s0 = voxelSize[maxNumLevels - 1];
    int i = maxNumLevels - 1;
    while (i < depth)
    {
        s0 /= order;
        i++;
    }
    return s0;
}
>>>
    return = {
        value = voxelSize[depth]
        desc = Voxel size
    }
}
function.public[] = {
	spec = virtual
	type = double
	name = getMinLeafSize
	shortDesc = Get minimum leaf voxel size
	longDesc = Get the size (edge length) of a leaf voxel at the maximum depth level of the octree.
	impl = 
    return = {
        value = getVoxelSize(maxNumLevels - 1)
        desc = Leaf voxel size
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getLocation
	shortDesc = Get location
	longDesc = Get the location vector for the specified location code.
    param[] = {
        type = const Ionflux::VolGfx::NodeLoc3&
        name = loc
        desc = Location code
    }
    param[] = {
        type = Ionflux::GeoUtils::Vector3&
        name = target
        desc = Where to store the location data
    }
	impl = <<<
double leafSize = getMinLeafSize();
target.setElements(leafSize * loc.x.to_ulong(), 
    leafSize * loc.y.to_ulong(), 
    leafSize * loc.z.to_ulong());
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getLocation0
	shortDesc = Get location
	longDesc = Get the location vector for the specified location code.
    param[] = {
        type = const Ionflux::VolGfx::NodeLoc3&
        name = loc
        desc = Voxel location code
    }
	impl = <<<
Ionflux::GeoUtils::Vector3 l0;
getLocation(loc, l0);
>>>
    return = {
        value = l0
        desc = Location vector
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getVoxelLocation
	shortDesc = Get voxel location
	longDesc = Get the location vector for the voxel with the specified coordinates at the specified level.
    param[] = {
        type = const Ionflux::VolGfx::NodeLoc3&
        name = loc
        desc = Voxel location code
    }
    param[] = {
        type = int
        name = depth
        desc = Voxel depth
    }
    param[] = {
        type = Ionflux::GeoUtils::Vector3&
        name = target
        desc = Where to store the location data
    }
	impl = <<<
double leafSize = getMinLeafSize();
LocInt lm0 = getLocMask(depth).to_ulong();
target.setElements(leafSize * (loc.x.to_ulong() & lm0), 
    leafSize * (loc.y.to_ulong() & lm0), 
    leafSize * (loc.z.to_ulong() & lm0));
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getVoxelLocation0
	shortDesc = Get voxel location
	longDesc = Get the location vector for the voxel with the specified coordinates at the specified level. This is the location of the lower left front corner of the voxel.
    param[] = {
        type = const Ionflux::VolGfx::NodeLoc3&
        name = loc
        desc = Voxel location code
    }
    param[] = {
        type = int
        name = depth
        desc = Voxel depth
    }
	impl = <<<
Ionflux::GeoUtils::Vector3 l0;
getVoxelLocation(loc, depth, l0);
>>>
    return = {
        value = l0
        desc = Voxel location vector
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getVoxelLocation
	shortDesc = Get voxel location
	longDesc = Get the location vector for the voxel with the specified coordinates at the specified level. This is the location of the lower left front corner of the voxel.
    param[] = {
        type = const Ionflux::VolGfx::NodeID&
        name = node
        desc = Node ID
    }
    param[] = {
        type = Ionflux::GeoUtils::Vector3&
        name = target
        desc = Where to store the location data
    }
	impl = <<<
getVoxelLocation(node.loc, node.depth, target);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getVoxelRange
	shortDesc = Get voxel range
	longDesc = Get the range of values contained by the voxel with the specified coordinates at the specified level.
    param[] = {
        type = const Ionflux::VolGfx::NodeLoc3&
        name = loc
        desc = Voxel location code
    }
	param[] = {
	    type = int
	    name = depth
	    desc = Voxel depth
	}
    param[] = {
        type = Ionflux::GeoUtils::Range3&
        name = target
        desc = Where to store the range data
    }
	impl = <<<
Ionflux::GeoUtils::Vector3 lv0;
getVoxelLocation(loc, depth, lv0);
double s0 = getVoxelSize(depth);
target.setBounds(lv0, s0);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getVoxelRange
	shortDesc = Get voxel range
	longDesc = Get the range of values contained by the voxel with the specified coordinates at the specified level.
    param[] = {
        type = Ionflux::VolGfx::NodeID
        name = node
        desc = Node ID
    }
    param[] = {
        type = Ionflux::GeoUtils::Range3&
        name = target
        desc = Where to store the range data
    }
	impl = getVoxelRange(node.loc, node.depth, target);
}
function.public[] = {
	spec = virtual
	type = void
	name = getVoxelRegion
	shortDesc = Get voxel region
	longDesc = Get the region contained by the voxel with the specified location code at the specified level. If \c includeMaxBoundary is \c false, the region is defined in such a way that each location code within this region is a valid location code of a child voxel of the specified voxel. Otherwise, the boundary of maximum extent will be included in the region. (Note that location codes for the maximum boundary are located within neighboring voxels.)
    param[] = {
        type = const Ionflux::VolGfx::NodeLoc3&
        name = loc
        desc = Voxel location code
    }
	param[] = {
	    type = int
	    name = depth
	    desc = Voxel depth
	}
    param[] = {
        type = Ionflux::VolGfx::Region3&
        name = target
        desc = Where to store the region data
    }
    param[] = {
        type = bool
        name = includeMaxBoundary
        desc = Include the node maximum boundary in the region
        default = false
    }
	impl = <<<
if ((depth < 0) 
    || (depth >= maxNumLevels))
    depth = maxNumLevels - 1;
LocInt offset0 = getDepthMask(depth).to_ulong();
LocInt offset1 = 1;
if (includeMaxBoundary)
    offset1 = 0;
target.l0 = loc;
target.l1.x = loc.x.to_ulong() + offset0 - offset1;
target.l1.y = loc.y.to_ulong() + offset0 - offset1;
target.l1.z = loc.z.to_ulong() + offset0 - offset1;
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getVoxelRegion
	shortDesc = Get voxel region
	longDesc = Get the region contained by the voxel with the specified node ID. If \c includeMaxBoundary is \c false, the region is defined in such a way that each location code within this region is a valid location code of a child voxel of the specified voxel. Otherwise, the boundary of maximum extent will be included in the region. (Note that location codes for the maximum boundary are located within neighboring voxels.)
    param[] = {
        type = Ionflux::VolGfx::NodeID
        name = node
        desc = Node ID
    }
    param[] = {
        type = Ionflux::VolGfx::Region3&
        name = target
        desc = Where to store the region data
    }
    param[] = {
        type = bool
        name = includeMaxBoundary
        desc = Include the node maximum boundary in the region
        default = false
    }
	impl = <<<
getVoxelRegion(node.loc, node.depth, target, includeMaxBoundary);
>>>
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkLoc
	shortDesc = Check location
	longDesc = Check whether the specified location code is within the range of the tree when adding the specified offset.
    param[] = {
        type = const Ionflux::VolGfx::NodeLoc&
        name = loc
        desc = Location code
    }
	param[] = {
	    type = int
	    name = offset
	    desc = Offset
	    default = 0
	}
	impl = <<<
LocInt l0 = loc.to_ulong();
LocInt maxLoc = getLocMask(maxNumLevels - 1).to_ulong();
if (offset >= 0)
{
    if (l0 + offset > maxLoc)
        return false;
} else
if (offset < 0)
{
    if (l0 < -offset)
        return false;
}
>>>
    return = {
        value = true
        desc = \c true if the location is within range when adding the specified offset, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkLoc
	shortDesc = Check location
	longDesc = Check whether the specified location vector is within the range of the tree.
    param[] = {
        type = const Ionflux::GeoUtils::Vector3&
        name = v
        desc = Location vector
    }
	impl = <<<
Ionflux::GeoUtils::Range3 r0;
NodeID nid0;
nid0.loc = Ionflux::VolGfx::createLoc(0, 0, 0);
nid0.depth = 0;
getVoxelRange(nid0, r0);
>>>
    return = {
        value = r0.isInRange(v)
        desc = \c true if the location is within range when adding the specified offset, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkLoc
	shortDesc = Check location
	longDesc = Check whether the specified location code is within the range of the tree when adding the specified offsets.
    param[] = {
        type = const Ionflux::VolGfx::NodeLoc3&
        name = loc
        desc = Location code
    }
	param[] = {
	    type = int
	    name = offsetX
	    desc = Offset (x)
	    default = 0
	}
	param[] = {
	    type = int
	    name = offsetY
	    desc = Offset (y)
	    default = 0
	}
	param[] = {
	    type = int
	    name = offsetZ
	    desc = Offset (z)
	    default = 0
	}
	impl = <<<
bool result = checkLoc(loc.x, offsetX) 
    && checkLoc(loc.y, offsetY) 
    && checkLoc(loc.z, offsetZ);
// <---- DEBUG ----- //
if (!result)
{
    std::cout << "[Context::checkLoc] DEBUG: "
        "Location out of bounds (loc = " << getLocString(loc) 
            << ", offset = (" << offsetX << ", " << offsetY 
            << ", " << offsetZ << "))." << std::endl;
}
// <---- DEBUG ----- */
>>>
    return = {
        value = result
        desc = \c true if the location is within range when adding the specified offsets, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkRegion
	shortDesc = Check region
	longDesc = Check whether the specified region is within the range of the tree when adding the specified offsets.
    param[] = {
        type = const Ionflux::VolGfx::Region3&
        name = region
        desc = Region
    }
	param[] = {
	    type = int
	    name = offsetX
	    desc = Offset (x)
	    default = 0
	}
	param[] = {
	    type = int
	    name = offsetY
	    desc = Offset (y)
	    default = 0
	}
	param[] = {
	    type = int
	    name = offsetZ
	    desc = Offset (z)
	    default = 0
	}
	impl = 
    return = {
        value = <<<
checkLoc(region.l0, offsetX, offsetY, offsetZ) 
    && checkLoc(region.l1, offsetX, offsetY, offsetZ)
>>>
        desc = \c true if the location is within range when adding the specified offsets, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkRange
	shortDesc = Check range
	longDesc = Check whether the specified range is within the range of the specified node.
    param[] = {
        type = const Ionflux::GeoUtils::Range3&
        name = range
        desc = Range
    }
    param[] = {
        type = const Ionflux::VolGfx::NodeLoc3&
        name = loc
        desc = Voxel location code
    }
	param[] = {
	    type = int
	    name = depth
	    desc = Voxel depth
	}
	impl = <<<
Ionflux::GeoUtils::Range3 r0;
getVoxelRange(loc, depth, r0);
Ionflux::GeoUtils::RangeCompResult result = r0.compare(range, 0.);
if (result == Ionflux::GeoUtils::RANGE_FIRST_CONTAINS)
    return true;
>>>
    return = {
        value = false
        desc = \c true if the location is within range when adding the specified offsets, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkRange
	shortDesc = Check range
	longDesc = Check whether the specified range is within the range of the specified node.
    param[] = {
        type = const Ionflux::GeoUtils::Range3&
        name = range
        desc = Range
    }
    param[] = {
        type = Ionflux::VolGfx::NodeID
        name = node
        desc = Node ID
    }
	impl = 
    return = {
        value = checkRange(range, node.loc, node.depth)
        desc = \c true if the location is within range when adding the specified offsets, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkRange
	shortDesc = Check range
	longDesc = Check whether the specified range is within the range of the voxel tree.
    param[] = {
        type = const Ionflux::GeoUtils::Range3&
        name = range
        desc = Range
    }
	impl = <<<
NodeLoc3 l0;
l0.x = 0;
l0.y = 0;
l0.z = 0;
>>>
    return = {
        value = checkRange(range, l0, 0)
        desc = \c true if the location is within range when adding the specified offsets, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkDepthRange
	shortDesc = Check depth
	longDesc = Check whether the specified depth is within the specified range.
    param[] = {
        type = int
        name = depth
        desc = depth
    }
    param[] = {
        type = int
        name = minDepth
        desc = minimum depth
        default = DEPTH_UNSPECIFIED
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth
        default = DEPTH_UNSPECIFIED
    }
	impl = <<<
if (minDepth < 0)
    minDepth = 0;
if (depth < minDepth)
    return false;
int n0 = getMaxNumLevels();
if ((maxDepth < 0) 
    || (maxDepth >= n0))
    maxDepth = n0 - 1;
if (minDepth > maxDepth)
    return false;
if (depth > maxDepth)
    return false;
>>>
    return = {
        value = true;
        desc = \c true if the location is within range when adding the specified offsets, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getContainingNode
	shortDesc = Get containing node
	longDesc = Get the ID for the deepest node that contains the specified range of values.
    param[] = {
        type = const Ionflux::GeoUtils::Range3&
        name = range
        desc = range
    }
    param[] = {
        type = Ionflux::VolGfx::NodeID&
        name = target
        desc = where to store the node ID
    }
	impl = <<<
if (!checkRange(range))
{
    std::ostringstream status;
    status << "Range out of bounds: [" 
        << range.getValueString() << "]";
    throw IFVGError(getErrorString(status.str(), 
        "getContainingNode"));
}
Region3 r0;
r0.l0 = createLoc(range.getRMin());
r0.l1 = createLoc(range.getRMax());
target.loc = r0.l0;
target.depth = getCommonAncestorLevel(r0.l0, r0.l1);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = initTriangleVoxelizationData
	shortDesc = Initialize triangle voxelization data
	longDesc = <<<
Initialize triangle voxelization data from a GeoUtils::Face, using the specified separability and depth level. If \c depth is negative, the maximum depth will be used.

See Huang 1998, "An Accurate Method for Voxelizing Polygon Meshes" for details.
>>>
    param[] = {
        type = const Ionflux::GeoUtils::Face&
        name = face
        desc = Face
    }
	param[] = {
	    type = Ionflux::VolGfx::TriangleVoxelizationData&
	    name = target
	    desc = triangle voxelization data
	}
	param[] = {
	    type = Ionflux::VolGfx::SeparabilityID
	    name = sep
	    desc = separability
	    default = SEPARABILITY_26
	}
	param[] = {
	    type = int
	    name = depth
	    desc = depth
	    default = DEPTH_UNSPECIFIED
	}
	param[] = {
	    type = bool
	    name = checkBounds0
	    desc = check bounds
	    default = true
	}
	impl = <<<
if (!face.isTri())
{
    throw IFVGError(getErrorString("initTriangleVoxelizationData", 
        "Face is not a triangle."));
}
if (depth < 0)
    depth = maxNumLevels - 1;
Ionflux::GeoUtils::Vertex3* v0 = 
    Ionflux::ObjectBase::nullPointerCheck(face.getVertexData(0), 
        this, "initTriangleVoxelizationData", "Vertex (0)");
Ionflux::GeoUtils::Vertex3* v1 = 
    Ionflux::ObjectBase::nullPointerCheck(face.getVertexData(1), 
        this, "initTriangleVoxelizationData", "Vertex (1)");
Ionflux::GeoUtils::Vertex3* v2 = 
    Ionflux::ObjectBase::nullPointerCheck(face.getVertexData(2), 
        this, "initTriangleVoxelizationData", "Vertex (2)");
// triangle data
target.tri.v0 = v0->getVector();
target.tri.v1 = v1->getVector();
target.tri.v2 = v2->getVector();
Ionflux::GeoUtils::Vector3 n0 = 
    (target.tri.v1 - target.tri.v0).cross(
        target.tri.v2 - target.tri.v0).normalize();
target.plane.p = target.tri.v0;
target.plane.normal = n0;
// separability factors
target.sep = sep;
double s0 = getVoxelSize(depth);
target.voxelSize = s0;
if (sep == SEPARABILITY_26)
{
    Ionflux::GeoUtils::Vector3* d0 = getMatchingVoxelDiag(n0);
    target.t = 0.5 * s0 * SQRT_3 * n0.angleCos(*d0);
    target.r_c = 0.5 * SQRT_3 * s0;
} else
if (sep == SEPARABILITY_6)
{
    Ionflux::GeoUtils::Vector3* n1 = getMatchingVoxelNormal(n0);
    target.t = 0.5 * s0 * n0.angleCos(*n1);
    target.r_c = 0.5 * s0;
}
// offset planes
// upper offset plane
target.planeU.p = target.tri.v0 + (n0 * target.t);
target.planeU.normal = n0;
// lower offset plane
target.planeL.p = target.tri.v0 - (n0 * target.t);
target.planeL.normal = n0.flip();
// edge shapes
// edge cylinder (0)
target.cylE0.center = (target.tri.v1 + target.tri.v0) * 0.5;
target.cylE0.direction = (target.tri.v1 - target.tri.v0).normalize();
target.cylE0.length = (target.tri.v1 - target.tri.v0).length();
target.cylE0.radius = target.r_c;
// edge cylinder (1)
target.cylE1.center = (target.tri.v2 + target.tri.v1) * 0.5;
target.cylE1.direction = (target.tri.v2 - target.tri.v1).normalize();
target.cylE1.length = (target.tri.v2 - target.tri.v1).length();
target.cylE1.radius = target.r_c;
// edge cylinder (2)
target.cylE2.center = (target.tri.v0 + target.tri.v2) * 0.5;
target.cylE2.direction = (target.tri.v0 - target.tri.v2).normalize();
target.cylE2.length = (target.tri.v0 - target.tri.v2).length();
target.cylE2.radius = target.r_c;
// edge plane (0)
target.planeE0.p = target.tri.v0;
target.planeE0.normal = target.cylE0.direction.cross(
    n0).normalize();
// edge plane (1)
target.planeE1.p = target.tri.v1;
target.planeE1.normal = target.cylE1.direction.cross(
    n0).normalize();
// edge plane (2)
target.planeE2.p = target.tri.v2;
target.planeE2.normal = target.cylE2.direction.cross(
    n0).normalize();
// containing node
Ionflux::GeoUtils::Range3 bb0;
bb0.setBounds(target.tri.v0);
bb0.extend(target.tri.v1);
bb0.extend(target.tri.v2);
bb0.extend(target.r_c);
if (!checkRange(bb0))
{
    if (checkBounds0)
    {
        Ionflux::GeoUtils::Range3 bb1;
        bb1.setBounds(target.tri.v0);
        bb1.extend(target.tri.v1);
        bb1.extend(target.tri.v2);
        std::ostringstream status;
        status << "Triangle voxelization not contained in voxel tree "
            "(depth = " << depth << ", voxelSize = " 
            << target.voxelSize << ", tri.bb = [" << bb1.getValueString() 
            << "], tri_vox.bb = [" << bb0.getValueString() 
            << "], tri = [" << getTriangleString(target.tri) 
            << "], r_c = " << target.r_c << ")";
        throw IFVGError(getErrorString(status.str(), 
            "initTriangleVoxelizationData"));
    } else
    {
        // set containing node to root
        target.node.depth = 0;
    }
} else
    getContainingNode(bb0, target.node);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = printDebugInfo
	const = true
	shortDesc = Print debug information
	longDesc = Print debug information.
	impl = <<<
std::cout << "maxNumLevels = " << maxNumLevels << ", order = " 
    << order << ", scale = " << scale << ", tolerance = " 
    << tolerance << ", maxNumLeafChildNodesPerNode = " 
        << maxNumLeafChildNodesPerNode 
    << ", maxNumLeafChildNodesPerDimension = " 
        << maxNumLeafChildNodesPerDimension << std::endl;
std::cout << "valid bits: " << validBits << std::endl;
std::cout << "depth masks: " << std::endl;
if (depthMask != 0)
{
    for (int i = 0; i < maxNumLevels; i++)
    {
        std::cout << "  [" << std::setw(3) << std::setfill('0') 
            << i << "] " << depthMask[i] << std::endl;
    }
} else
{
    std::cout << "  <null>" << std::endl;
}
std::cout << "location masks:" << std::endl;
if (locMask != 0)
{
    for (int i = 0; i < maxNumLevels; i++)
    {
        std::cout << "  [" << std::setw(3) << std::setfill('0') 
            << i << "] " << locMask[i] << std::endl;
    }
} else
{
    std::cout << "  <null>" << std::endl;
}
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getVoxelMesh
	shortDesc = Get voxel mesh
	longDesc = Get a box mesh for the node with the specified ID. If the optional \c colors color set is specified, the vertex colors for the box are selected from the color set according to the depth level of the node and the specified color offset. If \c colorIndex is not negative, the specified color index will be used for selecting a color from the color set. Boxes will be inset by the amount specified in \c boxInset, scaled by the leaf voxel size.
    param[] = {
        type = Ionflux::VolGfx::NodeID
        name = node
        desc = Node ID
    }
    param[] = {
        type = Ionflux::GeoUtils::Mesh&
        name = target
        desc = where to store the mesh
    }
    param[] = {
        type = double
        name = boxInset
        desc = box inset per depth level
        default = DEFAULT_BOX_INSET
    }
    param[] = {
        type = Ionflux::Altjira::ColorSet*
        name = colors
        desc = vertex colors
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorOffset
        desc = color index offset
        default = 0
    }
    param[] = {
        type = int
        name = colorIndex
        desc = color index
        default = COLOR_INDEX_UNSPECIFIED
    }
	impl = <<<
Ionflux::GeoUtils::Range3 r0;
getVoxelRange(node, r0);
if (boxInset != 0.)
{
    double s0 = getMinLeafSize();
    r0.extend(-boxInset * s0 * node.depth);
}
Ionflux::GeoUtils::Mesh* cm0 = r0.getMesh();
addLocalRef(cm0);
if (colors != 0)
{
    unsigned int nc0 = colors->getNumColors();
    if (nc0 > 0)
    {
        unsigned int d0 = static_cast<unsigned int>(node.depth);
        unsigned int ci0 = d0 + colorOffset;
        if (colorIndex >= 0)
            ci0 = colorIndex;
        Ionflux::Altjira::Color* c0 = 
            Ionflux::ObjectBase::nullPointerCheck(
                colors->getColor(ci0 % nc0), this, 
                "getVoxelMesh", "Color");
        Ionflux::GeoUtils::Vector4 cv0;
        Ionflux::GeoUtils::colorToVec(*c0, cv0);
        cm0->setFaceVertexColors(cv0);
    }
}
target.merge(*cm0);
removeLocalRef(cm0);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getVoxelVertexAttributes
	shortDesc = Get voxel vertex attributes
	longDesc = Get vertex attributes for a box mesh for the node with the specified ID. Boxes will be inset by the amount specified in \c boxInset, scaled by the leaf voxel size. Data will be appended to a specified vertex attributes for each target vertex attribute that is not null. If the optional \c color is specified, this color is used for the vertex colors of the box. If the optional \c positionOffset or \c positionScale are specified, vertex positions will be scaled or translated by these vectors.
    param[] = {
        type = Ionflux::VolGfx::NodeID
        name = node
        desc = Node ID
    }
    param[] = {
        type = Ionflux::GeoUtils::VertexAttribute*
        name = positionTarget
        desc = target for position data
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::VertexAttribute*
        name = colorTarget
        desc = target for color data
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::VertexAttribute*
        name = normalTarget
        desc = target for normal data
        default = 0
    }
	param[] = {
	    type = Ionflux::GeoUtils::NFaceTypeID
	    name = nFaceType
	    desc = N-face type
	    default = Ionflux::GeoUtils::NFace::TYPE_FACE
	}
    param[] = {
        type = double
        name = boxInset
        desc = box inset per depth level
        default = DEFAULT_BOX_INSET
    }
    param[] = {
        type = Ionflux::Altjira::Color*
        name = color
        desc = vertex color
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::Vector*
        name = positionOffset
        desc = position offset
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::Vector*
        name = positionScale
        desc = position scale
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::FaceMaskInt
        name = faces
        desc = faces to be rendered
        default = FACE_ALL
    }
    param[] = {
        type = Ionflux::VolGfx::FaceMaskInt
        name = flipNormals
        desc = faces for which the normals should be flipped
        default = FACE_UNDEFINED
    }
	impl = <<<
if (faces == FACE_UNDEFINED)
{
    // Nothing to be done.
    return;
}
Ionflux::GeoUtils::Range3 r0;
getVoxelRange(node, r0);
if (boxInset != 0.)
{
    double s0 = getMinLeafSize();
    r0.extend(-boxInset * s0 * node.depth);
}
// box vertices
Ionflux::GeoUtils::Vector3 v0(r0.getValue(0., 0., 0));
Ionflux::GeoUtils::Vector3 v1(r0.getValue(1., 0., 0));
Ionflux::GeoUtils::Vector3 v2(r0.getValue(1., 1., 0));
Ionflux::GeoUtils::Vector3 v3(r0.getValue(0., 1., 0));
Ionflux::GeoUtils::Vector3 v4(r0.getValue(0., 0., 1));
Ionflux::GeoUtils::Vector3 v5(r0.getValue(1., 0., 1));
Ionflux::GeoUtils::Vector3 v6(r0.getValue(1., 1., 1));
Ionflux::GeoUtils::Vector3 v7(r0.getValue(0., 1., 1));
if (positionScale != 0)
{
    v0.multiplyIP(*positionScale);
    v1.multiplyIP(*positionScale);
    v2.multiplyIP(*positionScale);
    v3.multiplyIP(*positionScale);
    v4.multiplyIP(*positionScale);
    v5.multiplyIP(*positionScale);
    v6.multiplyIP(*positionScale);
    v7.multiplyIP(*positionScale);
}
if (positionOffset != 0)
{
    v0.addIP(*positionOffset);
    v1.addIP(*positionOffset);
    v2.addIP(*positionOffset);
    v3.addIP(*positionOffset);
    v4.addIP(*positionOffset);
    v5.addIP(*positionOffset);
    v6.addIP(*positionOffset);
    v7.addIP(*positionOffset);
}
unsigned int numQuads = 0;
unsigned int numVerts = 0;
if (positionTarget != 0)
{
    // vertex positions
    unsigned int ne0 = positionTarget->getNumElements();
    if (nFaceType == Ionflux::GeoUtils::NFace::TYPE_FACE)
    {
        /* triangle faces
           6 faces * 2 triangles * 3 vertices = 36 vertices */
        numQuads = getNumFacesSet(faces);
        if (numQuads > 0)
        {
            numVerts = numQuads * 2 * 3;
            unsigned int offset0 = 0;
            bool reverse = false;
            positionTarget->resize(ne0 + numVerts, 3, 
                Ionflux::GeoUtils::DATA_TYPE_FLOAT, 2.);
            if (checkFaceMask(faces, FACE_Z0))
            {
                // quad (0, Z0)
                reverse = checkFaceMask(flipNormals, FACE_Z0);
                setVertexAttributeTrianglePos(*positionTarget, ne0, 
                    v0, v2, v1, reverse);
                setVertexAttributeTrianglePos(*positionTarget, ne0 + 3, 
                    v0, v3, v2, reverse);
                offset0 += 6;
            }
            if (checkFaceMask(faces, FACE_Z1))
            {
                // quad (1, Z1)
                reverse = checkFaceMask(flipNormals, FACE_Z1);
                setVertexAttributeTrianglePos(*positionTarget, 
                    ne0 + offset0, 
                    v4, v5, v6, reverse);
                setVertexAttributeTrianglePos(*positionTarget, 
                    ne0 + offset0 + 3, 
                    v4, v6, v7, reverse);
                offset0 += 6;
            }
            if (checkFaceMask(faces, FACE_Y0))
            {
                // quad (2, Y0)
                reverse = checkFaceMask(flipNormals, FACE_Y0);
                setVertexAttributeTrianglePos(*positionTarget, 
                    ne0 + offset0, 
                    v0, v1, v5, reverse);
                setVertexAttributeTrianglePos(*positionTarget, 
                    ne0 + offset0 + 3, 
                    v0, v5, v4, reverse);
                offset0 += 6;
            }
            if (checkFaceMask(faces, FACE_X1))
            {
                // quad (3, X1)
                reverse = checkFaceMask(flipNormals, FACE_X1);
                setVertexAttributeTrianglePos(*positionTarget, 
                    ne0 + offset0, 
                    v1, v2, v6, reverse);
                setVertexAttributeTrianglePos(*positionTarget, 
                    ne0 + offset0 + 3, 
                    v1, v6, v5, reverse);
                offset0 += 6;
            }
            if (checkFaceMask(faces, FACE_X0))
            {
                // quad (4, X0)
                reverse = checkFaceMask(flipNormals, FACE_X0);
                setVertexAttributeTrianglePos(*positionTarget, 
                    ne0 + offset0, 
                    v0, v4, v3, reverse);
                setVertexAttributeTrianglePos(*positionTarget, 
                    ne0 + offset0 + 3, 
                    v3, v4, v7, reverse);
                offset0 += 6;
            }
            if (checkFaceMask(faces, FACE_Y1))
            {
                // quad (5, Y1)
                reverse = checkFaceMask(flipNormals, FACE_Y1);
                setVertexAttributeTrianglePos(*positionTarget, 
                    ne0 + offset0, 
                    v2, v7, v6, reverse);
                setVertexAttributeTrianglePos(*positionTarget, 
                    ne0 + offset0 + 3, 
                    v2, v3, v7, reverse);
            }
        }
    } else
    if (nFaceType == Ionflux::GeoUtils::NFace::TYPE_EDGE)
    {
        /* edges
           12 edges * 2 vertices = 24 vertices */
        positionTarget->resize(ne0 + 24, 3, 
            Ionflux::GeoUtils::DATA_TYPE_FLOAT, 2.);
        // quad (0, Z0)
        positionTarget->setData(ne0, v0);
        positionTarget->setData(ne0 + 1, v3);
        positionTarget->setData(ne0 + 2, v3);
        positionTarget->setData(ne0 + 3, v2);
        positionTarget->setData(ne0 + 4, v2);
        positionTarget->setData(ne0 + 5, v1);
        positionTarget->setData(ne0 + 6, v1);
        positionTarget->setData(ne0 + 7, v0);
        // quad (1, Z1)
        positionTarget->setData(ne0 + 8, v4);
        positionTarget->setData(ne0 + 9, v5);
        positionTarget->setData(ne0 + 10, v5);
        positionTarget->setData(ne0 + 11, v6);
        positionTarget->setData(ne0 + 12, v6);
        positionTarget->setData(ne0 + 13, v7);
        positionTarget->setData(ne0 + 14, v7);
        positionTarget->setData(ne0 + 15, v4);
        // Z-edges
        positionTarget->setData(ne0 + 16, v0);
        positionTarget->setData(ne0 + 17, v4);
        positionTarget->setData(ne0 + 18, v1);
        positionTarget->setData(ne0 + 19, v5);
        positionTarget->setData(ne0 + 20, v2);
        positionTarget->setData(ne0 + 21, v6);
        positionTarget->setData(ne0 + 22, v3);
        positionTarget->setData(ne0 + 23, v7);
    }
}
if ((colorTarget != 0) 
    && (color != 0))
{
    // vertex colors
    Ionflux::GeoUtils::Vector4 cv0;
    Ionflux::GeoUtils::colorToVec(*color, cv0);
    unsigned int ne0 = colorTarget->getNumElements();
    if (nFaceType == Ionflux::GeoUtils::NFace::TYPE_FACE)
    {
        /* triangle faces
           6 faces * 2 triangles * 3 vertices = 36 vertices */
        if (numVerts == 0)
        {
            throw IFVGError(getErrorString(
                "Number of vertices is 0.", 
                "getVoxelVertexAttributes"));
        }
        colorTarget->resize(ne0 + numVerts, 4, 
            Ionflux::GeoUtils::DATA_TYPE_FLOAT, 2.);
        for (unsigned int i = 0; i < numVerts; i++)
            colorTarget->setData(ne0 + i, cv0);
    } else
    if (nFaceType == Ionflux::GeoUtils::NFace::TYPE_EDGE)
    {
        /* edges
           12 edges * 2 vertices = 24 vertices */
        colorTarget->resize(ne0 + 24, 4, 
            Ionflux::GeoUtils::DATA_TYPE_FLOAT, 2.);
        for (unsigned int i = 0; i < 24; i++)
            colorTarget->setData(ne0 + i, cv0);
    }
}
if (normalTarget != 0)
{
    // vertex normals
    unsigned int ne0 = normalTarget->getNumElements();
    if (nFaceType == Ionflux::GeoUtils::NFace::TYPE_FACE)
    {
        /* triangle faces
           6 faces * 2 triangles * 3 vertices = 36 vertices */
        unsigned int offset0 = 0;
        if (numVerts == 0)
        {
            throw IFVGError(getErrorString(
                "Number of vertices is 0.", 
                "getVoxelVertexAttributes"));
        }
        normalTarget->resize(ne0 + numVerts, 3, 
            Ionflux::GeoUtils::DATA_TYPE_FLOAT, 2.);
        Ionflux::GeoUtils::Vector3 cn0;
        if (checkFaceMask(faces, FACE_Z0))
        {
            // quad (0, Z0)
            if (!checkFaceMask(flipNormals, FACE_Z0))
                cn0 = Ionflux::GeoUtils::Vector3::E_Z.flip();
            else
                cn0 = Ionflux::GeoUtils::Vector3::E_Z;
            for (unsigned int i = 0; i < 6; i++)
                normalTarget->setData(ne0 + i, cn0);
            offset0 += 6;
        }
        if (checkFaceMask(faces, FACE_Z1))
        {
            // quad (1, Z1)
            if (!checkFaceMask(flipNormals, FACE_Z1))
                cn0 = Ionflux::GeoUtils::Vector3::E_Z;
            else
                cn0 = Ionflux::GeoUtils::Vector3::E_Z.flip();
            for (unsigned int i = 0; i < 6; i++)
                normalTarget->setData(ne0 + offset0 + i, cn0);
            offset0 += 6;
        }
        if (checkFaceMask(faces, FACE_Y0))
        {
            // quad (2, Y0)
            if (!checkFaceMask(flipNormals, FACE_Y0))
                cn0 = Ionflux::GeoUtils::Vector3::E_Y.flip();
            else
                cn0 = Ionflux::GeoUtils::Vector3::E_Y;
            for (unsigned int i = 0; i < 6; i++)
                normalTarget->setData(ne0 + offset0 + i, cn0);
            offset0 += 6;
        }
        if (checkFaceMask(faces, FACE_X1))
        {
            // quad (3, X1)
            if (!checkFaceMask(flipNormals, FACE_X1))
                cn0 = Ionflux::GeoUtils::Vector3::E_X;
            else
                cn0 = Ionflux::GeoUtils::Vector3::E_X.flip();
            for (unsigned int i = 0; i < 6; i++)
                normalTarget->setData(ne0 + offset0 + i, cn0);
            offset0 += 6;
        }
        if (checkFaceMask(faces, FACE_X0))
        {
            // quad (4, X0)
            if (!checkFaceMask(flipNormals, FACE_X0))
                cn0 = Ionflux::GeoUtils::Vector3::E_X.flip();
            else
                cn0 = Ionflux::GeoUtils::Vector3::E_X;
            for (unsigned int i = 0; i < 6; i++)
                normalTarget->setData(ne0 + offset0 + i, cn0);
            offset0 += 6;
        }
        if (checkFaceMask(faces, FACE_Y1))
        {
            // quad (5, Y1)
            if (!checkFaceMask(flipNormals, FACE_Y1))
                cn0 = Ionflux::GeoUtils::Vector3::E_Y;
            else
                cn0 = Ionflux::GeoUtils::Vector3::E_Y.flip();
            for (unsigned int i = 0; i < 6; i++)
                normalTarget->setData(ne0 + offset0 + i, cn0);
        }
    } else
    if (nFaceType == Ionflux::GeoUtils::NFace::TYPE_EDGE)
    {
        /* edges
           12 edges * 2 vertices = 24 vertices */
        normalTarget->resize(ne0 + 24, 3, 
            Ionflux::GeoUtils::DATA_TYPE_FLOAT, 2.);
        // quad (0)
        for (unsigned int i = 0; i < 8; i++)
            normalTarget->setData(ne0 + i, 
                Ionflux::GeoUtils::Vector3::E_Z.flip());
        // quad (1)
        for (unsigned int i = 0; i < 8; i++)
            normalTarget->setData(ne0 + 8 + i, 
                Ionflux::GeoUtils::Vector3::E_Z);
        // Z-edges
        for (unsigned int i = 0; i < 4; i++)
            normalTarget->setData(ne0 + 16 + i, 
                Ionflux::GeoUtils::Vector3::E_Y.flip());
        for (unsigned int i = 0; i < 4; i++)
            normalTarget->setData(ne0 + 20 + i, 
                Ionflux::GeoUtils::Vector3::E_Y);
    }
}
>>>
}
function.public[] = {
	spec = virtual
	type = bool
	name = getIntersectionLoc
	shortDesc = Get line intersection
	longDesc = Get the intersection location codes for the specified intersection data. If there is a valid intersection, the intersection location codes will be stored in \c target. Otherwise, \c target will be undefined and the function returns \c false.
    param[] = {
        type = Ionflux::GeoUtils::Line3&
        name = line
        desc = Line
    }
    param[] = {
        type = const Ionflux::GeoUtils::AAPlanePairIntersection&
        name = interData
        desc = Intersection data
    }
    param[] = {
        type = Ionflux::VolGfx::Region3&
        name = target
        desc = Where to store the intersection location codes
    }
	param[] = {
	    type = bool
	    name = checkBounds0
	    desc = check bounds
	    default = true
	}
	impl = <<<
if (!interData.valid)
    return false;
target.l0 = createLoc(line.eval(interData.tNear), checkBounds0);
target.l1 = createLoc(line.eval(interData.tFar), checkBounds0);
>>>
    return = {
        value = true
        desc = \c true if the intersection data is valid, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = getIntersectionLoc
	shortDesc = Get line intersection
	longDesc = Get the intersection location codes for the specified intersection data and node ID. If there is a valid intersection, the intersection location codes will be stored in \c target. Otherwise, \c target will be undefined and the function returns \c false. If \c clampToNodeRegion is true, this function ensures that the intersection locations will be located within the region as returned by getVoxelRegion().
    param[] = {
        type = const Ionflux::VolGfx::NodeID&
        name = node
        desc = Node
    }
    param[] = {
        type = Ionflux::GeoUtils::Line3&
        name = line
        desc = Line
    }
    param[] = {
        type = const Ionflux::GeoUtils::AAPlanePairIntersection&
        name = interData
        desc = Intersection data
    }
    param[] = {
        type = Ionflux::VolGfx::Region3&
        name = target
        desc = Where to store the intersection location codes
    }
    param[] = {
        type = bool
        name = clampToNodeRegion
        desc = Clamp values to node region
        default = true
    }
    param[] = {
        type = bool
        name = includeMaxBoundary
        desc = Include the node maximum boundary in the region
        default = false
    }
	impl = <<<
if (!interData.valid)
    return false;
Region3 t0, r0;
getIntersectionLoc(line, interData, t0, false);
if (!clampToNodeRegion)
    return true;
getVoxelRegion(node, r0, includeMaxBoundary);
target.l0 = clampLoc3(t0.l0, r0);
target.l1 = clampLoc3(t0.l1, r0);
>>>
    return = {
        value = true
        desc = \c true if the intersection data is valid, \c false otherwise
    }
}

# public member functions overridden from IFObject
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object.
	impl = <<<
std::ostringstream status;
status << "maxNumLevels = " << maxNumLevels << ", order = " 
    << order << ", scale = " << scale << ", tolerance = " 
    << tolerance << ", maxNumLeafChildNodesPerNode = " 
    << maxNumLeafChildNodesPerNode 
    << ", maxNumLeafChildNodesPerDimension = " 
        << maxNumLeafChildNodesPerDimension;
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}

# Static member functions.
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Vector3*
	name = getVoxelDiag
	shortDesc = Get voxel diagonal vector
	longDesc = Get the voxel diagonal unit vector with the specified index.
	param[] = {
	    type = int
	    name = index
	    desc = index
	}
	impl = <<<
if (voxelDiag == 0)
{
    // initialize static voxel diagonal vectors
    voxelDiag = new Ionflux::GeoUtils::Vector3[8];
    Ionflux::ObjectBase::nullPointerCheck(voxelDiag, 
        "Context::getVoxelDiag", "Voxel diagonal vector array");
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            for (int k = 0; k < 2; k++)
            {
                voxelDiag[4 * i + 2 * j + k].setElements(
                    (-1 + 2 * k) * SQRT_3_INV, 
                    (-1 + 2 * j) * SQRT_3_INV, 
                    (-1 + 2 * i) * SQRT_3_INV);
            }
        }
    }
}
Ionflux::ObjectBase::rangeCheck(index, 0, 7, 
    "Context::getVoxelDiag", "Index");
>>>
    return = {
        value = &(voxelDiag[index]);
        desc = Voxel diagonal unit vector
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Vector3*
	name = getVoxelDiag
	shortDesc = Get voxel diagonal vector
	longDesc = Get the voxel diagonal unit vector with the specified indices.
	param[] = {
	    type = int
	    name = x
	    desc = index (x)
	}
	param[] = {
	    type = int
	    name = y
	    desc = index (y)
	}
	param[] = {
	    type = int
	    name = z
	    desc = index (z)
	}
	impl = 
    return = {
        value = getVoxelDiag(4 * z + 2 * y + x);
        desc = Voxel diagonal unit vector
    }
}
function.public[] = {
	spec = static
	type = void
	name = cleanupVoxelDiag
	shortDesc = Clean up voxel diagonal vectors
	longDesc = Clean up the global voxel diagonal vectors.
	impl = <<<
if (voxelDiag != 0)
    delete[] voxelDiag;
voxelDiag = 0;
>>>
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Vector3*
	name = getMatchingVoxelDiag
	shortDesc = Get matching voxel diagonal vector
	longDesc = Get the voxel diagonal unit vector that best matches the specified vector.
	param[] = {
	    type = const Ionflux::GeoUtils::Vector3&
	    name = v
	    desc = vector
	}
	impl = <<<
Ionflux::GeoUtils::Vector3 s0;
v.getElementSigns(s0);
Ionflux::GeoUtils::Vector3 c0((s0 
    + Ionflux::GeoUtils::Vector3::E_SUM) / 2.);
>>>
    return = {
        value = getVoxelDiag(c0[0], c0[1], c0[2])
        desc = Matching voxel diagonal vector
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Vector3*
	name = getVoxelNormal
	shortDesc = Get voxel face normal vector
	longDesc = Get the voxel face normal vector with the specified index.
	param[] = {
	    type = int
	    name = index
	    desc = index
	}
	impl = <<<
if (voxelNormal == 0)
{
    // initialize static voxel face normal vectors
    voxelNormal = new Ionflux::GeoUtils::Vector3[6];
    Ionflux::ObjectBase::nullPointerCheck(voxelNormal, 
        "Context::getVoxelDiag", "Voxel face normal vector array");
    for (int i = 0; i < 3; i++)
    {
        voxelNormal[2 * i].setElement(i, -1.);
        voxelNormal[2 * i + 1].setElement(i, 1.);
    }
}
Ionflux::ObjectBase::rangeCheck(index, 0, 5, 
    "Context::getVoxelNormal", "Index");
>>>
    return = {
        value = &(voxelNormal[index]);
        desc = Voxel face normal vector
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Vector3*
	name = getMatchingVoxelNormal
	shortDesc = Get matching voxel face normal vector
	longDesc = Get the voxel face normal vector that best matches the specified vector.
	param[] = {
	    type = const Ionflux::GeoUtils::Vector3&
	    name = v
	    desc = vector
	}
	impl = <<<
Ionflux::GeoUtils::Vector3* result = 0;
double bc0 = 0.;
for (int i = 0; i < 6; i++)
{
    Ionflux::GeoUtils::Vector3* n0 = getVoxelNormal(i);
    double cc0 = v.angleCos(*n0);
    if ((cc0 > 0.) 
        && (cc0 > bc0))
    {
        bc0 = cc0;
        result = n0;
    }
}
>>>
    return = {
        value = result
        desc = Matching voxel face normal vector
    }
}
function.public[] = {
	spec = static
	type = void
	name = cleanupVoxelNormal
	shortDesc = Clean up voxel normal vectors
	longDesc = Clean up the global voxel normal vectors.
	impl = <<<
if (voxelNormal != 0)
    delete[] voxelNormal;
voxelNormal = 0;
>>>
}
function.public[] = {
	spec = static
	type = void
	name = cleanup
	shortDesc = Clean up global data
	longDesc = Clean up any global data that has been allocated by one of the static context functions.
	impl = <<<
cleanupVoxelDiag();
cleanupVoxelNormal();
>>>
}

# Pure virtual member functions.

# operations

# Global functions.

