# ===================================================================
# IFVG - Ionflux' Volumetric Graphics Library
# Copyright © 2014 Jörn P. Meier
# mail@ionflux.org
# -------------------------------------------------------------------
# Node.conf              Class configuration.
# ===================================================================
# 
# This file is part of IFVG - Ionflux' Volumetric Graphics Library.
# 
# IFVG - Ionflux' Volumetric Graphics Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# IFVG - Ionflux' Volumetric Graphics Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with IFVG - Ionflux' Volumetric Graphics Library; if not, write to 
# the Free Software  Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
# MA 02111-1307 USA
# 
# ===================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/types.hpp"'
        '"ifobject/constants.hpp"'
        '"altjira/Color.hpp"'
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/Vector3.hpp"'
        '"geoutils/Range3.hpp"'
        '"geoutils/Line3.hpp"'
        '"geoutils/Mesh.hpp"'
        '"geoutils/NFace.hpp"'
        '"ifvg/types.hpp"'
        '"ifvg/constants.hpp"'
        '"ifvg/Context.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '<algorithm>'
        '"ifobject/utils.hpp"'
        '"ifobject/objectutils.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/imageutils.hpp"'
        '"geoutils/FaceData.hpp"'
        '"ifvg/utils.hpp"'
        '"ifvg/serialize.hpp"'
        '"ifvg/IFVGError.hpp"'
        '"ifvg/NodeSet.hpp"'
        '"ifvg/IOContext.hpp"'
        '"ifvg/NodeProcessor.hpp"'
        '"ifvg/NodeFilter.hpp"'
        '"ifvg/NodeIntersectionProcessor.hpp"'
    }
}

# forward declarations
forward = {
    'class NodeSet'
    'class IOContext'
    'class NodeProcessor'
    'class NodeFilter'
    'class NodeIntersectionProcessor'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Node
	shortDesc = Voxel tree node
	title = Voxel tree node
	longDesc = <<<
A data node in a voxel tree. The data node is a wrapper around a NodeImpl object, which, together with the static 'Impl' member functions of Node, provides the low-level implementation of the node hierarchy. Node is intended as a convenient interface for operations on the root node of a voxel tree hierarchy. In this function, it provides automatic memory management for the voxel tree. However, it is usually best to use the NodeImpl object and the static 'Impl' functions directly when implementing low-level operations for voxel tree nodes.

Node should always be constructed with a Context, which provides meta-information needed for the voxel tree operations.
>>>
	group.name = ifvg
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
		}
	}
    features = {
        'copy'
        'upcast'
        'create'
        'classinfo'
        #'xmlio'
    }
    create = {
        allocationError = IFVGError("Could not allocate object")
        extendedCreate = true
    }
}

# Member variables.

# Public static constants.
constant.public[] = {
    type = Ionflux::VolGfx::NodeDataType
    name = DATA_TYPE_UNKNOWN
    desc = Node data type: unknown
    value = 0
}
constant.public[] = {
    type = Ionflux::VolGfx::NodeDataType
    name = DATA_TYPE_NULL
    desc = Node data type: null
    value = 1
}
constant.public[] = {
    type = Ionflux::VolGfx::NodeDataType
    name = DATA_TYPE_DENSITY
    desc = Node data type: density
    value = 2
}
constant.public[] = {
    type = Ionflux::VolGfx::NodeDataType
    name = DATA_TYPE_COLOR_RGBA
    desc = Node data type: color (RGBA)
    value = 3
}
constant.public[] = {
    type = Ionflux::VolGfx::NodeDataType
    name = DATA_TYPE_DISTANCE_8
    desc = Node data type: distance field (8 elements)
    value = 4
}
constant.public[] = {
    type = Ionflux::VolGfx::NodeDataType
    name = DATA_TYPE_COLOR_NORMAL
    desc = Node data type: color/normal
    value = 5
}
constant.public[] = {
    type = Ionflux::VolGfx::NodeDataType
    name = DATA_TYPE_FACE_VEC
    desc = Node data type: face vector
    value = 6
}
constant.public[] = {
    type = Ionflux::VolGfx::NodeDataType
    name = DATA_TYPE_VOXEL_CLASS
    desc = Node data type: voxel class
    value = 7
}
constant.public[] = {
    type = Ionflux::VolGfx::NodeDataType
    name = DATA_TYPE_VOXEL_IOB
    desc = Node data type: voxel inside/outside/boundary
    value = 8
}
constant.public[] = {
    type = Ionflux::VolGfx::NodeDataType
    name = DATA_TYPE_ANY_NOT_NULL
    desc = Node data type: any (not null)
    value = 100
}
constant.public[] = {
    type = int
    name = CHILD_INDEX_INVALID
    desc = Child index: invalid
    value = -1
}
constant.public[] = {
    type = Ionflux::ObjectBase::MagicSyllable
    name = MAGIC_SYLLABLE_HEADER
    desc = Magic syllable: header (HE)
    value = 0x4845
}
constant.public[] = {
    type = Ionflux::ObjectBase::MagicSyllable
    name = MAGIC_SYLLABLE_ROOT
    desc = Magic syllable: root (NR)
    value = 0x4e52
}
constant.public[] = {
    type = Ionflux::ObjectBase::MagicSyllable
    name = MAGIC_SYLLABLE_NODE
    desc = Magic syllable: node (NO)
    value = 0x4e4f
}
constant.public[] = {
    type = Ionflux::ObjectBase::MagicSyllable
    name = MAGIC_SYLLABLE_OFFSET_MAP
    desc = Magic syllable: offset map (OM)
    value = 0x4f4d
}
constant.public[] = {
    type = Ionflux::ObjectBase::MagicSyllable
    name = MAGIC_SYLLABLE_DATA
    desc = Magic syllable: node data (ND)
    value = 0x4e44
}
constant.public[] = {
    type = double
    name = DEFAULT_RAY_PLANE_OFFSET
    desc = Default ray plane offset
    value = 0.5
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    type = Ionflux::VolGfx::NodeImpl*
    setFromType = Ionflux::VolGfx::NodeImpl*
    name = impl
    desc = Node implementation
    impl.set = <<<
if (impl == newImpl)
    return;
if (newImpl != 0)
{
    if ((newImpl->parent != 0) 
        && (newImpl->refCount < 1))
    {
        /* Node implementation must have a reference from its 
           parent. */
        throw IFVGError(getErrorString("Attempt to reference "
            "node implementation that has a parent and no "
            "reference.", "setImpl"));
    }
    refImpl(newImpl);
}
if (impl != 0)
{
    if ((impl->parent != 0) 
        && (impl->refCount < 2))
    {
        /* Node implementation must have a reference from its 
           parent and this node. */
        throw IFVGError(getErrorString("Attempt to unreference "
            "node implementation that has a parent and less than "
            "two references.", "setImpl"));
    }
    unrefImpl(impl);
}
impl = newImpl;
>>>
}
property.protected[] = {
    type = Ionflux::VolGfx::Context*
    setFromType = Ionflux::VolGfx::Context*
    name = context
    desc = Voxel tree context
    managed = true
}

# Protected static constants.

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = impl
        value = 0
    }
    initializer[] = {
        name = context
        value = 0
    }
    impl = setImpl(createImpl());
}
constructor.public[] = {
    initializer[] = {
        name = impl
        value = 0
    }
    initializer[] = {
        name = context
        value = 0
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = initContext
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = initImpl
        desc = Node implementation
        default = 0
    }
    impl = <<<
if (initContext != 0)
    setContext(initContext);
if (initImpl != 0)
    setImpl(initImpl);
else
    setImpl(createImpl());
>>>
}

# Destructor.
destructor.impl = <<<
if (impl != 0)
    setImpl(0);
>>>

# Protected member functions.

# Public member functions.
function.copy.impl = <<<
if (this == &other)
    return *this;
setContext(other.context);
setImpl(other.impl);
>>>
function.public[] = {
	spec = virtual
	type = void
	name = clear
	const = true
	shortDesc = Clear node
	longDesc = Clear all data in the node.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "clear", "Node implementation");
clearImpl(impl, true, true, true);
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = getParent
	const = true
	shortDesc = Get parent node
	longDesc = Get the parent node. The caller is responsible for managing the returned object.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getParent", "Node implementation");
>>>
    return = {
        value = wrapImpl(impl->parent, context)
        desc = Parent node, or 0 if the parent node does not exist
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setChildNodes
	const = true
	shortDesc = Set child nodes
	longDesc = Set the child nodes of this node. \c newNodes is expected to be a vector containing a number of nodes equal or greater than the the maximum number of child nodes per node, ordered by ascending local X, Y, Z coordinate. Invalid nodes are identified by a zero entry within the vector.
	param[] = {
	    type = const Ionflux::VolGfx::NodeVector&
	    name = newNodes
	    desc = Vector of nodes
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "setChildNodes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "setChildNodes", "Context");
int n0 = context->getMaxNumLeafChildNodesPerNode();
if (newNodes.size() < static_cast<unsigned int>(n0))
{
    std::ostringstream status;
    status << "Unexpected number of nodes in vector (expected: " 
        << n0 << ", got: " << newNodes.size() << ")";
    throw IFVGError(getErrorString(status.str(), "setChildNodes"));
}
NodeImplVector niv;
for (int i = 0; i < n0; i++)
{
    Node* cn = newNodes[i];
    if (cn != 0)
    {
        NodeImpl* ci = cn->getImpl();
        Ionflux::ObjectBase::nullPointerCheck(ci, this, 
            "setChildNodes", "Child node implementation");
        niv.push_back(ci);
    } else
        niv.push_back(0);
}
setImplChildNodes(impl, context, niv);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = mergeChildNodes
	const = true
	shortDesc = Merge child nodes
	longDesc = Merge the nodes from the vector with the current child nodes of this node. \c newNodes is expected to be a vector containing a number of node implementations equal or greater than the maximum number of child nodes per node, ordered by ascending local X, Y, Z coordinate. Nodes that should not be changed are identified by a zero entry within the vector. A new node implementation will be created for each entry in \c newNodes. This node implementation takes over all data and child nodes from the entry in \c newNodes.
	param[] = {
	    type = const Ionflux::VolGfx::NodeImplVector&
	    name = newNodes
	    desc = Vector of node implementations
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "mergeChildNodes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "mergeChildNodes", "Context");
mergeImplChildNodes(impl, context, newNodes, fill0);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = mergeChildNodes
	const = true
	shortDesc = Merge child nodes
	longDesc = Merge the nodes from the vector with the current child nodes of this node. \c newNodes is expected to be a vector containing a number of node implementations equal or greater than the maximum number of child nodes per node, ordered by ascending local X, Y, Z coordinate. Nodes that should not be changed are identified by a zero entry within the vector. A new node implementation will be created for each entry in \c newNodes. This node implementation takes over all data and child nodes from the entry in \c newNodes.
	param[] = {
	    type = const Ionflux::VolGfx::NodeVector&
	    name = newNodes
	    desc = Vector of nodes
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "mergeChildNodes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "mergeChildNodes", "Context");
int n0 = context->getMaxNumLeafChildNodesPerNode();
if (newNodes.size() < static_cast<unsigned int>(n0))
{
    std::ostringstream status;
    status << "Unexpected number of nodes in vector (expected: " 
        << n0 << ", got: " << newNodes.size() << ")";
    throw IFVGError(getErrorString(status.str(), "mergeChildNodes"));
}
NodeImplVector niv;
for (int i = 0; i < n0; i++)
{
    Node* cn = newNodes[i];
    if (cn != 0)
    {
        NodeImpl* ci = cn->getImpl();
        Ionflux::ObjectBase::nullPointerCheck(ci, this, 
            "mergeChildNodes", "Child node implementation");
        niv.push_back(ci);
    } else
        niv.push_back(0);
}
mergeImplChildNodes(impl, context, niv, fill0);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = setChildNodeByOrderIndex
	const = true
	shortDesc = Set child node
	longDesc = Set the child node for the child node with the specified order index.
	param[] = {
	    type = Ionflux::VolGfx::Node*
	    name = newNode
	    desc = Child node
	}
	param[] = {
	    type = int
	    name = orderIndex
	    desc = Order index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "setChildNodeByOrderIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "setChildNodeByOrderIndex", "Context");
Ionflux::ObjectBase::nullPointerCheck(newNode, this, 
    "setChildNodeByOrderIndex", "Node");
NodeImpl* nImpl = newNode->getImpl();
Ionflux::ObjectBase::nullPointerCheck(nImpl, this, 
    "setChildNodeByOrderIndex", "Node implementation (new)");
setImplChildByOrderIndex(impl, context, nImpl, orderIndex);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = clearChildNodes
	const = true
	shortDesc = Clear child nodes
	longDesc = Clear the child nodes indicated by a bit set in the location mask.
	param[] = {
	    type = const Ionflux::VolGfx::NodeChildMask&
	    name = clearNodes
	    desc = Mask indicating nodes to be cleared
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "clearChildNodes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "clearChildNodes", "Context");
clearImplChildNodes(impl, context, clearNodes);
>>>
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = pruneEmpty
	const = true
	shortDesc = Prune empty child nodes
	longDesc = Clear the child nodes which are leaf nodes but do not contain any data.
    param[] = {
        type = bool
        name = recursive
        desc = recursively prune nodes
        default = false
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "pruneEmpty", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "pruneEmpty", "Context");
>>>
    return = {
        value = pruneEmptyImpl(impl, context, recursive);
        desc = number of nodes that were pruned
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = clearData
	const = true
	shortDesc = Clear data
	longDesc = Clear data of this node.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "clearData", "Node implementation");
clearImpl(impl, true, true, false);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = clearChildNodes
	const = true
	shortDesc = Clear child nodes
	longDesc = Clear child nodes of this node. If this node is leaf node, this function will not do anything.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "clearChildNodes", "Node implementation");
if (isImplLeaf(impl))
    return;
clearImpl(impl, true, false, true);
NodeImpl* pi = impl->parent;
if (pi != 0)
    updateImpl(pi, context);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = setData
	const = true
	shortDesc = Set data
	longDesc = Set the data of this node. The node implementation will take ownership of the data.
	param[] = {
	    type = Ionflux::VolGfx::NodeDataImpl*
	    name = newData
	    desc = Node data
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "setData", "Node implementation");
clearImpl(impl, false, true, false);
impl->data = newData;
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = setData
	const = true
	shortDesc = Set data
	longDesc = Set the data of this node to a new data instance of the specified type. If the node is not a leaf, any child nodes will be deleted. If the optional \c newData is specified, elements from this vector will be used to initialize the data record according to the data type.
	param[] = {
	    type = Ionflux::VolGfx::NodeDataType
	    name = newType
	    desc = Node data type
	}
	param[] = {
	    type = const Ionflux::ObjectBase::DoubleVector*
	    name = newData
        desc = Node data vector
        default = 0
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "setData", "Node implementation");
NodeDataImpl* d0 = createDataImpl(newType, newData);
clearImpl(impl, false, true, false);
impl->data = d0;
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = clearLeafData
	const = true
	shortDesc = Clear leaf data
	longDesc = Clear the leaf data of this node. If this node is not a leaf node, this function will not do anything.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "clearLeafData", "Node implementation");
if (!isLeaf())
    return;
clearImpl(impl, false, true, false);
>>>
}
function.public[] = {
	spec = virtual
	type = int
	name = getNumChildNodes
	const = true
	shortDesc = Get number of child nodes
	longDesc = Get the number of valid child nodes of this node.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getNumChildNodes", "Node implementation");
>>>
    return = {
        value = getImplNumChildNodes(impl)
        desc = Number of child nodes
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = fill
	const = true
	shortDesc = Fill node
	longDesc = Fill the node. This creates new child nodes so that all children of this node are valid. If \c clearExisting is set to \c true, any existing data is cleared. If \c recursive is set to \c true, child nodes are filled recursively. If \c maxDepth is greater than zero, child nodes will be filled up to and including the maximum depth specified.
	param[] = {
	    type = bool
	    name = clearExisting
	    desc = Clear existing data
	    default = false
	}
	param[] = {
	    type = bool
	    name = recursive
	    desc = Fill nodes recursively
	    default = false
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = 0
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "fill", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "fill", "Context");
>>>
    return = {
        value = fillImpl(impl, context, clearExisting, recursive, maxDepth);
        desc = Number of new nodes that have been created
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = getChildValidIndex
	const = true
	shortDesc = Get valid child index
	longDesc = Get the index of the specified child node among the valid child nodes.
	param[] = {
	    type = Ionflux::VolGfx::Node*
	    name = n
	    desc = Node
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getValidChildIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(n, this, 
    "getValidChildIndex", "Node");
NodeImpl* oi = n->getImpl();
Ionflux::ObjectBase::nullPointerCheck(oi, this, 
    "getValidChildIndex", "Node implementation (other)");
>>>
    return = {
        value = getImplChildValidIndex(impl, oi)
        desc = Index of the specified child node among the valid child nodes, or CHILD_INDEX_INVALID if the node is not a child of this node
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = getChildValidIndex
	const = true
	shortDesc = Get valid child index
	longDesc = Get the index of the specified child node implementation among the valid child node implementations.
	param[] = {
	    type = Ionflux::VolGfx::NodeImpl*
	    name = otherImpl
	    desc = Node implementation
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getValidChildIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(otherImpl, this, 
    "getValidChildIndex", "Node implementation (other)");
>>>
    return = {
        value = getImplChildValidIndex(impl, otherImpl)
        desc = Index of the specified child node among the valid child nodes, or CHILD_INDEX_INVALID if the node is not a child of this node
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = getChildValidIndex
	const = true
	shortDesc = Get valid child index
	longDesc = Get the index of the child node with the specified order index among the valid child nodes.
	param[] = {
	    type = int
	    name = orderIndex
	    desc = Order index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getChildValidIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "setChildNodes", "Context");
>>>
    return = {
        value = getImplChildValidIndex(impl, context, orderIndex)
        desc = Index of the specified child node among the valid child nodes, or CHILD_INDEX_INVALID if the node is not a child of this node
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = getChildOrderIndex
	const = true
	shortDesc = Get child order index
	longDesc = Get the index of the child node with the specified valid index among all child nodes (including invalid nodes). This can be used to calculate the coordinates of a child node or to test the mask bits.
	param[] = {
	    type = int
	    name = index
	    desc = Index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getChildOrderIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getChildOrderIndex", "Context");
>>>
    return = {
        value = getImplChildOrderIndex(impl, context, index)
        desc = \c true if the child with the specified index is a leaf node, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::NodeLoc3
	name = getChildLoc
	const = true
	shortDesc = Get child location code
	longDesc = Get the location code of the child node with the specified order index. This will also report the correct location code for child nodes that currently do not exist. If The depth of a child node would be above the maximum depth for the tree, an exception will be raised.
	param[] = {
	    type = int
	    name = orderIndex
	    desc = Order index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getChildLoc", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getChildLoc", "Context");
>>>
    return = {
        value = getImplChildLoc(impl, context, orderIndex)
        desc = Location code for the child node with the specified order index
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isLeafOrderChild
	const = true
	shortDesc = Leaf check
	longDesc = Check whether the child node with the specified valid index is a leaf node.
	param[] = {
	    type = int
	    name = orderIndex
	    desc = Order index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "isLeafOrderChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "isLeafOrderChild", "Context");
>>>
    return = {
        value = isImplLeafOrderChild(impl, context, orderIndex);
        desc = \c true if the child with the specified index is a leaf node, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isLeafValidChild
	const = true
	shortDesc = Leaf check
	longDesc = Check whether the child node with the specified valid index is a leaf node.
	param[] = {
	    type = int
	    name = index
	    desc = Index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "isLeafValidChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "isLeafOrderChild", "Context");
>>>
    return = {
        value = isImplLeafValidChild(impl, context, index);
        desc = \c true if the child with the specified index is a leaf node, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isLeaf
	const = true
	shortDesc = Leaf check
	longDesc = Check whether this node is a leaf node.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "isLeaf", "Node implementation");
>>>
    return = {
        value = !impl->valid.any()
        desc = \c true if this node is a leaf node, \c false otherwise.
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::LeafStatusID
	name = getLeafStatus
	shortDesc = Get leaf status
	longDesc = Get leaf status.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getLeafStatus", "Node implementation");
>>>
    return = {
        value = getImplLeafStatus(impl)
        desc = leaf status of the node implementation
    }
}
function.public[] = {
    spec = virtual
    type = void
    name = update
    shortDesc = Update node state
    longDesc = Update the node state according to changes in the child nodes.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "update", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "update", "Context");
updateImpl(impl, context);
>>>
}
function.public[] = {
    spec = virtual
    type = bool
    name = hasVoxelClassInfo
    shortDesc = Node data type voxel class information check
    longDesc = Check whether the node has a data type that has voxel class information attached.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "hasVoxelClassInfo", "Node implementation");
>>>
    return = {
        value = hasImplVoxelClassInfo(impl);
        desc = \c true if the node has a data type that has voxel class information attached, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::VolGfx::VoxelClassID
    name = getVoxelClass
    shortDesc = Get node voxel class
    longDesc = Get the voxel class of the node.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getVoxelClass", "Node implementation");
>>>
    return = {
        value = getImplVoxelClass(impl)
        desc = Voxel class, or VOXEL_CLASS_UNDEFINED if the node does not have voxel class data attached
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = hasVoxelClass
    shortDesc = Node voxel class check
    longDesc = Check if the node voxel class matches the specified mask.
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = mask
        desc = Voxel class mask
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "hasVoxelClass", "Node implementation");
>>>
    return = {
        value = hasImplVoxelClass(impl, mask)
        desc = \c true if the node voxel class matches the specified mask, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::VolGfx::VoxelClassID
    name = setVoxelClass
    shortDesc = Set node implementation voxel class
    longDesc = Set the voxel class mask for the node implementation. If \c enable is set to \c false, the specified voxel class mask will be unset instead of set. If the node implementation does not have any data of a compatible type attached and \c createDataType is 0, this function does nothing. Otherwise, if there is no data attached to the node, a new record of type \c createDataType will be created.
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = mask
        desc = Voxel class mask
    }
    param[] = {
        type = bool
        name = enable
        desc = enable flag
        default = true
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = createDataType
        desc = data type for new records
        default = DATA_TYPE_UNKNOWN
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "setVoxelClass", "Node implementation");
>>>
    return = {
        value = setImplVoxelClass(impl, mask, enable, createDataType)
        desc = new voxel class of the node implementation
    }
}
function.public[] = {
    spec = virtual
    type = unsigned int
    name = setVoxelClass0
    shortDesc = Set node implementation voxel class
    longDesc = Set the voxel class mask for node implementations within the hierarchy that pass the specified filter. If \c enable is set to \c false, the specified voxel class mask will be unset instead of set. If one of the node implementations does not have any data of a compatible type attached and \c createDataType is 0, it will be left unchanged by this function. Otherwise, if there is no data attached to the node, a new record of type \c createDataType will be created.
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = mask
        desc = Voxel class mask
    }
    param[] = {
        type = bool
        name = enable
        desc = enable flag
        default = true
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = process nodes recursively
        default = true
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = createDataType
        desc = data type for new records
        default = DATA_TYPE_UNKNOWN
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "setVoxelClass", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "setVoxelClass", "Context");
>>>
    return = {
        value = <<<
setImplVoxelClass(impl, context, mask, enable, filter, 
    recursive, createDataType)
>>>
        desc = number of nodes on which the voxel class was set
    }
}
function.public[] = {
    spec = virtual
    type = bool
    name = hasColorIndex
    shortDesc = Node data type color index check
    longDesc = Check whether the node has a data type that has a color index attached.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "hasColorIndex", "Node implementation");
>>>
    return = {
        value = hasImplColorIndex(impl);
        desc = \c true if the node has a data type that has a color index attached, \c false otherwise
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::VolGfx::ColorIndex
    name = getColorIndex
    shortDesc = Get node color index
    longDesc = Get the color index of the node.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getColorIndex", "Node implementation");
>>>
    return = {
        value = getImplColorIndex(impl)
        desc = Color index, or COLOR_INDEX_UNSPECIFIED if the node does not have a color index attached
    }
}
function.public[] = {
    spec = virtual
    type = Ionflux::VolGfx::ColorIndex
    name = setColorIndex
    shortDesc = Set node implementation color index
    longDesc = Set the color index for the node implementation. If the node implementation does not have any data of a compatible type attached and \c createDataType is 0, this function does nothing. Otherwise, if there is no data attached to the node, a new record of type \c createDataType will be created.
    param[] = {
        type = Ionflux::VolGfx::ColorIndex
        name = color
        desc = Color index
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = createDataType
        desc = data type for new records
        default = DATA_TYPE_UNKNOWN
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "setColorIndex", "Node implementation");
>>>
    return = {
        value = setImplColorIndex(impl, color, createDataType)
        desc = new color index of the node implementation
    }
}
function.public[] = {
    spec = virtual
    type = unsigned int
    name = setColorIndex0
    shortDesc = Set node implementation color index
    longDesc = Set the color index for node implementations within the hierarchy that pass the specified filter. If one of the node implementations does not have any data of a compatible type attached and \c createDataType is 0, it will be left unchanged by this function. Otherwise, if there is no data attached to the node, a new record of type \c createDataType will be created.
    param[] = {
        type = Ionflux::VolGfx::ColorIndex
        name = color
        desc = Color index
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = process nodes recursively
        default = true
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = createDataType
        desc = data type for new records
        default = DATA_TYPE_UNKNOWN
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "setColorIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "setColorIndex", "Context");
>>>
    return = {
        value = <<<
setImplColorIndex(impl, context, color, filter, recursive, 
    createDataType)
>>>
        desc = number of nodes on which the color index was set
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = getChildByOrderIndex
	const = true
	shortDesc = Get child node by order index
	longDesc = Get the child node with the specified order index. The caller is responsible for managing the returned object.
	param[] = {
	    type = int
	    name = orderIndex
	    desc = Order index
	}
	param[] = {
	    type = bool
	    name = autoCreate
	    desc = Create child nodes automatically if they do not exist
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getChildByOrderIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getChildByOrderIndex", "Context");
NodeImpl* ni = getImplChildByOrderIndex(impl, context, orderIndex, 
    autoCreate);
>>>
    return = {
        value = wrapImpl(ni, context)
        desc = Child node with the specified order index, or 0 if the child node does not exist
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = getChildByValidIndex
	const = true
	shortDesc = Get child by order index
	longDesc = Get the child node with the specified valid index. The caller is responsible for managing the returned object.
	param[] = {
	    type = int
	    name = index
	    desc = Valid index
	}
	impl = <<<
NodeImpl* ni = getImplChildByValidIndex(impl, index);
>>>
    return = {
        value = wrapImpl(ni, context)
        desc = Child node with the specified order index, or 0 if the child node does not exist
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = locateChild
	shortDesc = Locate child node
	longDesc = Locate the child node that contains the specified location index. If \c maxDepth not negative, the search for the node stops at the specified maximum depth. The caller is responsible for managing the returned object.
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc
	    desc = Node data
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "locateChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "locateChild", "Context");
NodeImpl* ni = locateImplChild(impl, context, loc, maxDepth);
>>>
    return = {
        value = wrapImpl(ni, context)
        desc = Leaf node containing the specified location, or 0 if no suitable node was found
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = locateChild
	shortDesc = Locate child node
	longDesc = Locate the child node that contains the specified point. If \c maxDepth is greater than zero, the search for the node stops at the specified maximum depth. The caller is responsible for managing the returned object.
	param[] = {
	    type = const Ionflux::GeoUtils::Vector3&
	    name = p
	    desc = Point
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "locateChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "locateChild", "Context");
NodeImpl* ni = locateImplChild(impl, context, p, maxDepth);
>>>
    return = {
        value = wrapImpl(ni, context)
        desc = Leaf node containing the specified location, or 0 if no suitable node was found
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = locateRegion
	shortDesc = Locate region
	longDesc = Locate the node that contains the specified region. If \c maxDepth is not negative, the search for the node stops at the specified maximum depth. The caller is responsible for managing the returned object.
	param[] = {
	    type = const Ionflux::VolGfx::Region3&
	    name = region
	    desc = Region
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "locateRegion", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "locateRegion", "Context");
NodeImpl* ni = locateImplRegion(impl, context, region, maxDepth);
>>>
    return = {
        value = wrapImpl(ni, context)
        desc = Node containing the specified region, or 0 if no suitable node was found
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = locateRegion
	shortDesc = Locate region
	longDesc = Locate the node that contains the specified region. If \c maxDepth is not negative, the search for the node stops at the specified maximum depth. The caller is responsible for managing the returned object.
	param[] = {
	    type = const Ionflux::GeoUtils::Range3&
	    name = range
	    desc = Range
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "locateRegion", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "locateRegion", "Context");
Region3 r0 = context->createRegion(range);
NodeImpl* ni = locateImplRegion(impl, context, r0, maxDepth);
>>>
    return = {
        value = wrapImpl(ni, context)
        desc = Node containing the specified region, or 0 if no suitable node was found
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = locateNode
	shortDesc = Locate node
	longDesc = Locate the node that contains the specified location index. If \c maxDepth is not negative, the search for the node stops at the specified maximum depth. This function will search the ancestors of the current node implementation upwards if the specified location is not contained in this node. The caller is responsible for managing the returned object.
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc
	    desc = Location
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "locateNode", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "locateNode", "Context");
NodeImpl* ni = locateImplNode(impl, context, loc, maxDepth);
>>>
    return = {
        value = wrapImpl(ni, context)
        desc = Node containing the specified location, or 0 if no suitable node was found
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = getDepth
	const = true
	shortDesc = Get depth
	longDesc = Get the depth of the node.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getDepth", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getDepth", "Context");
>>>
    return = {
        value = getImplDepth(impl, context);
        desc = Node depth
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = getMaxDepth
	const = true
	shortDesc = Get maximum depth
	longDesc = Get the maximum depth of the node hierarchy.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getMaxDepth", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getMaxDepth", "Context");
>>>
    return = {
        value = getImplMaxDepth(impl, context);
        desc = Maximum node depth of the hierarchy
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = insertChild
	shortDesc = Insert child node
	longDesc = Insert a child node at the specified depth that contains the specified location index. If \c depth is negative, a leaf node at the maximum depth will be inserted. If a node with the specified location code already exists at the specified depth, that node will be returned. The caller is responsible for managing the returned object.
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc
	    desc = Node data
	}
	param[] = {
	    type = int
	    name = depth
	    desc = Depth at which to create the node
	    default = DEPTH_UNSPECIFIED
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	param[] = {
	    type = bool
	    name = fillTargetDepth0
	    desc = Create a full set of child nodes at the target depth level if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "insertChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "insertChild", "Context");
NodeImpl* ni = insertImplChild(impl, context, loc, depth, fill0, 
    fillTargetDepth0);
>>>
    return = {
        value = wrapImpl(ni, context)
        desc = Node at the specified location and depth, or 0 if the location is outside the bounds of this node
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = insertChild
	shortDesc = Insert child node
	longDesc = Insert a child node at the specified depth that contains the specified point. If \c depth is negative, a leaf node at the maximum depth will be inserted. If a node with the specified location code already exists at the specified depth, that node will be returned. The caller is responsible for managing the returned object.
	param[] = {
	    type = const Ionflux::GeoUtils::Vector3&
	    name = p
	    desc = Point
	}
	param[] = {
	    type = int
	    name = depth
	    desc = Depth at which to create the node
	    default = DEPTH_UNSPECIFIED
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "insertChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "insertChild", "Context");
NodeImpl* ni = insertImplChild(impl, context, p, depth, fill0);
>>>
    return = {
        value = wrapImpl(ni, context)
        desc = Node at the specified location and depth, or 0 if the location is outside the bounds of this node
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::VolGfx::Node*
	name = insertChild
	shortDesc = Insert child node
	longDesc = Insert a child node identified by the specified node ID. If \c depth is not greater than zero, a leaf node at the maximum depth will be inserted. If a node with the specified location code already exists at the specified depth, that node will be returned. The caller is responsible for managing the returned object.
	param[] = {
	    type = const Ionflux::VolGfx::NodeID&
	    name = nodeID
	    desc = Node ID
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "insertChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "insertChild", "Context");
NodeImpl* ni = insertImplChild(impl, context, nodeID, fill0);
>>>
    return = {
        value = wrapImpl(ni, context)
        desc = Node at the specified location and depth, or 0 if the location is outside the bounds of this node
    }
}
function.public[] = {
	spec = virtual
	type = double
	name = getVoxelSize
	shortDesc = Get voxel size
	longDesc = Get the voxel size for the node.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getVoxelSize", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getVoxelSize", "Context");
>>>
    return = {
        value = getImplVoxelSize(impl, context)
        desc = Location vector
    }
}
function.public[] = {
	spec = virtual
	type = double
	name = getVoxelSizeLoc
	shortDesc = Get voxel size
	longDesc = Get the voxel size for the node in location code units.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getVoxelSizeLoc", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getVoxelSizeLoc", "Context");
>>>
    return = {
        value = getImplVoxelSizeLoc(impl, context)
        desc = Location vector
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getLocation
	const = true
	shortDesc = Get location
	longDesc = Get the location vector for the corner of the node with the lowest coordinates on each of the axes.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getLocation", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getLocation", "Context");
>>>
    return = {
        value = getImplLocation(impl, context)
        desc = Location vector
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = getNeighborLoc
	shortDesc = Get neighbor location code
	longDesc = Get the location code of the smallest size neighbor node with the specified offset, where the offset is one of {-1, 0, 1} If the neighbor node location is within the bounds of the tree, the location code is stored in \c target. If no neighbor exists within the bounds of the tree, the function returns \c false and the contents of \c target is undefined.
	param[] = {
	    type = int
	    name = offsetX
	    desc = Offset (x)
	}
	param[] = {
	    type = int
	    name = offsetY
	    desc = Offset (y)
	}
	param[] = {
	    type = int
	    name = offsetZ
	    desc = Offset (z)
	}
    param[] = {
        type = Ionflux::VolGfx::NodeLoc3&
        name = target
        desc = Where to store the neighbor location
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getNeighborLoc", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getNeighborLoc", "Context");
>>>
    return = {
        value = getImplNeighborLoc(impl, context, offsetX, offsetY, offsetZ, target)
        desc = \c true if the neighbor node exists, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getRange
	const = true
	shortDesc = Get range
	longDesc = Get the range of values contained in the node.
    param[] = {
        type = Ionflux::GeoUtils::Range3&
        name = target
        desc = Where to store the range data
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getRange", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getRange", "Context");
getImplRange(impl, context, target);
>>>
}
function.public[] = {
	spec = virtual
	type = bool
	name = getIntersectionLoc
	const = true
	shortDesc = Get line intersection location
	longDesc = Get the intersection location codes for the specified intersection data. If there is a valid intersection, the intersection location codes will be stored in \c target. Otherwise, \c target will be undefined and the function returns \c false.
    param[] = {
        type = Ionflux::GeoUtils::Line3&
        name = line
        desc = Line
    }
    param[] = {
        type = const Ionflux::GeoUtils::AAPlanePairIntersection&
        name = interData
        desc = Intersection data
    }
    param[] = {
        type = Ionflux::VolGfx::Region3&
        name = target
        desc = Where to store the intersection location codes
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getIntersection", "Context");
>>>
    return = {
        value = context->getIntersectionLoc(line, interData, target)
        desc = \c true if the intersection data is valid, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = find
	shortDesc = Find nodes
	longDesc = Find nodes by depth range. All nodes that are within the specified depth range and meet the additional requirements will be added to the \c target set. If \c target is 0, nodes will be counted but not added to the target set.
    param[] = {
        type = Ionflux::VolGfx::NodeSet*
        name = target
        desc = Where to store the nodes
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = find nodes recursively
        default = true
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "find", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "find", "Context");
unsigned int numNodes = 0;
if (target != 0)
{
    NodeImplVector v0;
    numNodes = findImpl(impl, context, &v0, filter, recursive);
    for (NodeImplVector::iterator i = v0.begin(); i != v0.end(); i++)
    {
        NodeImpl* ci = *i;
        if (ci != 0)
            target->addNode(wrapImpl(ci, context));
    }
} else
    numNodes = findImpl(impl, context, 0, filter, recursive);
>>>
    return = {
        value = numNodes
        desc = number of node implementations found
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = process
	shortDesc = Process nodes
	longDesc = Process nodes that pass the specified filter using the specified node processors. The \c preProcessor is invoked before the recursion. The \c postProcessor is invoked after the recursion. Recursive traversal stops when the \c preProcessor returns ChainableNodeProcessor::RESULT_FINISHED, or when the maximum depth as set on the \c filter is reached.
    param[] = {
        type = Ionflux::VolGfx::NodeProcessor*
        name = preProcessor
        desc = node processor (pre)
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeProcessor*
        name = postProcessor
        desc = node processor (post)
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = find nodes recursively
        default = true
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "process", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "process", "Context");
>>>
    return = {
        value = <<<
processImpl(impl, context, preProcessor, filter, 
    postProcessor, recursive)
>>>
        desc = number of node implementations processed
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::Altjira::Color*
	name = getColor
	shortDesc = Get color
	longDesc = Get a color for the node. If the optional \c colors color set is specified, the color for the node is selected from the color set according to the depth level of the node and the specified color offset. If \c colorIndex is not negative, the specified color index will be used for selecting a color from the color set. If the optional \c voxelClassColors is specified and the node has a voxel class attached to its data, the color for the node is selected according to the first entry in the vector that matches one of the voxel classes of the node. The \c colorIndex takes precedence over all other color specifications, followed by the voxel class color, the leaf color index and finally the depth based color.
    param[] = {
        type = Ionflux::Altjira::ColorSet*
        name = colors
        desc = color set
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexOffset
        desc = color index offset
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexRange
        desc = color index range
        default = 0
    }
    param[] = {
        type = int
        name = colorIndex
        desc = color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = int
        name = leafColorIndex
        desc = leaf color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassColorVector*
        name = voxelClassColors
        desc = voxel class colors
        default = 0
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getColor", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getColor", "Context");
>>>
    return = {
        value = <<<
getImplColor(impl, context, colors, colorIndexOffset, 
    colorIndexRange, colorIndex, leafColorIndex, voxelClassColors)
>>>
        desc = color, or 0 if no color is specified for the node
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getMesh
	shortDesc = Get mesh
	longDesc = Get a mesh for the node. One box is generated for each node. If the optional \c colors color set is specified, the vertex colors for each box are selected from the color set according to the depth level of the node. Boxes will be inset by the amount specified in \c boxInset, scaled by the size of the octree. The mesh for the node will be merged into the \c target mesh.
    param[] = {
        type = Ionflux::GeoUtils::Mesh&
        name = target
        desc = where to store the mesh
    }
    param[] = {
        type = double
        name = boxInset
        desc = box inset per depth level
        default = Ionflux::VolGfx::Context::DEFAULT_BOX_INSET
    }
    param[] = {
        type = Ionflux::Altjira::ColorSet*
        name = colors
        desc = vertex colors
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorOffset
        desc = color index offset
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexOffset
        desc = color index offset
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexRange
        desc = color index range
        default = 0
    }
    param[] = {
        type = int
        name = leafColorIndex
        desc = leaf color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively create meshes
        default = false
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getMesh", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getMesh", "Context");
getImplMesh(impl, context, target, boxInset, colors, 
    colorOffset, colorIndexOffset, colorIndexRange, leafColorIndex, 
    filter, recursive);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getVertexAttributes
	shortDesc = Get vertex attributes
	longDesc = Get vertex attributes for the node. Boxes will be inset by the amount specified in \c boxInset, scaled by the leaf voxel size. If the optional \c colors color set is specified, the vertex colors for the box are selected from the color set according to the depth level of the node and the specified color offset. If \c colorIndex is not negative, the specified color index will be used for selecting a color from the color set. If the optional \c voxelClassColors is specified, the colors for nodes that have a voxel class set is selected according to the first entry in the vector that matches one of the voxel classes of the node. Data will be appended to a specified vertex attributes for each target vertex attribute that is not null. If the optional \c positionOffset or \c positionScale are specified, vertex positions will be scaled or translated by these vectors.
    param[] = {
        type = Ionflux::GeoUtils::VertexAttribute*
        name = positionTarget
        desc = target for position data
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::VertexAttribute*
        name = colorTarget
        desc = target for color data
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::VertexAttribute*
        name = normalTarget
        desc = target for normal data
        default = 0
    }
	param[] = {
	    type = Ionflux::GeoUtils::NFaceTypeID
	    name = nFaceType
	    desc = Mesh N-face type
	    default = Ionflux::GeoUtils::NFace::TYPE_FACE
	}
    param[] = {
        type = double
        name = boxInset
        desc = box inset per depth level
        default = Ionflux::VolGfx::Context::DEFAULT_BOX_INSET
    }
    param[] = {
        type = Ionflux::Altjira::ColorSet*
        name = colors
        desc = vertex colors
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexOffset
        desc = color index offset
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexRange
        desc = color index range
        default = 0
    }
    param[] = {
        type = int
        name = colorIndex
        desc = color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = int
        name = leafColorIndex
        desc = leaf color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassColorVector*
        name = voxelClassColors
        desc = voxel class colors
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::Vector*
        name = positionOffset
        desc = position offset
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::Vector*
        name = positionScale
        desc = position scale
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively get vertex attributes
        default = false
    }
    param[] = {
        type = bool
        name = boundaryFacesOnly
        desc = show only boundary faces
        default = false
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getMesh", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "getMesh", "Context");
getImplVertexAttributes(impl, context, positionTarget, 
    colorTarget, normalTarget, nFaceType, boxInset, colors, 
    colorIndexOffset, colorIndexRange, colorIndex, leafColorIndex, 
    voxelClassColors, positionOffset, positionScale, filter, 
    recursive, boundaryFacesOnly);
>>>
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = getNumFaces
	shortDesc = Get number of faces
	longDesc = Get the number of faces for the node. This is the total number of faces attached to the node or, if \c recursive is set to \c true, the hierarchy of nodes starting at this node.
    param[] = {
        type = bool
        name = recursive
        desc = count faces recursively
        default = false
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "getNumFaces", "Node implementation");
>>>
    return = {
        value = getImplNumFaces(impl)
        desc = Number of faces
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = voxelizeInsertFace
	shortDesc = Insert face for voxelization
	longDesc = Insert a face into the node hierarchy for voxelization. The face will be attached to the deepest node that completely contains its voxelization.
    param[] = {
        type = Ionflux::GeoUtils::Face*
        name = face
        desc = face
    }
	param[] = {
	    type = Ionflux::VolGfx::SeparabilityID
	    name = sep
	    desc = separability
	    value = SEPARABILITY_26
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "voxelizeInsertFace", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "voxelizeInsertFace", "Context");
>>>
    return = {
        value = voxelizeImplInsertFace(impl, context, face, sep, fill0)
        desc = \c true if the face was inserted into the node hierarchy, \c false if the node hierarchy does not contain the face voxelization
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = voxelizeInsertFaces
	shortDesc = Insert faces for voxelization
	longDesc = Insert faces from the mesh into the node hierarchy for voxelization. Each face will be attached to the deepest node that completely contains its voxelization.
    param[] = {
        type = const Ionflux::GeoUtils::Mesh&
        name = mesh
        desc = mesh
    }
	param[] = {
	    type = Ionflux::VolGfx::SeparabilityID
	    name = sep
	    desc = separability
	    value = SEPARABILITY_26
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "Node::voxelizeInsertImplFaces", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "Node::voxelizeInsertImplFaces", "Context");
>>>
    return = {
        value = voxelizeImplInsertFaces(impl, context, mesh, sep, fill0)
        desc = number of faces that were inserted into the node hierarchy
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = voxelizeFaces
	shortDesc = Voxelize faces
	longDesc = Voxelize faces that are attached to the node hierarchy. The voxelization data will replace any data currently attached to the nodes (including face data). Data will be generated according to the \c target parameter, at the depth level specified via the \c targetDepth parameter. If \c targetDepth is negative, the target depth is set to the maximum depth. Faces passed in via the optional \c faces parameter will be appended to the face list for the node.
	param[] = {
	    type = Ionflux::VolGfx::NodeProcessor*
	    name = processor
	    desc = node processor
	    value = 0
	}
	param[] = {
	    type = int
	    name = targetDepth
	    desc = target depth
	    value = DEPTH_UNSPECIFIED
	}
	param[] = {
	    type = Ionflux::VolGfx::SeparabilityID
	    name = sep
	    desc = separability
	    value = SEPARABILITY_26
	}
	param[] = {
	    type = bool
	    name = fillTargetDepth
	    desc = Create a full set of child nodes at the target depth if one is missing
	    default = false
	}
	param[] = {
	    type = bool
	    name = pruneEmpty0
	    desc = Prune empty child nodes after voxelization
	    default = false
	}
	param[] = {
	    type = Ionflux::GeoUtils::FaceVector*
	    name = faces0
	    desc = additional faces
	    default = 0
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "voxelizeFaces", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "voxelizeFaces", "Context");
>>>
    return = {
        value = <<<
voxelizeImplFaces(impl, context, processor, targetDepth, sep, 
    fillTargetDepth, pruneEmpty0, faces0);
>>>
        desc = number of voxels that were set
    }
}
function.public[] = {
    spec = virtual
    type = unsigned int
    name = getMemSize
    shortDesc = Get allocated size
    longDesc = Get the allocated size in memory for this node, including the size of the allocated data.
    param[] = {
        type = bool
        name = recursive
        desc = recursively calculate allocated size
        default = false
    }
    impl = <<<
unsigned int s0 = sizeof(Node);
if (impl != 0)
    s0 += getImplMemSize(impl, recursive);
>>>
    return = {
        value = s0
        desc = allocated size of the node implementation
    }
}
function.public[] = {
    spec = virtual
    type = unsigned int
    name = getDataMemSize
    shortDesc = Get allocated size for data
    longDesc = Get the allocated size in memory for the data of this node.
    impl = <<<
if (impl == 0)
    return 0;
>>>
    return = {
        value = getDataImplMemSize(impl->data)
        desc = allocated size of the node data
    }
}
function.public[] = {
    bindings.disable = true
    spec = virtual
    type = void
    name = serializeHierarchy
    shortDesc = Serialize node hierarchy
    longDesc = Serialize the node hierarchy of which this node is the root node.
    param[] = {
        type = std::ostream&
        name = target
        desc = where to store the serialized data
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "serializeHierarchy", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "serializeHierarchy", "Context");
serializeImplHierarchy(impl, context, target);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = serializeHierarchy
    shortDesc = Serialize node hierarchy
    longDesc = Serialize the node hierarchy of which this node is the root node.
    param[] = {
        type = Ionflux::VolGfx::IOContext&
        name = ioContext
        desc = I/O context
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "serializeHierarchy", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "serializeHierarchy", "Context");
serializeImplHierarchy(impl, context, ioContext);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = deserialize
    shortDesc = Deserialize node
    longDesc = Deserialize a node from the specified offset.
    param[] = {
        type = Ionflux::VolGfx::IOContext&
        name = ioContext
        desc = I/O context
    }
    param[] = {
        type = Ionflux::ObjectBase::DataSize
        name = offset
        desc = deserialization offset
        default = Ionflux::ObjectBase::DATA_SIZE_INVALID
    }
    param[] = {
        type = Ionflux::ObjectBase::MagicSyllable
        name = magicSyllable
        desc = magic syllable to be used to indicate the node type
        default = MAGIC_SYLLABLE_NODE
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize node data
        default = true
    }
    param[] = {
        type = bool
        name = zeroChildPointer
        desc = zero the child pointer
        default = true
    }
    param[] = {
        type = bool
        name = zeroParentPointer
        desc = zero the parent pointer
        default = true
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "deserialize", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "deserialize", "Context");
deserializeImpl(impl, context, ioContext, offset, magicSyllable, 
    deserializeData, zeroChildPointer, zeroParentPointer);
>>>
}
function.public[] = {
    bindings.disable = true
    spec = virtual
    type = void
    name = deserializeHierarchy
    shortDesc = Deserialize node hierarchy
    longDesc = Deserialize a node hierarchy from the specified source. This node will become the root of the hierarchy. If \c targetNode is specified, the node ID of the root node of the deserialized hierarchy will be stored in \c targetNode.
    param[] = {
        type = std::istream&
        name = source
        desc = data source
    }
    param[] = {
        type = Ionflux::VolGfx::NodeImplHierarchyHeader*
        name = header
        desc = where to store the node implementation hierarchy header
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeID*
        name = targetNode
        desc = where to store the node ID
        default = 0
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap*
        name = poMap
        desc = where to store the pointer/offset map (serialized)
        default = 0
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap*
        name = poMapCurrent
        desc = where to store the pointer/offset map (current)
        default = 0
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize node data
        default = true
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth for deserializing child nodes
        default = DEPTH_UNSPECIFIED
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "deserializeImplHierarchy", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "deserializeImplHierarchy", "Context");
deserializeImplHierarchy(impl, context, source, header, targetNode, 
    poMap, poMapCurrent, deserializeData, maxDepth);
>>>
}
function.public[] = {
    spec = virtual
    type = void
    name = deserializeHierarchy
    shortDesc = Deserialize node hierarchy
    longDesc = Deserialize a node hierarchy from the specified source. This node will become the root of the hierarchy. If \c targetNode is specified, the node ID of the root node of the deserialized hierarchy will be stored in \c targetNode.
    param[] = {
        type = Ionflux::VolGfx::IOContext&
        name = ioContext
        desc = I/O context
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize node data
        default = true
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth for deserializing child nodes
        default = DEPTH_UNSPECIFIED
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "deserializeImplHierarchy", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "deserializeImplHierarchy", "Context");
deserializeImplHierarchy(impl, context, ioContext, deserializeData, 
    maxDepth);
>>>
}
function.public[] = {
	spec = virtual
	type = bool
	name = intersectRay
	shortDesc = Intersect ray
	longDesc = Find intersections between the node and the specified ray.
    param[] = {
        type = const Ionflux::GeoUtils::Line3&
        name = ray
        desc = ray
    }
    param[] = {
        type = Ionflux::VolGfx::NodeIntersection&
        name = target
        desc = where to store the node intersection data
    }
    param[] = {
        type = double
        name = t
        desc = tolerance
        default = DEFAULT_TOLERANCE
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "intersectRay", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "intersectRay", "Context");
>>>
    return = {
        value = intersectRayImpl(impl, context, ray, target, t)
        desc = \c true if the intersection is valid, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = intersectRay
	shortDesc = Intersect ray
	longDesc = Find intersections between the node and the specified ray. Node intersections are passed to the specified intersection processor in order of occurence along the ray. Ray traversal stops when the processor returns ChainableNodeProcessor::RESULT_FINISHED. If \c filter is specified, only intersections for nodes that pass the filter will be processed. However, if \c recursive is \c true, child nodes of nodes that do not pass the filter may still be processed.
    param[] = {
        type = const Ionflux::GeoUtils::Line3&
        name = ray
        desc = ray
    }
    param[] = {
        type = Ionflux::VolGfx::NodeIntersectionProcessor*
        name = processor
        desc = node intersection processor
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = intersect nodes recursively
        default = true
    }
    param[] = {
        type = double
        name = t
        desc = tolerance
        default = DEFAULT_TOLERANCE
    }
    param[] = {
        type = Ionflux::VolGfx::NodeIntersection*
        name = pcIntersection
        desc = precomputed node intersection
        default = 0
    }
	param[] = {
	    type = bool
	    name = fill0
	    desc = create a full set of child nodes for nodes that intersect the ray
	    default = false
	}
	param[] = {
	    type = bool
	    name = pruneEmpty0
	    desc = prune empty child nodes after processing an intersection
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "intersectRay", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "intersectRay", "Context");
>>>
    return = {
        value = <<<
intersectRayImpl(impl, context, ray, processor, filter, 
    recursive, t, pcIntersection, fill0, pruneEmpty0)
>>>
        desc = number of nodes that have intersections
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = castRayGrid
	shortDesc = Cast ray grid
	longDesc = Cast a number of rays arranged in a grid defined by the specified parameters. Rays are arranged in a two-dimensional grid, where each ray is offset from the next along each coordinate by the ray origin step specified for that coordinate. The grid has a number of rays in each coordinate according to the specified number of rays.
    param[] = {
        type = const Ionflux::GeoUtils::Vector3&
        name = rayOrigin
        desc = ray origin
    }
    param[] = {
        type = const Ionflux::GeoUtils::Vector3&
        name = rayDirection
        desc = ray direction
    }
    param[] = {
        type = const Ionflux::GeoUtils::Vector3&
        name = originStepX
        desc = ray origin step (X)
    }
    param[] = {
        type = const Ionflux::GeoUtils::Vector3&
        name = originStepY
        desc = ray origin step (Y)
    }
    param[] = {
        type = unsigned int
        name = numRaysX
        desc = number of rays in X direction
    }
    param[] = {
        type = unsigned int
        name = numRaysY
        desc = number of rays in Y direction
    }
    param[] = {
        type = Ionflux::VolGfx::NodeIntersectionProcessor*
        name = processor
        desc = node intersection processor
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = intersect nodes recursively
        default = true
    }
    param[] = {
        type = double
        name = t
        desc = tolerance
        default = DEFAULT_TOLERANCE
    }
	param[] = {
	    type = bool
	    name = fill0
	    desc = create a full set of child nodes for nodes that intersect a ray
	    default = false
	}
	param[] = {
	    type = bool
	    name = pruneEmpty0
	    desc = prune empty child nodes after processing an intersection
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "castRayGrid", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "castRayGrid", "Context");
>>>
    return = {
        value = <<<
castRayGridImpl(impl, context, rayOrigin, rayDirection, originStepX, 
    originStepY, numRaysX, numRaysY, processor, filter, recursive, t, 
    fill0, pruneEmpty0)
>>>
        desc = number of nodes that have intersections
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = castRayGrid
	shortDesc = Cast ray grid
	longDesc = Cast a number of rays arranged in a grid defined by the specified parameters. Rays are arranged in a regular grid in such a way that nodes on the specified target depth level are covered by one ray each that passes through the center of each node at that depth level. Rays in the grid are cast along the specified axis, and they are offset from the node by the specified \c planeOffset, given as a fraction of the node size at the target level.
    param[] = {
        type = const Ionflux::GeoUtils::AxisID&
        name = axis
        desc = axis to be used as the direction vector
    }
    param[] = {
        type = int
        name = targetDepth
        desc = target depth level
        default = DEPTH_UNSPECIFIED
    }
    param[] = {
        type = double
        name = planeOffset
        desc = ray plane offset
        default = DEFAULT_RAY_PLANE_OFFSET
    }
    param[] = {
        type = Ionflux::VolGfx::NodeIntersectionProcessor*
        name = processor
        desc = node intersection processor
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = intersect nodes recursively
        default = true
    }
    param[] = {
        type = double
        name = t
        desc = tolerance
        default = DEFAULT_TOLERANCE
    }
	param[] = {
	    type = bool
	    name = fill0
	    desc = create a full set of child nodes for nodes that intersect a ray
	    default = false
	}
	param[] = {
	    type = bool
	    name = pruneEmpty0
	    desc = prune empty child nodes after processing an intersection
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, 
    "castRayGrid", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, this, 
    "castRayGrid", "Context");
>>>
    return = {
        value = <<<
castRayGridImpl(impl, context, axis, targetDepth, planeOffset, 
    processor, filter, recursive, t, fill0, pruneEmpty0)
>>>
        desc = number of nodes that have intersections
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = merge
	shortDesc = Merge node hierarchies
	longDesc = Merge two node hierarchies. The merging operation will be applied to a source and a target node if they pass their respective filters (if set). A valid source child node will be taken over by the target node if either the corresponding target child note is not set or the child merge policy is \c MERGE_POLICY_TAKE_OVER_SOURCE and the source child node passes the source merge filter (if set). A valid source data entry will be taken over by the target node if either there is no data record attached to the target node or the data merge policy is \c MERGE_POLICY_TAKE_OVER_SOURCE and the source child node passes the source merge filter (if set). If \c recursive is set to true, child nodes will be merged recursively if both the target and its corresponding source child node are set and the child node merge policy is either not \c MERGE_POLICY_TAKE_OVER_SOURCE, or the source child node did not pass the filter.
    param[] = {
        type = Ionflux::VolGfx::Node&
        name = source
        desc = Source node
    }
    param[] = {
        type = Ionflux::VolGfx::MergePolicyID
        name = childPolicy
        desc = Policy for merging child nodes
        default = MERGE_POLICY_KEEP_TARGET
    }
    param[] = {
        type = Ionflux::VolGfx::MergePolicyID
        name = dataPolicy
        desc = Policy for merging data
        default = MERGE_POLICY_KEEP_TARGET
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = sourceFilter
        desc = source node filter
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = targetFilter
        desc = target node filter
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = sourceMergeFilter
        desc = source node merge filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = merge nodes recursively
        default = true
    }
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes on the target node if one is missing
	    default = false
	}
    impl = <<<
NodeImpl* sourceImpl = source.getImpl();
Ionflux::ObjectBase::nullPointerCheck(sourceImpl, 
    "merge", "Node implementation (source)");
Ionflux::ObjectBase::nullPointerCheck(impl, 
    "merge", "Node implementation (target)");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "merge", "Context");
>>>
    return = {
        value = <<<
mergeImpl(sourceImpl, impl, context, childPolicy, dataPolicy, 
    sourceFilter, targetFilter, sourceMergeFilter, recursive, fill0)
>>>
        desc = number of nodes that have been merged
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = printDebugInfo
	const = true
	shortDesc = Print debug information
	longDesc = Print debug information.
	param[] = {
	    type = bool
	    name = recursive
	    desc = List child nodes recursively
	    default = false
	}
	param[] = {
	    type = unsigned int
	    name = indentWidth
	    desc = Indentation width
	    default = Ionflux::ObjectBase::DEFAULT_INDENT_WIDTH
	}
	param[] = {
	    type = char
	    name = indentChar
	    desc = Indentation character
	    default = ' '
	}
	param[] = {
	    type = unsigned int
	    name = depth
	    desc = Depth
	    default = 0
	}
	impl = 
    return = {
        value = printImplDebugInfo(impl, context, recursive, indentWidth, indentChar, depth)
        desc = String representation
    }
}

# public member functions overridden from IFObject
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object
	impl = <<<
std::ostringstream status;
status << getImplValueString(impl, context);
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}

# Static member functions.
function.public[] = {
    spec = static
    type = std::string
    name = getDataTypeString
    shortDesc = Get node data type string
    longDesc = Get a string representation for a node data type.
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = t
        desc = Node data type
    }
    impl = <<<
if (t == DATA_TYPE_UNKNOWN)
    return "<unknown>";
else
if (t == DATA_TYPE_NULL)
    return "<null>";
else
if (t == DATA_TYPE_DENSITY)
    return "density";
else
if (t == DATA_TYPE_COLOR_RGBA)
    return "color_rgba";
else
if (t == DATA_TYPE_DISTANCE_8)
    return "distance_8";
else
if (t == DATA_TYPE_COLOR_NORMAL)
    return "color_normal";
else
if (t == DATA_TYPE_FACE_VEC)
    return "face_vec";
else
if (t == DATA_TYPE_VOXEL_CLASS)
    return "voxel_class";
else
if (t == DATA_TYPE_VOXEL_IOB)
    return "voxel_iob";
>>>
    return = {
        value = "<unknown>"
        desc = Node data type string
    }
}
function.public[] = {
    spec = static
    type = Ionflux::ObjectBase::DataSize
    name = getDataTypeNumElements
    shortDesc = Get number of elements for data type
    longDesc = Get the number of elements for array data types.
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = t
        desc = Node data type
    }
    impl = <<<
if (t == DATA_TYPE_DENSITY)
    return 1;
else
if (t == DATA_TYPE_COLOR_RGBA)
    return 4;
else
if (t == DATA_TYPE_DISTANCE_8)
    return 8;
else
if (t == DATA_TYPE_COLOR_NORMAL)
    return 7;
>>>
    return = {
        value = Ionflux::ObjectBase::DATA_SIZE_INVALID
        desc = number of elements for the data type, or DATA_SIZE_INVALID if the data type is not an array type
    }
}
function.public[] = {
    spec = static
    type = std::string
    name = getDataValueString
    shortDesc = Get node data value string
    longDesc = Get a string representation for a node data value.
    param[] = {
        type = Ionflux::VolGfx::NodeDataImpl*
        name = data
        desc = Node data implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(data, 
    "Node::getDataValueString", "Node data implementation");
NodeDataType t = data->type;
if (t == DATA_TYPE_UNKNOWN)
    return "";
else
if (t == DATA_TYPE_NULL)
    return "";
else
if (t == DATA_TYPE_DENSITY)
{
    // density value
    NodeDataValue* d0 = static_cast<NodeDataValue*>(data->data);
    Ionflux::ObjectBase::nullPointerCheck(d0, 
        "Node::getDataValueString", "Node data value");
    std::ostringstream status;
    status << *d0;
    return status.str();
} else
if (t == DATA_TYPE_FACE_VEC)
{
    // face vector
    Ionflux::GeoUtils::FaceVector* dp1 = 
        static_cast<Ionflux::GeoUtils::FaceVector*>(data->data);
    std::ostringstream status;
    for (unsigned int i = 0; i < dp1->size(); i++)
    {
        Ionflux::GeoUtils::Face* cf = (*dp1)[i];
        if (cf != 0)
        {
            if (i > 0)
                status << ", ";
            status << "[" << cf->getValueString() << "]";
        }
    }
    return status.str();
} else
if (t == DATA_TYPE_VOXEL_CLASS)
{
    // voxel class
    VoxelClassID c0;
    unpackVoxelClass(data->data, c0);
    return getVoxelClassValueString(c0);
} else
if (t == DATA_TYPE_VOXEL_IOB)
{
    // voxel inside/outside/boundary
    VoxelDataIOB* dp1 = static_cast<VoxelDataIOB*>(data->data);
    return getVoxelDataIOBValueString(*dp1);
} else
if ((t == DATA_TYPE_COLOR_RGBA) 
    || (t == DATA_TYPE_DISTANCE_8) 
    || (t == DATA_TYPE_COLOR_NORMAL))
{
    // array data types
    Ionflux::ObjectBase::DataSize n0 = getDataTypeNumElements(t);
    if (n0 != Ionflux::ObjectBase::DATA_SIZE_INVALID)
    {
        NodeDataValue* d0 = static_cast<NodeDataValue*>(data->data);
        Ionflux::ObjectBase::nullPointerCheck(d0, 
            "Node::getDataValueString", "Node data value");
        std::ostringstream status;
        for (Ionflux::ObjectBase::DataSize i = 0; i < n0; i++)
        {
            if (i > 0)
                status << ", ";
            status << d0[i];
        }
        return status.str();
    }
}
>>>
    return = {
        value = "<unknown>"
        desc = Node data type string
    }
}
function.public[] = {
    spec = static
    type = Ionflux::VolGfx::NodeImpl*
    name = createImpl
    shortDesc = Create node implementation
    longDesc = Create a new node implementation. The caller is responsible for managing the node implementation.
    impl = <<<
NodeImpl* newImpl = Ionflux::ObjectBase::create<NodeImpl>(
    "Node::createImpl", "node implementation");
newImpl->refCount = 0;
newImpl->loc.x = 0;
newImpl->loc.y = 0;
newImpl->loc.z = 0;
newImpl->valid = 0;
newImpl->leaf = 0;
newImpl->parent = 0;
newImpl->data = 0;
newImpl->child = 0;
>>>
    return = {
        value = newImpl
        desc = New node implementation
    }
}
function.public[] = {
    spec = static
    type = void
    name = copyImpl
    shortDesc = Copy node implementation
    longDesc = Create a new node implementation that is a copy of the specified node implementation. If \c takeover is set to \c true, the target node implementation will take over the child nodes and data from the source node implementation. In this case, the entries in the source node related to the child nodes and data are cleared. Otherwise, the child node and data entries will not be copied to the target node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl&
        name = source
        desc = Source node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::NodeImpl&
        name = target
        desc = Target node implementation
    }
    param[] = {
        type = bool
        name = takeover
        desc = Take over the data of the source node
        default = false
    }
    impl = <<<
target.loc.x = source.loc.x;
target.loc.y = source.loc.y;
target.loc.z = source.loc.z;
if (!takeover)
{
    target.valid = 0;
    target.leaf = 0;
    target.data = 0;
    target.child = 0;
} else
{
    target.valid = source.valid;
    target.leaf = source.leaf;
    target.data = source.data;
    target.child = source.child;
    source.valid = 0;
    source.leaf = 0;
    source.data = 0;
    source.child = 0;
}
>>>
}
function.public[] = {
    spec = static
    type = Ionflux::ObjectBase::UInt16
    name = refImpl
    shortDesc = Reference node implementation
    longDesc = Reference a node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::refImpl", "Node implementation");
if (otherImpl->refCount < MAX_REF_COUNT)
    otherImpl->refCount++;
else
    throw IFVGError("[Node::refImpl] Reference count overflow.");
>>>
    return = {
        value = otherImpl->refCount
        desc = New reference count of the node implementation
    }
}
function.public[] = {
    spec = static
    type = void
    name = clearDataImpl
    shortDesc = Clear node data implementation
    longDesc = Clear the data of the specified node data implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeDataImpl*
        name = dataImpl
        desc = Node data implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(dataImpl, 
    "Node::clearDataImpl", "Node data implementation");
NodeDataImpl* dp = dataImpl;
if (dp->type == DATA_TYPE_DENSITY)
{
    // density value
    NodeDataValue* dp1 = 
        static_cast<NodeDataValue*>(dp->data);
    delete dp1;
} else 
if (dp->type == DATA_TYPE_FACE_VEC)
{
    // face vector
    Ionflux::GeoUtils::FaceVector* dp1 = 
        static_cast<Ionflux::GeoUtils::FaceVector*>(dp->data);
    delete dp1;
} else 
if (dp->type == DATA_TYPE_VOXEL_CLASS)
{
    // voxel class
    // Nothing to be done.
} else 
if (dp->type == DATA_TYPE_VOXEL_IOB)
{
    // voxel inside/outside/boundary
    VoxelDataIOB* dp1 = static_cast<VoxelDataIOB*>(dp->data);
    delete dp1;
} else 
if ((dp->type == DATA_TYPE_COLOR_RGBA) 
    || (dp->type == DATA_TYPE_DISTANCE_8) 
    || (dp->type == DATA_TYPE_COLOR_NORMAL))
{
    // array types
    NodeDataValue* dp1 = 
        static_cast<NodeDataValue*>(dp->data);
    delete[] dp1;
} else 
if (dp->type != DATA_TYPE_NULL)
{
    throw IFVGError("[Node::clearDataImpl] "
        "Cannot delete data of unknown type");
}
dp->data = 0;
dp->type = DATA_TYPE_NULL;
>>>
}
function.public[] = {
    spec = static
    type = void
    name = clearImpl
    shortDesc = Clear node implementation
    longDesc = Clear the child nodes and data of the specified node implementation. This assumes that there are no references held on any nodes that are part of the hierarchy starting from \c otherImpl. If this is not the case, an exception will be thrown.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = bool
        name = recursive
        desc = Recursively clear data
        default = true
    }
    param[] = {
        type = bool
        name = clearData
        desc = Clear data
        default = true
    }
    param[] = {
        type = bool
        name = clearChildNodes
        desc = Clear child nodes
        default = true
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::clearImpl", "Node implementation");
if (clearChildNodes && otherImpl->valid.any())
{
    NodeImpl* cp = otherImpl->child;
    if (cp != 0)
    {
        // Delete child nodes.
        int numChildNodes = otherImpl->valid.count();
        for (int i = 0; i < numChildNodes; i++)
        {
            NodeImpl& cn = cp[i];
            if (cn.refCount > 1)
            {
                std::ostringstream status;
                status << "[Node::unrefImpl] Cannot delete "
                    "child node because it is still referenced "
                    "(i = " << i << ").";
                throw IFVGError(status.str());
            } else
            if (cn.refCount == 0)
            {
                throw IFVGError("[Node::clearImpl] Attempt to remove "
                    "reference from node implementation with zero "
                    "references.");
            }
            cn.refCount = 0;
            cn.parent = 0;
            if (recursive)
            {
                /* NOTE: Data has to be cleared as well when recursively 
                         deleting nodes. */
                clearImpl(&cn, true, true, clearChildNodes);
            }
        }
        delete[] cp;
        otherImpl->child = 0;
    }
    otherImpl->valid = 0;
    otherImpl->leaf = 0;
}
if (clearData && (otherImpl->data != 0))
{
    // Delete data node.
    NodeDataImpl* dp = otherImpl->data;
    clearDataImpl(dp);
    delete dp;
    otherImpl->data = 0;
}
>>>
}
function.public[] = {
    spec = static
    type = Ionflux::ObjectBase::UInt16
    name = unrefImpl
    shortDesc = Unreference node implementation
    longDesc = Unreference a node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::refImpl", "Node implementation");
if (otherImpl->refCount > 0)
{
    otherImpl->refCount--;
    if (otherImpl->refCount == 0)
    {
        clearImpl(otherImpl, true, true, true);
        delete otherImpl;
    }
    return 0;
} else
{
    throw IFVGError("[Node::unrefImpl] Attempt to remove "
        "reference from node implementation with zero "
        "references.");
}
>>>
    return = {
        value = otherImpl->refCount
        desc = New reference count of the node implementation
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::Node*
	name = wrapImpl
	shortDesc = Wrap node implementation
	longDesc = Wrap a node implementation in a new node object. If the node implementation is 0, no node object will be created. The caller is responsible for managing the returned object.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	impl = <<<
Node* result = 0;
if (otherImpl != 0)
    result = Node::create(context, otherImpl);
>>>
    return = {
        value = result
        desc = New node object, or 0 if the node implementation is 0
    }
}
function.public[] = {
    spec = static
    type = void
    name = setImplParent
    shortDesc = Set node implementation parent node
    longDesc = Set the parent node for all child nodes of the node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::setImplParent", "Node implementation");
if (otherImpl->valid.any())
{
    NodeImpl* cp = otherImpl->child;
    if (cp != 0)
    {
        // Set parent for child nodes.
        int numChildNodes = otherImpl->valid.count();
        for (int i = 0; i < numChildNodes; i++)
        {
            NodeImpl& cn = cp[i];
            cn.parent = otherImpl;
        }
    }
}
>>>
}
function.public[] = {
    spec = static
    type = void
    name = updateImpl
    shortDesc = Update node implementation state
    longDesc = Update the node implementation state according to changes in the child nodes.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::updateImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::updateImpl", "Context");
// Update leaf node flags.
otherImpl->leaf = 0;
NodeImpl* cp = otherImpl->child;
if (cp != 0)
{
    if (otherImpl->valid.any())
    {
        int n0 = context->getMaxNumLeafChildNodesPerNode();
        int k = 0;
        for (int i = 0; i < n0; i++)
        {
            if (otherImpl->valid.test(i))
            {
                NodeImpl& cn = cp[k];
                if (!cn.valid.any())
                    otherImpl->leaf.set(i, true);
                k++;
            }
        }
    }
} else
    otherImpl->valid = 0;
>>>
}
function.public[] = {
    spec = static
    type = Ionflux::VolGfx::NodeDataImpl*
    name = createDataImpl
    shortDesc = Create node data implementation
    longDesc = Create a new node data implementation. The caller is responsible for managing the node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = t
        desc = Node data type
    }
    param[] = {
        type = const Ionflux::ObjectBase::DoubleVector*
        name = newData
        desc = Node data vector
        default = 0
    }
    impl = <<<
Ionflux::VolGfx::NodeDataImpl* newImpl = 
    Ionflux::ObjectBase::create<NodeDataImpl>("Node::createDataImpl", 
        "node data implementation");
newImpl->type = t;
if (t == DATA_TYPE_NULL)
    newImpl->data = 0;
else
if (t == DATA_TYPE_DENSITY)
{
    // density value
    NodeDataValue* dp = Ionflux::ObjectBase::create<NodeDataValue>(
        "Node::createDataImpl", "Node density data");
    if ((newData != 0) 
        && (newData->size() > 0))
    {
        *dp = (*newData)[0];
    } else
        *dp = DENSITY_EMPTY;
    newImpl->data = dp;
} else
if (t == DATA_TYPE_FACE_VEC)
{
    // face vector
    Ionflux::GeoUtils::FaceVector* dp = 
        new Ionflux::GeoUtils::FaceVector;
    if (dp == 0)
    {
        throw IFVGError("[Node::createDataImpl] "
            "Could not allocate data.");
    }
    newImpl->data = dp;
} else
if (t == DATA_TYPE_VOXEL_CLASS)
{
    // voxel class
    packVoxelClass(VOXEL_CLASS_UNDEFINED, newImpl->data);
} else
if (t == DATA_TYPE_VOXEL_IOB)
{
    // voxel inside/outside/boundary
    VoxelDataIOB* dp = Ionflux::ObjectBase::create<VoxelDataIOB>(
        "Node::createDataImpl", "Voxel data");
    *dp = createVoxelDataIOB();
    newImpl->data = dp;
} else
if ((t == DATA_TYPE_COLOR_RGBA) 
    || (t == DATA_TYPE_DISTANCE_8) 
    || (t == DATA_TYPE_COLOR_NORMAL))
{
    // array types
    Ionflux::ObjectBase::DataSize n0 = getDataTypeNumElements(t);
    if (n0 != Ionflux::ObjectBase::DATA_SIZE_INVALID)
    {
        // allocate data array
        NodeDataValue* dp = new NodeDataValue[n0];
        if (dp == 0)
        {
            throw IFVGError("[Node::createDataImpl] "
                "Could not allocate data.");
        }
        for (Ionflux::ObjectBase::DataSize i = 0; i < n0; i++)
        {
            NodeDataValue& v0 = dp[i];
            if ((newData != 0) 
                && (newData->size() > i))
            {
                v0 = (*newData)[i];
            } else
                v0 = 0.;
        }
        newImpl->data = dp;
    } else
    {
        std::ostringstream status;
        status << "[Node::createDataImpl] Invalid node data type: " << t;
        throw IFVGError(status.str());
    }
}
>>>
    return = {
        value = newImpl
        desc = New node data implementation
    }
}
function.public[] = {
    spec = static
    type = unsigned int
    name = getDataImplMemSize
    shortDesc = Get node data implementation allocated size
    longDesc = Get the allocated size in memory for a node data implementation, including the size of the allocated data.
    param[] = {
        type = Ionflux::VolGfx::NodeDataImpl*
        name = dataImpl
        desc = Node data implementation
    }
    impl = <<<
if (dataImpl == 0)
    return 0;
unsigned int s0 = sizeof(NodeDataImpl);
NodeDataType t0 = dataImpl->type;
if (t0 == DATA_TYPE_DENSITY)
{
    // density value
    s0 += 1;
} else
if (t0 == DATA_TYPE_FACE_VEC)
{
    // face vector
    Ionflux::GeoUtils::FaceVector* dp = 
        static_cast<Ionflux::GeoUtils::FaceVector*>(dataImpl->data);
    if (dp != 0)
    {
        s0 += sizeof(Ionflux::GeoUtils::FaceVector);
        s0 += (dp->size() * sizeof(Ionflux::GeoUtils::Face*));
    }
} else
if (t0 == DATA_TYPE_VOXEL_IOB)
{
    // voxel inside/outside/boundary
    VoxelDataIOB* dp = static_cast<VoxelDataIOB*>(dataImpl->data);
    if (dp != 0)
        s0 += sizeof(VoxelDataIOB);
} else
if (t0 == DATA_TYPE_VOXEL_CLASS)
{
    // voxel class
    // Nothing to be done.
} else
if ((t0 == DATA_TYPE_COLOR_RGBA) 
    || (t0 == DATA_TYPE_DISTANCE_8) 
    || (t0 == DATA_TYPE_COLOR_NORMAL))
{
    // array types
    unsigned int n0 = getDataTypeNumElements(t0);
    s0 += (n0 * sizeof(NodeDataValue));
}
>>>
    return = {
        value = s0
        desc = allocated size of the node data
    }
}
function.public[] = {
    spec = static
    type = void
    name = setDataImplColorNormal
    shortDesc = Set node data (color/normal)
    longDesc = Set the color/normal data for the specified node data implementation to the specified values.
    param[] = {
        type = Ionflux::VolGfx::NodeDataImpl*
        name = dataImpl
        desc = Node data implementation
    }
    param[] = {
        type = const Ionflux::Altjira::Color&
        name = color
        desc = color
    }
    param[] = {
        type = const Ionflux::GeoUtils::Vector3&
        name = normal
        desc = normal vector
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(dataImpl, 
    "Node::setDataImplColorNormal", "Node data implementation");
if (dataImpl->type != DATA_TYPE_COLOR_NORMAL)
{
    std::ostringstream status;
    status << "[Node::setDataImplColorNormal] "
        "Node data implementation has incorrect type (type = '" 
        << getDataTypeString(dataImpl->type) << "').";
    throw IFVGError(status.str());
}
NodeDataValue* dp = Ionflux::ObjectBase::nullPointerCheck(
    static_cast<NodeDataValue*>(dataImpl->data), 
    "Node::setDataImplColorNormal", "Data pointer");
for (unsigned int i = 0; i < 7; i++)
{
    if (i == 0)
        dp[i] = color.getRed();
    else 
    if (i == 1)
        dp[i] = color.getGreen();
    else 
    if (i == 2)
        dp[i] = color.getBlue();
    else 
    if (i == 3)
        dp[i] = color.getAlpha();
    else 
    if (i > 3)
        dp[i] = normal[i - 3];
}
>>>
}
function.public[] = {
    spec = static
    type = Ionflux::VolGfx::NodeDataType
    name = getImplDataType
    shortDesc = Get node implementation data type
    longDesc = Get the data type of the node implementation data.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplDataType", "Node data implementation");
NodeDataImpl* d0 = otherImpl->data;
if (d0 != 0)
    return d0->type;
>>>
    return = {
        value = DATA_TYPE_NULL
        desc = Node data type, or DATA_TYPE_NULL if the node does not have any data
    }
}
function.public[] = {
    spec = static
    type = bool
    name = hasImplDataType
    shortDesc = Check node implementation data type
    longDesc = Check if the node implementation has a data record of the specified type.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = dataType
        desc = data type
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::hasImplDataType", "Node data implementation");
NodeDataType t0 = getImplDataType(otherImpl);
if (((dataType == DATA_TYPE_ANY_NOT_NULL) 
        && (t0 != DATA_TYPE_NULL))
    || (t0 == dataType))
    return true;
>>>
    return = {
        value = false
        desc = \c true if the node implementation has a data record of the specified type, \c false otherwise
    }
}
function.public[] = {
    spec = static
    type = Ionflux::VolGfx::NodeDataImpl*
    name = getImplData
    shortDesc = Get node implementation data. This ensures that the data that is returned exists and has the specified type. If the node data has a different type, it will be cleared and a new data record of the specified type will be created and attached to the node implementation.
    longDesc = 
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = dataType
        desc = data type
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplData", "Node data implementation");
NodeDataImpl* d0 = otherImpl->data;
if ((d0 != 0)
    && (d0->type != dataType))
{
    // clear existing data of wrong type
    clearImpl(otherImpl, false, true, false);
    d0 = otherImpl->data;
}
if (d0 == 0)
{
    // create new data of specified type
    d0 = createDataImpl(dataType);
    otherImpl->data = d0;
}
>>>
    return = {
        value = otherImpl->data
        desc = Node data implementation of specified type
    }
}
function.public[] = {
    spec = static
    type = bool
    name = dataTypeHasVoxelClassInfo
    shortDesc = Node data type voxel class information check
    longDesc = Check whether the specified node data type has voxel class information attached.
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = dataType
        desc = Node data type
    }
    impl = <<<
if ((dataType == DATA_TYPE_VOXEL_CLASS) 
    || (dataType == DATA_TYPE_VOXEL_IOB))
    return true;
>>>
    return = {
        value = false
        desc = \c true if the specified node data type has voxel class information attached, \c false otherwise
    }
}
function.public[] = {
    spec = static
    type = bool
    name = hasImplVoxelClassInfo
    shortDesc = Node data type voxel class information check
    longDesc = Check whether the specified node implementation has a data type that has voxel class information attached.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::hasImplVoxelClassInfo", "Node implementation");
NodeDataType t0 = getImplDataType(otherImpl);
>>>
    return = {
        value = dataTypeHasVoxelClassInfo(t0);
        desc = \c true if the specified node implementation has a data type that has voxel class information attached, \c false otherwise
    }
}
function.public[] = {
    spec = static
    type = Ionflux::VolGfx::VoxelClassID
    name = getImplVoxelClass
    shortDesc = Get node implementation voxel class
    longDesc = Get the voxel class of the node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplVoxelClass", "Node implementation");
VoxelClassID c0 = VOXEL_CLASS_UNDEFINED;
NodeDataType t0 = getImplDataType(otherImpl);
if (t0 == DATA_TYPE_NULL)
    return c0;
NodeDataImpl* dp = Ionflux::ObjectBase::nullPointerCheck(
    otherImpl->data, "Node::getImplVoxelClass", "Node data");
if (t0 == DATA_TYPE_VOXEL_CLASS)
{
    // voxel class
    unpackVoxelClass(dp->data, c0);
} else
if (t0 == DATA_TYPE_VOXEL_IOB)
{
    // voxel inside/outside/boundary
    VoxelDataIOB* d0 = static_cast<VoxelDataIOB*>(dp->data);
    if (d0 != 0)
        c0 = d0->voxelClass;
}
>>>
    return = {
        value = c0
        desc = Voxel class, or VOXEL_CLASS_UNDEFINED if the node does not have voxel class data attached
    }
}
function.public[] = {
    spec = static
    type = bool
    name = hasImplVoxelClass
    shortDesc = Node implementation voxel class check
    longDesc = Check if the node implementation voxel class matches the specified mask.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = mask
        desc = Voxel class mask
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::hasImplVoxelClass", "Node implementation");
VoxelClassID c0 = getImplVoxelClass(otherImpl);
if (Ionflux::VolGfx::checkVoxelClass(c0, mask))
    return true;
>>>
    return = {
        value = false
        desc = \c true if the node implementation voxel class matches the specified mask, \c false otherwise
    }
}
function.public[] = {
    spec = static
    type = Ionflux::VolGfx::VoxelClassID
    name = setImplVoxelClass
    shortDesc = Set node implementation voxel class
    longDesc = Set the voxel class mask for the node implementation. If \c enable is set to \c false, the specified voxel class mask will be unset instead of set. If the node implementation does not have any data of a compatible type attached and \c createDataType is 0, this function does nothing. Otherwise, if there is no data attached to the node, a new record of type \c createDataType will be created.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = mask
        desc = Voxel class mask
    }
    param[] = {
        type = bool
        name = enable
        desc = enable flag
        default = true
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = createDataType
        desc = data type for new records
        default = DATA_TYPE_UNKNOWN
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::setImplVoxelClass", "Node implementation");
VoxelClassID c0 = VOXEL_CLASS_UNDEFINED;
NodeDataType t0 = getImplDataType(otherImpl);
NodeDataImpl* dp = 0;
if (t0 == DATA_TYPE_NULL)
{
    // no data attached
    if (createDataType == DATA_TYPE_UNKNOWN)
        return c0;
    if (!dataTypeHasVoxelClassInfo(createDataType))
    {
        std::ostringstream status;
        status << "Data type to be created does not support "
            "voxel class info (" 
            << getDataTypeString(createDataType) << " (" 
            << static_cast<int>(createDataType) << ")).";
        throw IFVGError(Ionflux::ObjectBase::getErrorString(
            status.str(), "Node::setImplVoxelClass"));
    }
    dp = getImplData(otherImpl, createDataType);
    t0 = createDataType;
} else
{
    dp = Ionflux::ObjectBase::nullPointerCheck(
        otherImpl->data, "Node::getImplVoxelClass", "Node data");
}
if (t0 == DATA_TYPE_VOXEL_CLASS)
{
    // voxel class
    unpackVoxelClass(dp->data, c0);
    Ionflux::VolGfx::setVoxelClass(mask, c0, enable);
    packVoxelClass(c0, dp->data);
} else
if (t0 == DATA_TYPE_VOXEL_IOB)
{
    // voxel inside/outside/boundary
    VoxelDataIOB* d0 = static_cast<VoxelDataIOB*>(dp->data);
    if (d0 != 0)
    {
        Ionflux::VolGfx::setVoxelClass(mask, d0->voxelClass, enable);
        c0 = d0->voxelClass;
    }
}
>>>
    return = {
        value = c0
        desc = new voxel class of the node implementation
    }
}
function.public[] = {
    spec = static
    type = unsigned int
    name = setImplVoxelClass
    shortDesc = Set node implementation voxel class
    longDesc = Set the voxel class mask for node implementations within the hierarchy that pass the specified filter. If \c enable is set to \c false, the specified voxel class mask will be unset instead of set. If one of the node implementations does not have any data of a compatible type attached and \c createDataType is 0, it will be left unchanged by this function. Otherwise, if there is no data attached to the node, a new record of type \c createDataType will be created.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassID
        name = mask
        desc = Voxel class mask
    }
    param[] = {
        type = bool
        name = enable
        desc = enable flag
        default = true
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = process nodes recursively
        default = true
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = createDataType
        desc = data type for new records
        default = DATA_TYPE_UNKNOWN
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::setImplVoxelClass", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::setImplVoxelClass", "Context");
if (filter != 0)
{
    int maxDepth = filter->getMaxDepth();
    int depth = getImplDepth(otherImpl, context);
    if (!context->checkDepthRange(depth, 0, maxDepth))
        return 0;
}
unsigned int numNodes = 0;
if ((filter == 0) 
    || NodeProcessor::checkFlags(
        filter->process(otherImpl), NodeFilter::RESULT_PASS))
{
    // set voxel class on this node implementation
    setImplVoxelClass(otherImpl, mask, enable, createDataType);
    numNodes++;
}
if (!recursive)
    return numNodes;
// set voxel class recursively
int n0 = getImplNumChildNodes(otherImpl);
for (int i = 0; i < n0; i++)
{
    NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
        getImplChildByValidIndex(otherImpl, i), 
        "Node::setImplVoxelClass", "Child node implementation");
    numNodes += setImplVoxelClass(cn0, context, mask, enable, 
        filter, true, createDataType);
}
>>>
    return = {
        value = numNodes
        desc = number of nodes on which the voxel class was set
    }
}
function.public[] = {
    spec = static
    type = bool
    name = dataTypeHasColorIndex
    shortDesc = Node data type color index check
    longDesc = Check whether the specified node data type has a color index attached.
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = dataType
        desc = Node data type
    }
    impl = <<<
if (dataType == DATA_TYPE_VOXEL_IOB)
    return true;
>>>
    return = {
        value = false
        desc = \c true if the specified node data type has voxel class information attached, \c false otherwise
    }
}
function.public[] = {
    spec = static
    type = bool
    name = hasImplColorIndex
    shortDesc = Node data type color index check
    longDesc = Check whether the specified node implementation has a data type that has a color index attached.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::hasImplColorIndex", "Node implementation");
NodeDataType t0 = getImplDataType(otherImpl);
>>>
    return = {
        value = dataTypeHasColorIndex(t0);
        desc = \c true if the specified node implementation has a data type that has a color index attached, \c false otherwise
    }
}
function.public[] = {
    spec = static
    type = Ionflux::VolGfx::ColorIndex
    name = getImplColorIndex
    shortDesc = Get node implementation color index
    longDesc = Get the color index of the node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplColorIndex", "Node implementation");
ColorIndex c0 = COLOR_INDEX_UNSPECIFIED;
NodeDataType t0 = getImplDataType(otherImpl);
if (t0 == DATA_TYPE_NULL)
    return c0;
NodeDataImpl* dp = Ionflux::ObjectBase::nullPointerCheck(
    otherImpl->data, "Node::getImplColorIndex", "Node data");
if (t0 == DATA_TYPE_VOXEL_IOB)
{
    // voxel inside/outside/boundary
    VoxelDataIOB* d0 = static_cast<VoxelDataIOB*>(dp->data);
    if (d0 != 0)
        c0 = d0->color;
}
>>>
    return = {
        value = c0
        desc = Color index, or COLOR_INDEX_UNSPECIFIED if the node does not have color index data attached
    }
}
function.public[] = {
    spec = static
    type = Ionflux::VolGfx::ColorIndex
    name = setImplColorIndex
    shortDesc = Set node implementation color index
    longDesc = Set the color index for the node implementation. If the node implementation does not have any data of a compatible type attached and \c createDataType is 0, this function does nothing. Otherwise, if there is no data attached to the node, a new record of type \c createDataType will be created.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::ColorIndex
        name = color
        desc = Color index
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = createDataType
        desc = data type for new records
        default = DATA_TYPE_UNKNOWN
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::setImplColorIndex", "Node implementation");
ColorIndex c0 = COLOR_INDEX_UNSPECIFIED;
NodeDataType t0 = getImplDataType(otherImpl);
NodeDataImpl* dp = 0;
if (t0 == DATA_TYPE_NULL)
{
    // no data attached
    if (createDataType == DATA_TYPE_UNKNOWN)
        return c0;
    if (!dataTypeHasColorIndex(createDataType))
    {
        std::ostringstream status;
        status << "Data type to be created does not support "
            "color index (" 
            << getDataTypeString(createDataType) << " (" 
            << static_cast<int>(createDataType) << ")).";
        throw IFVGError(Ionflux::ObjectBase::getErrorString(
            status.str(), "Node::setImplColorIndex"));
    }
    dp = getImplData(otherImpl, createDataType);
    t0 = createDataType;
} else
{
    dp = Ionflux::ObjectBase::nullPointerCheck(
        otherImpl->data, "Node::setImplColorIndex", "Node data");
}
if (t0 == DATA_TYPE_VOXEL_IOB)
{
    // voxel inside/outside/boundary
    VoxelDataIOB* d0 = static_cast<VoxelDataIOB*>(dp->data);
    if (d0 != 0)
    {
        d0->color = color;
        c0 = d0->color;
    }
}
>>>
    return = {
        value = c0
        desc = new color of the node implementation
    }
}
function.public[] = {
    spec = static
    type = unsigned int
    name = setImplColorIndex
    shortDesc = Set node implementation color index
    longDesc = Set the color index for node implementations within the hierarchy that pass the specified filter. If one of the node implementations does not have any data of a compatible type attached and \c createDataType is 0, it will be left unchanged by this function. Otherwise, if there is no data attached to the node, a new record of type \c createDataType will be created.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::ColorIndex
        name = color
        desc = Color index
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = process nodes recursively
        default = true
    }
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = createDataType
        desc = data type for new records
        default = DATA_TYPE_UNKNOWN
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::setImplColorIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::setImplColorIndex", "Context");
if (filter != 0)
{
    int maxDepth = filter->getMaxDepth();
    int depth = getImplDepth(otherImpl, context);
    if (!context->checkDepthRange(depth, 0, maxDepth))
        return 0;
}
unsigned int numNodes = 0;
if ((filter == 0) 
    || NodeProcessor::checkFlags(
        filter->process(otherImpl), NodeFilter::RESULT_PASS))
{
    // set color index on this node implementation
    setImplColorIndex(otherImpl, color, createDataType);
    numNodes++;
}
if (!recursive)
    return numNodes;
// set color index recursively
int n0 = getImplNumChildNodes(otherImpl);
for (int i = 0; i < n0; i++)
{
    NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
        getImplChildByValidIndex(otherImpl, i), 
        "Node::setImplColorIndex", "Child node implementation");
    numNodes += setImplColorIndex(cn0, context, color, filter, 
        true, createDataType);
}
>>>
    return = {
        value = numNodes
        desc = number of nodes on which the color index was set
    }
}
function.public[] = {
    spec = static
    type = Ionflux::VolGfx::FaceMaskInt
    name = getImplBoundaryFaces
    shortDesc = Get node implementation boundary faces
    longDesc = Get the boundary faces of the node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplBoundaryFaces", "Node implementation");
NodeDataType t0 = getImplDataType(otherImpl);
if (t0 == DATA_TYPE_NULL)
    return FACE_UNDEFINED;
NodeDataImpl* dp = Ionflux::ObjectBase::nullPointerCheck(
    otherImpl->data, "Node::getImplBoundaryFaces", "Node data");
FaceMaskInt fm0 = FACE_UNDEFINED;
if (t0 == DATA_TYPE_VOXEL_IOB)
{
    // voxel inside/outside/boundary
    VoxelDataIOB* d0 = static_cast<VoxelDataIOB*>(dp->data);
    if (d0 != 0)
        fm0 = d0->boundaryFaces;
}
>>>
    return = {
        value = fm0
        desc = boundary face mask, or DACE_UNDEFINED if the node does not have boundary face data attached
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeImpl*
	name = getImplParent
	shortDesc = Get parent node implementation
	longDesc = Get the parent node implementation. The caller is responsible for managing the returned object.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::isImplParent", "Node implementation");
>>>
    return = {
        value = otherImpl->parent
        desc = Parent node implementation, or 0 if the parent node does not exist
    }
}
function.public[] = {
	spec = static
	type = bool
	name = isImplLeaf
	shortDesc = Leaf check
	longDesc = Check whether the node implementation is a leaf node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::isImplLeaf", "Node implementation");
>>>
    return = {
        value = !otherImpl->valid.any()
        desc = \c true if the node implementation is a leaf node, \c false otherwise
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::LeafStatusID
	name = getImplLeafStatus
	shortDesc = Get leaf status
	longDesc = Get leaf status.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplLeafStatus", "Node implementation");
if (isImplLeaf(otherImpl))
    return NODE_LEAF;
>>>
    return = {
        value = NODE_NON_LEAF
        desc = leaf status of the node implementation
    }
}
function.public[] = {
	spec = static
	type = bool
	name = isImplLeafOrderChild
	shortDesc = Leaf check
	longDesc = Check whether the child node with the specified valid index is a leaf node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = int
	    name = orderIndex
	    desc = Order index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::isImplLeafOrderChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::isImplLeafOrderChild", "Context");
if (orderIndex < 0)
{
    std::ostringstream status;
    status << "[Node::isImplLeafOrderChild] "
        "Invalid child order index (" << orderIndex << ").";
    throw IFVGError(status.str());
}
int n0 = context->getMaxNumLeafChildNodesPerNode();
if (orderIndex >= n0)
{
    std::ostringstream status;
    status << "[Node::isImplLeafOrderChild] "
        "Child node index out of range: " << orderIndex;
    throw IFVGError(status.str());
}
>>>
    return = {
        value = otherImpl->leaf.test(orderIndex)
        desc = \c true if the child with the specified index is a leaf node, \c false otherwise
    }
}
function.public[] = {
	spec = static
	type = bool
	name = isImplLeafValidChild
	shortDesc = Leaf check
	longDesc = Check whether the child node with the specified valid index is a leaf node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = int
	    name = index
	    desc = Index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::isImplLeafValidChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::isImplLeafValidChild", "Context");
int numChildNodes = getImplNumChildNodes(otherImpl);
if (index > numChildNodes)
{
    std::ostringstream status;
    status << "[Node::isImplLeafValidChild] "
        "Child node index out of range: " << index;
    throw IFVGError(status.str());
}
int oi = getImplChildOrderIndex(otherImpl, context, index);
>>>
    return = {
        value = isImplLeafOrderChild(otherImpl, context, oi);
        desc = \c true if the child with the specified index is a leaf node, \c false otherwise
    }
}
function.public[] = {
	spec = static
	type = int
	name = getImplDepth
	shortDesc = Get depth
	longDesc = Get the depth of the node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplDepth", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplDepth", "Context");
LocInt maxNumLevels = context->getMaxNumLevels();
if (otherImpl->parent == 0)
    return 0;
int depth = 0;
NodeImpl* ci = otherImpl;
while ((ci->parent != 0) 
    && (depth < (maxNumLevels - 1)))
{
    depth++;
    ci = ci->parent;
}
if (depth >= maxNumLevels)
{
    std::ostringstream status;
    status << "[Node::getImplDepth] Depth above maximum "
        "(maxNumLevels = " << maxNumLevels << ", depth = " 
        << depth << ")";
    throw IFVGError(status.str());
}
>>>
    return = {
        value = depth
        desc = Node depth
    }
}
function.public[] = {
	spec = static
	type = int
	name = getImplMaxDepth
	shortDesc = Get maximum depth
	longDesc = Get the maximum depth of the node hierarchy.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplMaxDepth", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplMaxDepth", "Context");
int maxDepth = getImplDepth(otherImpl, context);
int n0 = getImplNumChildNodes(otherImpl);
for (int i = 0; i < n0; i++)
{
    NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
        getImplChildByValidIndex(otherImpl, i), 
        "Node::getImplMaxDepth", "Child node implementation");
    int d0 = getImplMaxDepth(cn0, context);
    if (d0 > maxDepth)
        maxDepth = d0;
}
>>>
    return = {
        value = maxDepth
        desc = Maximum node implementation depth of the hierarchy
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeID
	name = getImplNodeID
	shortDesc = Get node ID
	longDesc = Get the ID of the node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplNodeID", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplNodeID", "Context");
NodeID nid0;
nid0.loc = otherImpl->loc;
nid0.depth = getImplDepth(otherImpl, context);
>>>
    return = {
        value = nid0
        desc = Node ID
    }
}
function.public[] = {
	spec = static
	type = int
	name = getImplChildValidIndex
	shortDesc = Get valid child index
	longDesc = Get the index of the specified child node implementation among the valid child node implementations.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
	param[] = {
	    type = Ionflux::VolGfx::NodeImpl*
	    name = childImpl
	    desc = Child node implementation
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplChildValidIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(childImpl, 
    "Node::getImplChildValidIndex", "Node implementation");
int numChildNodes = getImplNumChildNodes(otherImpl);
NodeImpl* cp = otherImpl->child;
Ionflux::ObjectBase::nullPointerCheck(cp, 
    "Node::getImplChildValidIndex", "Child node pointer");
int result = CHILD_INDEX_INVALID;
int i = 0;
while ((i < numChildNodes) 
    && (result == CHILD_INDEX_INVALID))
{
    NodeImpl& cn = cp[i];
    if (&cn == otherImpl)
        result = i;
    i++;
}
>>>
    return = {
        value = result
        desc = Index of the specified child node among the valid child nodes, or CHILD_INDEX_INVALID if the node is not a child of this node
    }
}
function.public[] = {
	spec = static
	type = int
	name = getImplChildValidIndex
	shortDesc = Get valid child index
	longDesc = Get the index of the child node with the specified order index among the valid child nodes.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = int
	    name = orderIndex
	    desc = Order index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplChildValidIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplChildValidIndex", "Context");
int n0 = context->getMaxNumLeafChildNodesPerNode();
int numChildNodes = getImplNumChildNodes(otherImpl);
if (orderIndex >= n0)
{
    std::ostringstream status;
    status << "[Node::getImplChildValidIndex] "
        "Child node index out of range: " << orderIndex;
    throw IFVGError(status.str());
}
if (!otherImpl->valid.test(orderIndex))
{
    /* <---- DEBUG ----- //
    std::cout << "[Node::getImplChildValidIndex] DEBUG: ["
        << getImplValueString(otherImpl, context) << "] "
        "Child node invalid for order index (" 
        << orderIndex << ")." << std::endl;
    // <---- DEBUG ----- */
    return CHILD_INDEX_INVALID;
}
int i = 0;
int k = 0;
while ((i <= orderIndex) 
    && (k < numChildNodes))
{
    if (otherImpl->valid.test(i))
        k++;
    i++;
}
if (i == orderIndex + 1)
    return k - 1;
/* <---- DEBUG ----- //
std::cout << "[Node::getImplChildValidIndex] DEBUG: ["
    << getImplValueString(otherImpl, context) << "] "
    "Child node invalid for order index (orderIndex = " 
    << orderIndex << ", i = " << i << ", k = " << k << ")." 
    << std::endl;
// <---- DEBUG ----- */
>>>
    return = {
        value = CHILD_INDEX_INVALID
        desc = Index of the specified child node among the valid child nodes, or CHILD_INDEX_INVALID if the node is not a child of this node
    }
}
function.public[] = {
	spec = static
	type = int
	name = getImplChildOrderIndex
	shortDesc = Get child order index
	longDesc = Get the index of the child node with the specified valid index among all child nodes (including invalid nodes). This can be used to calculate the coordinates of a child node or to test the mask bits.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = const Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = int
	    name = index
	    desc = Index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplChildOrderIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplChildOrderIndex", "Context");
int numChildNodes = getImplNumChildNodes(otherImpl);
if (index >= numChildNodes)
{
    std::ostringstream status;
    status << "[Node::getImplChildOrderIndex] "
        "Child node index out of range: " << index;
    throw IFVGError(status.str());
}
// Find the bit index of the child with the specified index.
int i = 0;
int n0 = context->getMaxNumLeafChildNodesPerNode();
int validCount = 0;
while ((validCount < index) 
    && (i < n0))
{
    if (otherImpl->valid.test(i))
        validCount++;
    i++;
}
if ((validCount - 1) == index)
    return i - 1;
>>>
    return = {
        value = CHILD_INDEX_INVALID
        desc = \c true if the child with the specified index is a leaf node, \c false otherwise
    }
}
function.public[] = {
	spec = static
	type = int
	name = getImplChildOrderIndex
	shortDesc = Get child order index
	longDesc = Get the order index of the specified child node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = childImpl
        desc = Child node implementation
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplChildOrderIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(childImpl, 
    "Node::getImplChildOrderIndex", "Child node implementation");
if (isImplLeaf(otherImpl))
    return CHILD_INDEX_INVALID;
int numChildNodes = getImplNumChildNodes(otherImpl);
// Find the bit index of the matching child node implementation.
int i = 0;
int validCount = 0;
NodeImpl* cp = otherImpl->child;
bool found = false;
while ((validCount < numChildNodes) 
    && !found)
{
    if (otherImpl->valid.test(i))
    {
        NodeImpl* ci = &(cp[validCount]);
        if (ci == childImpl)
            found = true;
        validCount++;
    }
    i++;
}
if (found)
    return i - 1;
>>>
    return = {
        value = CHILD_INDEX_INVALID
        desc = \c true if the child with the specified index is a leaf node, \c false otherwise
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeImpl*
	name = getImplChildByOrderIndex
	shortDesc = Get child node implementation by order index
	longDesc = Get the child node implementation with the specified order index. The caller is responsible for managing the returned object.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = int
	    name = orderIndex
	    desc = Order index
	}
	param[] = {
	    type = bool
	    name = autoCreate
	    desc = Create child nodes automatically if they do not exist
	    default = false
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplChildByOrderIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplChildByOrderIndex", "Context");
int n0 = context->getMaxNumLeafChildNodesPerNode();
if (orderIndex >= n0)
{
    std::ostringstream status;
    status << "[Node::getImplChildByOrderIndex] "
        "Child node index out of range: " << orderIndex;
    throw IFVGError(status.str());
}
int vi = getImplChildValidIndex(otherImpl, context, orderIndex);
if (vi == CHILD_INDEX_INVALID)
{
    if (autoCreate)
    {
        // Create a new child node.
        /* <---- DEBUG ----- //
        std::cout << "[Node::getImplChildByOrderIndex] DEBUG: ["
            << getImplValueString(otherImpl, context) << "] "
            "Child node does not exist for order index (" 
            << orderIndex << "), creating new node." << std::endl;
        // <---- DEBUG ----- */
        NodeImplVector newImpl;
        NodeImpl* createdImpl = 0;
        for (int i = 0; i < n0; i++)
        {
            if (i == orderIndex)
            {
                /* Create a new node implementation for this 
                   order index. */
                createdImpl = createImpl();
                refImpl(createdImpl);
                createdImpl->parent = otherImpl;
                newImpl.push_back(createdImpl);
            } else
            {
                // Add invalid node.
                newImpl.push_back(0);
            }
        }
        mergeImplChildNodes(otherImpl, context, newImpl, fill0);
        if (createdImpl != 0)
            unrefImpl(createdImpl);
        vi = getImplChildValidIndex(otherImpl, context, orderIndex);
    } else
    {
        // Node is invalid and should not be created.
        /* <---- DEBUG ----- //
        unsigned int d0 = getImplDepth(otherImpl, context);
        Ionflux::GeoUtils::Vector3 lv0;
        context->getVoxelLocation(otherImpl->loc, d0, lv0);
        std::cout << "[Node::getImplChildByOrderIndex] DEBUG: "
            "node: [" << d0 << ", (" << lv0.getValueString() << ")] "
            "Child node does not exist for order index " 
            << orderIndex << ")." << std::endl;
        // <---- DEBUG ----- */
        return 0;
    }
}
NodeImpl* cn = getImplChildByValidIndex(otherImpl, vi);
if (cn == 0)
{
    std::ostringstream status;
    unsigned int d0 = getImplDepth(otherImpl, context);
    Ionflux::GeoUtils::Vector3 lv0;
    context->getVoxelLocation(otherImpl->loc, d0, lv0);
    status << "[Node::getImplChildByOrderIndex] "
        << "Child with valid index #" << vi 
        << " is null [this.loc = (" 
        << lv0.getValueString() << "), this.depth = " 
        << d0 << "].";
    throw IFVGError(status.str());
}
>>>
    return = {
        value = cn
        desc = Child node with the specified order index, or 0 if the child node does not exist
    }
}
function.public[] = {
	spec = static
	type = int
	name = getImplNumChildNodes
	shortDesc = Get number of child nodes
	longDesc = Get the number of valid child nodes of this node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplNumChildNodes", "Node implementation");
>>>
    return = {
        value = otherImpl->valid.count()
        desc = String representation
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeImpl*
	name = getImplChildByValidIndex
	shortDesc = Get child implementation by valid index
	longDesc = Get the child node implementation with the specified valid index. If the child node with the specified index does not exist, an exception will be raised.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
	param[] = {
	    type = int
	    name = index
	    desc = Valid index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "getImplChildByValidIndex", "Node implementation");
NodeImpl* cp = otherImpl->child;
Ionflux::ObjectBase::nullPointerCheck(cp, 
    "getImplChildByValidIndex", "Node child pointer");
int numChildNodes = getImplNumChildNodes(otherImpl);
if ((index < 0) || (index > numChildNodes))
{
    std::ostringstream status;
    status << "[Node::getImplChildByValidIndex] "
        "Child node index out of range: " << index;
    throw IFVGError(status.str());
}
>>>
    return = {
        value = &(cp[index])
        desc = Child node with the specified valid index
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeImpl*
	name = locateImplChild
	shortDesc = Locate child node implementation
	longDesc = Locate the child node that contains the specified location index. If \c maxDepth is greater than zero, the search for the node stops at the specified maximum depth.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc
	    desc = Node data
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::locateImplChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::locateImplChild", "Context");
LocInt maxNumLevels = context->getMaxNumLevels();
LocInt depth = getImplDepth(otherImpl, context);
if ((maxDepth < 0) 
    || (maxDepth >= maxNumLevels))
    maxDepth = maxNumLevels - 1;
/* <---- DEBUG ----- //
std::cout << "[Node::locateImplChild] DEBUG: ["
    << getImplValueString(otherImpl, context) << "] loc = " 
    << getLocString(loc) << ", maxDepth = " << maxDepth 
    << std::endl;
// <---- DEBUG ----- */
if (depth > maxDepth)
{
    // Current node is below the maximum depth.
    /* <---- DEBUG ----- //
    std::cout << "[Node::locateImplChild] DEBUG: "
        << "Current node is below maximum depth." << std::endl;
    // <---- DEBUG ----- */
    return 0;
}
// Check location code of the current node.
if (!context->locEqual(loc, otherImpl->loc, depth))
{
    // Location is outside the bounds of this node.
    /* <---- DEBUG ----- //
    std::cout << "[Node::locateImplChild] DEBUG: "
        << "Location is outside the bounds of this node (loc = " 
        << getLocString(loc) << ")." << std::endl;
    // <---- DEBUG ----- */
    return 0;
}
if (isImplLeaf(otherImpl) || (depth == maxDepth))
{
    /* The current node is the closest leaf node to the 
       specified location. */
    /* <---- DEBUG ----- //
    std::cout << "[Node::locateImplChild] DEBUG: "
        << "Current node is the closest leaf node to loc = " 
        << getLocString(loc) << "." << std::endl;
    // <---- DEBUG ----- */
    return otherImpl;
}
NodeImpl* ci0 = otherImpl;
NodeImpl* ci1 = 0;
bool found = false;
while (!found)
{
    if (depth >= (maxNumLevels - 1))
    {
        // This node should be a leaf node.
        std::ostringstream status;
        status << "[Node::locateImplChild] "
            "Depth above maximum (maxNumLevels = " << maxNumLevels 
            << ", depth = " << (depth + 1) << ").";
        throw IFVGError(status.str());
    }
    int oi = context->getChildOrderIndex(loc, depth + 1);
    if (oi < 0)
    {
        std::ostringstream status;
        status << "[Node::locateImplChild] "
            "Invalid child order index (maxNumLevels = " 
            << maxNumLevels << ", depth = " << (depth + 1) 
            << ", loc = " << getLocString(loc) << ").";
        throw IFVGError(status.str());
    }
    if (ci0->valid.test(oi))
    {
        ci1 = ci0;
        ci0 = getImplChildByOrderIndex(ci0, context, oi);
        if (ci0 == 0)
        {
            std::ostringstream status;
            unsigned int d0 = getImplDepth(ci1, context);
            Ionflux::GeoUtils::Vector3 lv0;
            context->getVoxelLocation(ci1->loc, d0, lv0);
            Ionflux::GeoUtils::Vector3 lv1;
            context->getLocation(loc, lv1);
            status << "[Node::locateImplChild] "
                << "Child with valid order index #" << oi 
                << " does not exist [this.loc = (" 
                << lv0.getValueString() << "), this.depth = " << d0 
                << ", target.loc = (" << lv1.getValueString() 
                << "), target.depth = " << maxDepth << "].";
            throw IFVGError(status.str());
        }
        if (otherImpl->leaf.test(oi))
        {
            // Child node is a leaf node.
            /* <---- DEBUG ----- //
            std::cout << "[Node::locateImplChild] DEBUG: "
                << "Matching leaf child node with order index: " 
                << oi << "." << std::endl;
            // <---- DEBUG ----- */
            found = true;
        } else
        {
            // Continue with child node.
            depth++;
            if (depth == maxDepth)
            {
                // Child note is at the specified depth.
                /* <---- DEBUG ----- //
                std::cout << "[Node::locateImplChild] DEBUG: "
                    << "Matching child node with order index (" 
                    << oi << ") at target depth (" << maxDepth 
                    << ")." << std::endl;
                // <---- DEBUG ----- */
                found = true;
            }
        }
    } else
    {
        /* If the child specified by the location code is not valid, 
           the current node is the closest node to the specified 
           location. */
        /* <---- DEBUG ----- //
        std::cout << "[Node::locateImplChild] DEBUG: "
            << "Matching child node does not exist (orderIndex = " 
            << oi << ")." << std::endl;
        // <---- DEBUG ----- */
        found = true;
    }
}
>>>
    return = {
        value = ci0
        desc = Node containing the specified location, or 0 if no suitable node was found
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeImpl*
	name = locateImplChild
	shortDesc = Locate child node
	longDesc = Locate the child node that contains the specified point. If \c maxDepth is greater than zero, the search for the node stops at the specified maximum depth. The caller is responsible for managing the returned object.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = const Ionflux::GeoUtils::Vector3&
	    name = p
	    desc = Point
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::locateImplChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::locateImplChild", "Context");
// <---- DEBUG ----- //
if (!context->checkLoc(p))
{
    std::ostringstream status;
    status << "Location out of bounds (v = (" << p.getValueString() 
        << "))";
    throw IFVGError(Ionflux::ObjectBase::getErrorString(
        status.str(), "Node::locateImplChild"));
}
// <---- DEBUG ----- */
NodeLoc3 loc = context->createLoc(p);
>>>
    return = {
        value = locateImplChild(otherImpl, context, loc, maxDepth)
        desc = Leaf node containing the specified location, or 0 if no suitable node was found
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeImpl*
	name = insertImplChild
	shortDesc = Insert child node implementation
	longDesc = Insert a child node at the specified depth that contains the specified location index. If \c depth is negative, a leaf node at the maximum depth will be inserted. If a node with the specified location code already exists at the specified depth, that node will be returned.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc
	    desc = Node data
	}
	param[] = {
	    type = int
	    name = depth
	    desc = Depth at which to create the node
	    default = DEPTH_UNSPECIFIED
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	param[] = {
	    type = bool
	    name = fillTargetDepth0
	    desc = Create a full set of child nodes at the target depth level if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::insertImplChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::insertImplChild", "Context");
LocInt maxNumLevels = context->getMaxNumLevels();
if (depth < 0)
    depth = maxNumLevels - 1;
/* <---- DEBUG ----- //
std::cout << "[Node::insertImplChild] DEBUG: ["
    << getImplValueString(otherImpl, context) << "] loc = " 
    << getLocString(loc) << ", depth = " << depth 
    << std::endl;
// <---- DEBUG ----- */
if (depth > (maxNumLevels - 1))
{
    std::ostringstream status;
    status << "[Node::insertImplChild] "
        "Depth above maximum (maxNumLevels = " << maxNumLevels 
        << ", depth = " << depth << ")";
    throw IFVGError(status.str());
}
// Locate the node that is closest to the specified location.
NodeImpl* ci = locateImplChild(otherImpl, context, loc, depth);
if (ci == 0)
{
    // Location is outside the bounds of this node.
    // <---- DEBUG ----- //
    unsigned int d0 = getImplDepth(otherImpl, context);
    Ionflux::GeoUtils::Vector3 lv0;
    context->getVoxelLocation(otherImpl->loc, d0, lv0);
    Ionflux::GeoUtils::Vector3 lv1;
    context->getLocation(loc, lv1);
    std::cout << "[Node::insertImplChild] DEBUG: "
        << "Location is outside the bounds of this node "
        "[this.loc = (" << lv0.getValueString() << "), this.depth = " 
        << d0 << ", target.loc = (" << lv1.getValueString() 
        << "), target.depth = " << depth << "]." << std::endl;
    // <---- DEBUG ----- */
    return 0;
}
int cd = getImplDepth(ci, context);
if (cd == depth)
{
    // Node has the specified depth.
    /* <---- DEBUG ----- //
    std::cout << "[Node::insertImplChild] DEBUG: "
        << "Returning existing node (depth = " << depth 
        << ", loc = " << getLocString(loc) << ")." 
        << std::endl;
    // <---- DEBUG ----- */
    return ci;
}
/* <---- DEBUG ----- //
std::cout << "[Node::insertImplChild] DEBUG: "
    << "Closest leaf node [" 
    << getImplValueString(otherImpl, context) << "] loc = " 
    << getLocString(loc) << ", depth = " << depth 
    << std::endl;
// <---- DEBUG ----- */
// Add nodes until specified depth is reached.
while (cd < depth)
{
    if (cd > (maxNumLevels - 1))
    {
        std::ostringstream status;
        status << "[Node::insertImplChild] "
            "Depth above maximum (maxNumLevels = " 
            << maxNumLevels << ", depth = " << (cd + 1) 
            << ").";
        throw IFVGError(status.str());
    }
    int oi = context->getChildOrderIndex(loc, cd + 1);
    bool fill1 = fill0;
    if (!fill0 && (cd == (depth - 1)))
        fill1 = fillTargetDepth0;
    /* <---- DEBUG ----- //
    std::cout << "[Node::insertImplChild] DEBUG: "
        << "Inserting node (depth = " << (cd + 1) 
        << ", loc = " << getLocString(loc) << ", orderIndex = " 
        << oi << ")." << std::endl;
    // <---- DEBUG ----- */
    ci = getImplChildByOrderIndex(ci, context, oi, true, fill1);
    if (ci == 0)
    {
        Ionflux::GeoUtils::Vector3 lv0;
        context->getLocation(loc, lv0);
        std::ostringstream status;
        status << "[Node::insertImplChild] "
            "Could not create child node [loc = (" 
            << lv0.getValueString() << "), depth = " << depth 
            << ", orderIndex = " << oi << "].";
        throw IFVGError(status.str());
    }
    cd++;
}
>>>
    return = {
        value = ci
        desc = Node at the specified location and depth, or 0 if the location is outside the bounds of this node
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeImpl*
	name = insertImplChild
	shortDesc = Insert child node implementation
	longDesc = Insert a child node at the specified depth that contains the specified location index. If \c depth is negative, a leaf node at the maximum depth will be inserted. If a node with the specified location code already exists at the specified depth, that node will be returned.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = const Ionflux::GeoUtils::Vector3&
	    name = p
	    desc = Point
	}
	param[] = {
	    type = int
	    name = depth
	    desc = Depth at which to create the node
	    default = DEPTH_UNSPECIFIED
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	param[] = {
	    type = bool
	    name = fillTargetDepth0
	    desc = Create a full set of child nodes at the target depth level if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::insertImplChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::insertImplChild", "Context");
// <---- DEBUG ----- //
if (!context->checkLoc(p))
{
    std::ostringstream status;
    status << "Location out of bounds (v = (" << p.getValueString() 
        << "))";
    throw IFVGError(Ionflux::ObjectBase::getErrorString(
        status.str(), "Node::insertImplChild"));
}
// <---- DEBUG ----- */
NodeLoc3 loc = context->createLoc(p);
>>>
    return = {
        value = <<<
insertImplChild(otherImpl, context, loc, depth, fill0, 
    fillTargetDepth0)
>>>
        desc = Node at the specified location and depth, or 0 if the location is outside the bounds of this node
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeImpl*
	name = insertImplChild
	shortDesc = Insert child node implementation
	longDesc = Insert a child node identified by the specified node ID. If \c depth is not greater than zero, a leaf node at the maximum depth will be inserted. If a node with the specified location code already exists at the specified depth, that node will be returned.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = const Ionflux::VolGfx::NodeID&
	    name = nodeID
	    desc = Node ID
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	param[] = {
	    type = bool
	    name = fillTargetDepth0
	    desc = Create a full set of child nodes at the target depth level if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::insertImplChild", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::insertImplChild", "Context");
>>>
    return = {
        value = <<<
insertImplChild(otherImpl, context, nodeID.loc, nodeID.depth, fill0, 
    fillTargetDepth0);
>>>
        desc = Node at the specified location and depth, or 0 if the location is outside the bounds of this node
    }
}
function.public[] = {
	spec = static
	type = void
	name = mergeImplChildNodes
	shortDesc = Merge child nodes
	longDesc = Merge the nodes from the vector with the current child nodes of the node implementation. \c newNodes is expected to be a vector containing a number of node implementations equal or greater than the maximum number of child nodes per node, ordered by ascending local X, Y, Z coordinate. Nodes that should not be changed are identified by a zero entry within the vector. A new node implementation will be created for each entry in \c newNodes. This node implementation takes over all data and child nodes from the entry in \c newNodes.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = const Ionflux::VolGfx::NodeImplVector&
	    name = newNodes
	    desc = Vector of node implementations
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::mergeImplChildNodes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::mergeImplChildNodes", "Context");
int n0 = context->getMaxNumLeafChildNodesPerNode();
if (newNodes.size() < static_cast<unsigned int>(n0))
{
    std::ostringstream status;
    status << "[Node::mergeImplChildNodes] "
        "Unexpected number of nodes in vector (expected: " 
        << n0 << ", got: " << newNodes.size() << ")";
    throw IFVGError(status.str());
}
NodeImplVector newNodes0 = newNodes;
int numValid = 0;
NodeImpl* cp0 = 0;
if (!isImplLeaf(otherImpl))
{
    cp0 = Ionflux::ObjectBase::nullPointerCheck(
        otherImpl->child, "Node::mergeImplChildNodes", 
            "Child node pointer");
}
// Scan for valid nodes.
NodeChildMask newLeaf = otherImpl->leaf;
NodeChildMask newValid = otherImpl->valid;
NodeImplVector createdImpl;
for (int i = 0; i < n0; i++)
{
    NodeImpl* ci = newNodes0[i];
    if (ci != 0)
    {
        // Use the new node implementation.
        newValid.set(i, true);
        if (!ci->valid.any())
            newLeaf.set(i, true);
        else
            newLeaf.set(i, false);
        numValid++;
    } else 
    if (otherImpl->valid.test(i))
    {
        // Use existing node implementation.
        numValid++;
    } else
    if (fill0)
    {
        // Create missing nodes.
        newValid.set(i, true);
        newLeaf.set(i, true);
        ci = createImpl();
        refImpl(ci);
        ci->parent = otherImpl;
        createdImpl.push_back(ci);
        newNodes0[i] = ci;
        numValid++;
    }
}
// Copy node implementations.
NodeImpl* cp1 = new NodeImpl[numValid];
if (cp1 == 0)
{
    throw IFVGError("Node::mergeImplChildNodes"
        "Could not allocate child node implementations.");
}
int k = 0;
int l = 0;
for (int i = 0; i < n0; i++)
{
    NodeImpl* ci = newNodes0[i];
    if (ci != 0)
    {
        // Create new child node implementation.
        copyImpl(*ci, cp1[k], true);
        cp1[k].refCount = 0;
        cp1[k].parent = otherImpl;
        cp1[k].loc = getImplChildLoc(otherImpl, context, i);
        setImplParent(&(cp1[k]));
        // This reference will be cleared by clearImpl().
        refImpl(&(cp1[k]));
        k++;
    } else
    if (otherImpl->valid.test(i))
    {
        // Copy existing child node implementation.
        copyImpl(cp0[l], cp1[k], true);
        cp1[k].refCount = 0;
        cp1[k].parent = otherImpl;
        cp1[k].loc = getImplChildLoc(otherImpl, context, i);
        setImplParent(&(cp1[k]));
        // This reference will be cleared by clearImpl().
        refImpl(&(cp1[k]));
        l++;
        k++;
    }
}
/* NOTE: Data for any nodes that should be kept has already been taken 
         over, so clearing all old child nodes here should be safe. */
clearImpl(otherImpl, true, false, true);
otherImpl->child = cp1;
otherImpl->valid = newValid;
otherImpl->leaf = newLeaf;
NodeImpl* pi = otherImpl->parent;
if (pi != 0)
    updateImpl(pi, context);
// clean up references to temporary nodes
for (NodeImplVector::iterator i = createdImpl.begin(); 
    i != createdImpl.end(); i++)
    unrefImpl(*i);
>>>
}
function.public[] = {
	spec = static
	type = void
	name = setImplChildByOrderIndex
	shortDesc = Set child node
	longDesc = Set the child node implementation for the child node with the specified order index.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = Ionflux::VolGfx::NodeImpl*
	    name = newNode
	    desc = Child node implementation
	}
	param[] = {
	    type = int
	    name = orderIndex
	    desc = Order index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::setImplChildByOrderIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::setImplChildByOrderIndex", "Context");
int n0 = context->getMaxNumLeafChildNodesPerNode();
if (orderIndex >= n0)
{
    std::ostringstream status;
    status << "[Node::setImplChildNodeByOrderIndex] "
        "Child node index out of range: " << orderIndex;
    throw IFVGError(status.str());
}
NodeImplVector niv;
for (int i = 0; i < n0; i++)
{
    if (i == orderIndex)
    {
        refImpl(newNode);
        niv.push_back(newNode);
    } else
        niv.push_back(0);
}
mergeImplChildNodes(otherImpl, context, niv);
// Unreference temporary nodes.
for (int i = 0; i < n0; i++)
{
    NodeImpl* ci = niv[i];
    if (ci != 0)
        unrefImpl(ci);
}
>>>
}
function.public[] = {
	spec = static
	type = void
	name = setImplChildByValidIndex
	shortDesc = Set child node
	longDesc = Set the child node implementation for the child node with the specified valid index. Any existing child data for that index will be cleared.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
	param[] = {
	    type = Ionflux::VolGfx::NodeImpl*
	    name = newImpl
	    desc = Child node implementation
	}
	param[] = {
	    type = int
	    name = index
	    desc = Valid index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::setImplChildByValidIndex", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(newImpl, 
    "Node::setImplChildByValidIndex", "Node implementation (child)");
int numChildNodes = getImplNumChildNodes(otherImpl);
if (index >= numChildNodes)
{
    std::ostringstream status;
    status << "[Node::setImplChildByValidIndex]" 
        "Child node index out of range: " << index;
    throw IFVGError(status.str());
}
NodeImpl* cp = otherImpl->child;
Ionflux::ObjectBase::nullPointerCheck(cp, 
    "Node::setImplChildByValidIndex", "Child node pointer");
NodeImpl& ci = cp[index];
Ionflux::ObjectBase::UInt16 rc0 = ci.refCount;
NodeLoc3 loc0 = ci.loc;
if (rc0 != 0)
{
    std::ostringstream status;
    status << "[Node::setImplChildByValidIndex] "
        "Child node has zero references (index = " << index 
        << ").";
    throw IFVGError(status.str());
}
if (rc0 > 1)
{
    std::ostringstream status;
    status << "[Node::setImplChildByValidIndex] "
        "Cannot replace child node with external references "
        "(index = " << index << ", refCount = " << rc0 << ").";
    throw IFVGError(status.str());
}
clearImpl(&ci, true, true, true);
copyImpl(*newImpl, ci, true);
/* Since the pointer to the child that is being replaced stays the 
   same, the reference count can also be taken over. */
ci.refCount = rc0;
ci.parent = otherImpl;
ci.loc = loc0;
setImplParent(&ci);
>>>
}
function.public[] = {
	spec = static
	type = void
	name = setImplChildNodes
	shortDesc = Set child nodes
	longDesc = Set the child nodes of the node. \c newNodes is expected to be a vector containing a number of node implementations equal or greater than the maximum number of child nodes per node, ordered by ascending local X, Y, Z coordinate. Invalid nodes are identified by a zero entry within the vector. Existing child nodes will be cleared.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = const Ionflux::VolGfx::NodeImplVector&
	    name = newNodes
	    desc = Vector of node implementations
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::setImplChildNodes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::setImplChildNodes", "Context");
int n0 = context->getMaxNumLeafChildNodesPerNode();
if (newNodes.size() < static_cast<unsigned int>(n0))
{
    std::ostringstream status;
    status << "[Node::setImplChildNodes] "
        "Unexpected number of nodes in vector (expected: " 
        << n0 << ", got: " << newNodes.size() << ")";
    throw IFVGError(status.str());
}
int numValid = 0;
otherImpl->valid = 0;
otherImpl->leaf = 0;
// Scan for valid nodes.
for (int i = 0; i < n0; i++)
{
    NodeImpl* ci = newNodes[i];
    if (ci != 0)
    {
        otherImpl->valid.set(i, true);
        if (!ci->valid.any())
            otherImpl->leaf.set(i, true);
        numValid++;
    }
}
// Copy node implementations.
NodeImpl* cp = new NodeImpl[numValid];
if (cp == 0)
{
    throw IFVGError("Node::setImplChildNodes"
        "Could not allocate child node implementations.");
}
int k = 0;
for (int i = 0; i < n0; i++)
{
    NodeImpl* ci = newNodes[i];
    if (ci != 0)
    {
        copyImpl(*ci, cp[k], true);
        cp[k].refCount = 0;
        cp[k].parent = otherImpl;
        cp[k].loc = getImplChildLoc(otherImpl, context, i);
        setImplParent(&(cp[k]));
        // This reference will be cleared by clearImpl().
        refImpl(&(cp[k]));
        k++;
    }
}
clearImpl(otherImpl, true, false, true);
otherImpl->child = cp;
NodeImpl* pi = otherImpl->parent;
if (pi != 0)
    updateImpl(pi, context);
>>>
}
function.public[] = {
	spec = static
	type = void
	name = clearImplChildNodes
	shortDesc = Clear child nodes
	longDesc = Clear the child nodes indicated by a bit set in the child node mask.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = const Ionflux::VolGfx::NodeChildMask&
	    name = clearNodes
	    desc = Mask indicating nodes to be cleared
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::clearImplChildNodes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::clearImplChildNodes", "Context");
int n0 = context->getMaxNumLeafChildNodesPerNode();
int numValid = 0;
if (isImplLeaf(otherImpl))
{
    // This is a leaf node, nothing to be done.
    return;
}
NodeImpl* cp0 = Ionflux::ObjectBase::nullPointerCheck(
    otherImpl->child, "Node::clearImplChildNodes", 
    "Child node pointer");
// Scan for valid nodes.
NodeChildMask newLeaf = otherImpl->leaf;
NodeChildMask newValid = otherImpl->valid;
for (int i = 0; i < n0; i++)
{
    if (otherImpl->valid.test(i))
    {
        if (!clearNodes.test(i)) 
        {
            // keep this node.
            numValid++;
        } else
        {
            // node will be cleared
            newValid.set(i, false);
            newLeaf.set(i, false);
        }
    }
}
// Copy node implementations.
NodeImpl* cp1 = new NodeImpl[numValid];
if (cp1 == 0)
{
    throw IFVGError("Node::clearImplChildNodes"
        "Could not allocate child node implementations.");
}
int k = 0;
int l = 0;
for (int i = 0; i < n0; i++)
{
    if (otherImpl->valid.test(i))
    {
        if (!clearNodes.test(i))
        {
            // Copy existing child node implementation.
            copyImpl(cp0[l], cp1[k], true);
            cp1[k].refCount = 0;
            cp1[k].parent = otherImpl;
            cp1[k].loc = getImplChildLoc(otherImpl, context, i);
            setImplParent(&(cp1[k]));
            // This reference will be cleared by clearImpl().
            refImpl(&(cp1[k]));
            k++;
        }
        l++;
    }
}
/* NOTE: Data for any nodes that should be kept has already been taken 
         over, so clearing all old child nodes here should be safe. */
clearImpl(otherImpl, true, false, true);
otherImpl->child = cp1;
otherImpl->valid = newValid;
otherImpl->leaf = newLeaf;
NodeImpl* pi = otherImpl->parent;
if (pi != 0)
    updateImpl(pi, context);
>>>
}
function.public[] = {
	spec = static
	type = unsigned int
	name = pruneEmptyImpl
	shortDesc = Prune empty child nodes
	longDesc = Clear the child nodes which are leaf nodes but do not contain any data.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively prune nodes
        default = false
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::pruneEmptyImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::pruneEmptyImpl", "Context");
int n0 = context->getMaxNumLeafChildNodesPerNode();
NodeChildMask cm0 = 0;
unsigned int numPruned = 0;
for (int i = 0; i < n0; i++)
{
    if (otherImpl->valid.test(i))
    {
        NodeImpl* cn = Ionflux::ObjectBase::nullPointerCheck(
            getImplChildByOrderIndex(otherImpl, context, i, false), 
                "Node::pruneEmptyImpl", "Child node implementation");
        if (recursive)
            numPruned += pruneEmptyImpl(cn, context, true);
        if (otherImpl->leaf.test(i))
        {
            if ((cn->data == 0) 
                || (cn->data->type == DATA_TYPE_NULL))
            {
                cm0.set(i, true);
                numPruned++;
            }
        }
    }
}
if (cm0.any())
    clearImplChildNodes(otherImpl, context, cm0);
>>>
    return = {
        value = numPruned
        desc = number of nodes that were pruned
    }
}
function.public[] = {
	spec = static
	type = int
	name = fillImpl
	shortDesc = Fill node
	longDesc = Fill the node. This creates new child nodes so that all children of this node are valid. If \c clearExisting is set to \c true, any existing child nodes are cleared. If \c recursive is set to \c true, child nodes are filled recursively. If \c maxDepth is not negative, child nodes will be filled up to and including the maximum depth specified.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = bool
	    name = clearExisting
	    desc = Clear existing child nodes
	    default = false
	}
	param[] = {
	    type = bool
	    name = recursive
	    desc = Fill nodes recursively
	    default = false
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::fillImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::fillImpl", "Context");
LocInt maxNumLevels = context->getMaxNumLevels();
int n0 = context->getMaxNumLeafChildNodesPerNode();
LocInt depth = getImplDepth(otherImpl, context);
if ((maxDepth < 0) 
    || (maxDepth >= maxNumLevels))
    maxDepth = maxNumLevels - 1;
/* <---- DEBUG ----- //
if (depth == 2)
{
    std::cout << "[Node::fillImpl] DEBUG: ["
        << getImplValueString(otherImpl, context) << "] depth = " 
        << depth << ", maxDepth = " << maxDepth << std::endl;
}
// <---- DEBUG ----- */
if (depth >= maxDepth)
{
    // Current node is at the maximum depth.
    /* <---- DEBUG ----- //
    std::cout << "[Node::fillImpl] DEBUG: "
        << "Current node is at maximum depth." << std::endl;
    // <---- DEBUG ----- */
    return 0;
}
if (clearExisting)
{
    /* <---- DEBUG ----- //
    std::cout << "[Node::fillImpl] DEBUG: "
        << "Clearing data." << std::endl;
    // <---- DEBUG ----- */
    clearImpl(otherImpl, true, false, true);
}
// Add new child nodes.
int nodesCreated = 0;
NodeImplVector niv;
for (int i = 0; i < n0; i++)
{
    if (!otherImpl->valid.test(i))
    {
        /* <---- DEBUG ----- //
        if (depth == 2)
        {
            std::cout << "[Node::fillImpl] DEBUG: "
                << "Creating node #" << std::setw(3) 
                << std::setfill('0') << i << "." << std::endl;
        }
        // <---- DEBUG ----- */
        NodeImpl* ci = createImpl();
        refImpl(ci);
        niv.push_back(ci);
        nodesCreated++;
    } else
        niv.push_back(0);
}
mergeImplChildNodes(otherImpl, context, niv);
// Unreference temporary nodes.
for (int i = 0; i < n0; i++)
{
    NodeImpl* ci = niv[i];
    if (ci != 0)
        unrefImpl(ci);
}
if ((recursive)
    && (depth < maxDepth))
{
    // Recursively fill nodes.
    /* <---- DEBUG ----- //
    std::cout << "[Node::fillImpl] DEBUG: "
        << "Recursively filling nodes." << std::endl;
    // <---- DEBUG ----- */
    for (int i = 0; i < n0; i++)
    {
        if (otherImpl->valid.test(i))
        {
            /* <---- DEBUG ----- //
            std::cout << "[Node::fillImpl] DEBUG: "
                << "Filling child node #" << std::setw(3) 
                << std::setfill('0') << i << "." << std::endl;
            // <---- DEBUG ----- */
            NodeImpl* ci = getImplChildByOrderIndex(otherImpl, 
                context, i, false);
            Ionflux::ObjectBase::nullPointerCheck(ci, 
                "Node::fillImpl", "Child node implementation");
            int nc0 = fillImpl(ci, context, clearExisting, 
                recursive, maxDepth);
            nodesCreated += nc0;
        }
    }
}
>>>
    return = {
        value = nodesCreated
        desc = Number of new nodes that have been created
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeImpl*
	name = locateImplRegion
	shortDesc = Locate region
	longDesc = Locate the node that contains the specified region. If \c maxDepth is greater than zero, the search for the node stops at the specified maximum depth.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = const Ionflux::VolGfx::Region3&
	    name = region
	    desc = Region
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::locateImplRegion", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::locateImplRegion", "Context");
// <---- DEBUG ----- //
std::cout << "[Node::locateImplRegion] DEBUG: ["
    << getImplValueString(otherImpl, context) << "] region = " 
    << getRegionString(region) << ", maxDepth = " << maxDepth 
    << std::endl;
// <---- DEBUG ----- */
int l0 = context->getCommonAncestorLevel(region, maxDepth);
// <---- DEBUG ----- //
std::cout << "[Node::locateImplRegion] DEBUG: "
    "target level = " << l0 << std::endl;
// <---- DEBUG ----- */
NodeImpl* ni = locateImplChild(otherImpl, context, region.l0, l0);
// <---- DEBUG ----- //
if (ni != 0)
{
    std::cout << "[Node::locateImplRegion] DEBUG: result node: ["
        << getImplValueString(ni, context) << "]." << std::endl;
} else
{
    std::cout << "[Node::locateImplRegion] DEBUG: "
        "No suitable node was found." << std::endl;
}
// <---- DEBUG ----- */
>>>
    return = {
        value = ni
        desc = Node containing the specified region, or 0 if no suitable node was found
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeImpl*
	name = locateImplNode
	shortDesc = Locate node implementation
	longDesc = Locate the node that contains the specified location index. If \c maxDepth is not negative, the search for the node stops at the specified maximum depth. This function will search the ancestors of the current node implementation upwards if the specified location is not contained in this node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = const Ionflux::VolGfx::NodeLoc3&
	    name = loc
	    desc = Location
	}
	param[] = {
	    type = int
	    name = maxDepth
	    desc = Maximum depth
	    default = DEPTH_UNSPECIFIED
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::locateImplNode", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::locateImplNode", "Context");
LocInt maxNumLevels = context->getMaxNumLevels();
LocInt depth = getImplDepth(otherImpl, context);
if ((maxDepth < 0) 
    || (maxDepth >= maxNumLevels))
    maxDepth = maxNumLevels - 1;
// <---- DEBUG ----- //
std::cout << "[Node::locateImplNode] DEBUG: ["
    << getImplValueString(otherImpl, context) << "] loc = " 
    << getLocString(loc) << ", maxDepth = " << maxDepth 
    << std::endl;
// <---- DEBUG ----- */
NodeImpl* ci = otherImpl;
int d0 = context->getCommonAncestorLevel(ci->loc, loc, maxDepth);
// <---- DEBUG ----- //
std::cout << "[Node::locateImplNode] DEBUG: "
    << "depth of common ancestor = " << d0 << std::endl;
// <---- DEBUG ----- */
while ((d0 < depth) 
    && (ci->parent != 0))
{
    ci = ci->parent;
    depth--;
}
>>>
    return = {
        value = locateImplChild(ci, context, loc, maxDepth);
        desc = Node containing the specified location, or 0 if no suitable node was found
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::NodeLoc3
	name = getImplChildLoc
	shortDesc = Get child location code
	longDesc = Get the location code of the child node with the specified order index. This will also report the correct location code for child nodes that currently do not exist. If The depth of a child node would be above the maximum depth for the tree, an exception will be raised.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = int
	    name = orderIndex
	    desc = Order index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplChildLoc", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplChildLoc", "Context");
if (context->getOrder() != 2)
{
    throw IFVGError("[Node::getImplChildLoc] "
        "Location codes not supported for tree order != 2.");
}
int n0 = context->getMaxNumLeafChildNodesPerNode();
if (orderIndex >= n0)
{
    std::ostringstream status;
    status << "[Node::getImplChildLoc] "
        "Child node index out of range: " << orderIndex;
    throw IFVGError(status.str());
}
LocInt maxNumLevels = context->getMaxNumLevels();
LocInt depth = getImplDepth(otherImpl, context);
if (depth >= (maxNumLevels - 1))
{
    // This node should be a leaf node.
    std::ostringstream status;
    status << "[Node::getImplChildLoc] "
        "Depth above maximum (maxNumLevels = " << maxNumLevels 
        << ", depth = " << (depth + 1) << ").";
    throw IFVGError(status.str());
}
NodeLoc m0 = context->getLocMask(depth);
NodeLoc3 loc = otherImpl->loc;
int n1 = maxNumLevels - depth - 2;
loc.x = (loc.x & m0) | NodeLoc((orderIndex & 1) << n1);
loc.y = (loc.y & m0) | NodeLoc(((orderIndex & 2) >> 1) << n1);
loc.z = (loc.z & m0) | NodeLoc(((orderIndex & 4) >> 2) << n1);
>>>
    return = {
        value = loc
        desc = Location code for the child node with the specified order index
    }
}
function.public[] = {
	spec = static
	type = double
	name = getImplVoxelSize
	shortDesc = Get voxel size
	longDesc = Get the voxel size for the node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplVoxelSize", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplVoxelSize", "Context");
int depth = getImplDepth(otherImpl, context);
>>>
    return = {
        value = context->getVoxelSize(depth)
        desc = Location vector
    }
}
function.public[] = {
	spec = static
	type = Ionflux::VolGfx::LocInt
	name = getImplVoxelSizeLoc
	shortDesc = Get voxel size
	longDesc = Get the voxel size for the node in location code units.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplVoxelSizeLoc", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplVoxelSizeLoc", "Context");
int depth = getImplDepth(otherImpl, context);
>>>
    return = {
        value = context->getDepthMask(depth).to_ulong()
        desc = Location vector
    }
}
function.public[] = {
	spec = static
	type = bool
	name = getImplNeighborLoc
	shortDesc = Get neighbor location code
	longDesc = Get the location code of the smallest size neighbor node with the specified offset, where the offset is one of {-1, 0, 1} If the neighbor node location is within the bounds of the tree, the location code is stored in \c target. If no neighbor exists within the bounds of the tree, the function returns \c false and the contents of \c target is undefined.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = int
	    name = offsetX
	    desc = Offset (x)
	}
	param[] = {
	    type = int
	    name = offsetY
	    desc = Offset (y)
	}
	param[] = {
	    type = int
	    name = offsetZ
	    desc = Offset (z)
	}
    param[] = {
        type = Ionflux::VolGfx::NodeLoc3&
        name = target
        desc = Where to store the neighbor location
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplNeighborLoc", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplNeighborLoc", "Context");
if (context->getOrder() != 2)
{
    throw IFVGError("[Node::getImplNeighborLoc] "
        "Location codes not supported for tree order != 2.");
}
// <---- DEBUG ----- //
std::cout << "[Node::getImplNeighborLoc] DEBUG: ["
    << getImplValueString(otherImpl, context) << "] offset = (" 
    << offsetX << ", " << offsetY << ", " << offsetZ << ")" 
    << std::endl;
// <---- DEBUG ----- */
LocInt vs = getImplVoxelSizeLoc(otherImpl, context);
// X
int ox = offsetX;
if (offsetX > 0)
    ox = offsetX * vs;
else
if (offsetX < 0)
    ox = -(offsetX + 1) * vs - 1;
// Y
int oy = offsetY;
if (offsetY > 0)
    oy = offsetY * vs;
else
if (offsetY < 0)
    oy = -(offsetY + 1) * vs - 1;
// Z
int oz = offsetZ;
if (offsetZ > 0)
    oz = offsetZ * vs;
else
if (offsetZ < 0)
    oz = -(offsetZ + 1) * vs - 1;
if (!context->checkLoc(otherImpl->loc, ox, oy, oz))
    return false;
target.x = otherImpl->loc.x.to_ulong() + ox;
target.y = otherImpl->loc.y.to_ulong() + oy;
target.z = otherImpl->loc.z.to_ulong() + oz;
>>>
    return = {
        value = true
        desc = \c true if the neighbor node exists, \c false otherwise
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Vector3
	name = getImplLocation
	shortDesc = Get location
	longDesc = Get the location vector for the corner of the node with the lowest coordinates on each of the axes.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplLocation", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplLocation", "Context");
int depth = getImplDepth(otherImpl, context);
>>>
    return = {
        value = context->getVoxelLocation0(otherImpl->loc, depth);
        desc = Location vector
    }
}
function.public[] = {
	spec = static
	type = void
	name = getImplRange
	shortDesc = Get range
	longDesc = Get the range of values contained in the node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::GeoUtils::Range3&
        name = target
        desc = Where to store the range data
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplRange", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplRange", "Context");
int depth = getImplDepth(otherImpl, context);
context->getVoxelRange(otherImpl->loc, depth, target);
>>>
}
function.public[] = {
	spec = static
	type = unsigned int
	name = findImpl
	shortDesc = Find node implementations
	longDesc = Find node implementations that pass the specified filter. If \c target is 0, nodes will be counted but not added to the target set.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::NodeImplVector*
        name = target
        desc = Where to store the node implementations
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = find nodes recursively
        default = true
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::findImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::findImpl", "Context");
if (filter != 0)
{
    int maxDepth = filter->getMaxDepth();
    int depth = getImplDepth(otherImpl, context);
    if (!context->checkDepthRange(depth, 0, maxDepth))
        return 0;
}
unsigned int numNodes = 0;
if ((filter == 0) 
    || NodeProcessor::checkFlags(
        filter->process(otherImpl), NodeFilter::RESULT_PASS))
{
    // add this node implementation
    if (target != 0)
        target->push_back(otherImpl);
    numNodes++;
}
if (!recursive)
    return numNodes;
// find nodes recursively
int n0 = getImplNumChildNodes(otherImpl);
for (int i = 0; i < n0; i++)
{
    NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
        getImplChildByValidIndex(otherImpl, i), 
        "Node::findImplByDepthRange", "Child node implementation");
    numNodes += findImpl(cn0, context, target, filter, true);
}
>>>
    return = {
        value = numNodes
        desc = number of node implementations found
    }
}
function.public[] = {
	spec = static
	type = unsigned int
	name = processImpl
	shortDesc = Process node implementations
	longDesc = Process node implementations that pass the specified filter using the specified node processors. The \c preProcessor is invoked before the recursion. The \c postProcessor is invoked after the recursion. Recursive traversal stops when the \c preProcessor returns ChainableNodeProcessor::RESULT_FINISHED, or when the maximum depth as set on the \c filter is reached.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::NodeProcessor*
        name = preProcessor
        desc = node processor (pre)
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeProcessor*
        name = postProcessor
        desc = node processor (post)
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = find nodes recursively
        default = true
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::processImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::processImpl", "Context");
if (filter != 0)
{
    int maxDepth = filter->getMaxDepth();
    int depth = getImplDepth(otherImpl, context);
    if (!context->checkDepthRange(depth, 0, maxDepth))
        return 0;
}
unsigned int numNodes = 0;
NodeProcessingResultID result = NodeProcessor::RESULT_OK;
bool process0 = false;
if ((filter == 0) 
    || NodeProcessor::checkFlags(
        filter->process(otherImpl), NodeFilter::RESULT_PASS))
{
    // process this node (pre)
    if (preProcessor != 0)
        result = preProcessor->process(otherImpl);
    numNodes++;
    process0 = true;
}
if (!recursive 
    || NodeProcessor::checkFlags(result, 
        ChainableNodeProcessor::RESULT_FINISHED))
    return numNodes;
// process nodes recursively
int n0 = getImplNumChildNodes(otherImpl);
for (int i = 0; i < n0; i++)
{
    NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
        getImplChildByValidIndex(otherImpl, i), 
        "Node::processImpl", "Child node implementation");
    numNodes += processImpl(cn0, context, preProcessor, filter, 
        postProcessor, true);
}
if (process0)
{
    // process this node (post)
    if (postProcessor != 0)
        result = postProcessor->process(otherImpl);
}
>>>
    return = {
        value = numNodes
        desc = number of node implementations processed
    }
}
function.public[] = {
	spec = static
	type = Ionflux::Altjira::Color*
	name = getImplColor
	shortDesc = Get color
	longDesc = Get a color for the node implementation. If the optional \c colors color set is specified, the color for the node is selected from the color set according to the depth level of the node and the specified color offset. If \c colorIndex is not negative, the specified color index will be used for selecting a color from the color set. If the optional \c voxelClassColors is specified and the node has a voxel class attached to its data, the color for the node is selected according to the first entry in the vector that matches one of the voxel classes of the node. The \c colorIndex takes precedence over all other color specifications, followed by the node color index, the voxel class color, the leaf color index and finally the depth based color.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::Altjira::ColorSet*
        name = colors
        desc = color set
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexOffset
        desc = color index offset
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexRange
        desc = color index range
        default = 0
    }
    param[] = {
        type = int
        name = colorIndex
        desc = color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = int
        name = leafColorIndex
        desc = leaf color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassColorVector*
        name = voxelClassColors
        desc = voxel class colors
        default = 0
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplColor", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplColor", "Context");
int ci0 = colorIndex;
Ionflux::Altjira::Color* c0 = 0;
if (ci0 < 0)
{
    // use node color index
    ci0 = getImplColorIndex(otherImpl);
    /* <---- DEBUG ----- //
    if (ci0 >= 0)
    {
        NodeID nid0 = Node::getImplNodeID(otherImpl, context);
        std::cerr << "[Node::getImplColor] DEBUG: "
            "node: [" << getNodeIDValueString(nid0, false, true, true, context) 
            << "] colorIndex = " << ci0 << std::endl;
    }
    // ----- DEBUG ----> */
}
if (ci0 < 0)
{
    if ((voxelClassColors != 0) 
        && (hasImplVoxelClassInfo(otherImpl)))
    {
        // use voxel class color
        VoxelClassID vc = getImplVoxelClass(otherImpl);
        c0 = getVoxelClassColor(*voxelClassColors, vc);
    }
}
if ((c0 == 0) 
    && (colors != 0))
{
    // select a color from the color set
    unsigned int nc0 = colors->getNumColors();
    if (colorIndexRange == 0)
        colorIndexRange = nc0;
    if (ci0 < 0)
    {
        bool leafFlag = isImplLeaf(otherImpl);
        if (leafFlag 
            && (leafColorIndex >= 0))
        {
            // use leaf color index
            ci0 = leafColorIndex;
        } else
        {
            // use color index based on depth
            int d0 = getImplDepth(otherImpl, context);
            unsigned int cMax = colorIndexOffset + colorIndexRange;
            if (cMax > nc0)
                colorIndexRange = nc0 - colorIndexOffset;
            ci0 = (d0 % colorIndexRange) + colorIndexOffset;
        }
    }
    if (nc0 > 0)
    {
        c0 = Ionflux::ObjectBase::nullPointerCheck(
            colors->getColor(ci0 % nc0), 
            "Node::getImplVertexAttributes", "Color");
    }
}
>>>
    return = {
        value = c0
        desc = color, or 0 if no color is specified for the node
    }
}
function.public[] = {
	spec = static
	type = void
	name = getImplMesh
	shortDesc = Get mesh
	longDesc = Get a mesh for the node implementation. One box is generated for each node. If the optional \c colors color set is specified, the vertex colors for each box are selected from the color set according to the depth level of the node. Node colors are selected according to getImplColor(). Boxes will be inset by the amount specified in \c boxInset, scaled by the size of the octree. The mesh for the node will be merged into the \c target mesh.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::GeoUtils::Mesh&
        name = target
        desc = where to store the mesh
    }
    param[] = {
        type = double
        name = boxInset
        desc = box inset per depth level
        default = Ionflux::VolGfx::Context::DEFAULT_BOX_INSET
    }
    param[] = {
        type = Ionflux::Altjira::ColorSet*
        name = colors
        desc = vertex colors
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexOffset
        desc = color index offset
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexRange
        desc = color index range
        default = 0
    }
    param[] = {
        type = int
        name = colorIndex
        desc = color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = int
        name = leafColorIndex
        desc = leaf color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively create meshes
        default = false
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplMesh", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplMesh", "Context");
NodeID nid0 = getImplNodeID(otherImpl, context);
int ci0 = colorIndex;
bool leafFlag = isImplLeaf(otherImpl);
if ((leafColorIndex >= 0) && leafFlag)
    ci0 = leafColorIndex;
if (filter != 0)
{
    int maxDepth = filter->getMaxDepth();
    int depth = getImplDepth(otherImpl, context);
    if (!context->checkDepthRange(depth, 0, maxDepth))
        return;
}
if ((filter == 0) 
    || NodeProcessor::checkFlags(
        filter->process(otherImpl), NodeFilter::RESULT_PASS))
{
    context->getVoxelMesh(nid0, target, boxInset, colors, 
        colorIndexOffset, ci0);
}
if (!recursive)
    return;
int n0 = getImplNumChildNodes(otherImpl);
for (int i = 0; i < n0; i++)
{
    NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
        getImplChildByValidIndex(otherImpl, i), 
        "Node::getImplMesh", "Child node implementation");
    getImplMesh(cn0, context, target, boxInset, colors, 
        colorIndexOffset, colorIndexRange, colorIndex, leafColorIndex, 
        filter, true);
}
>>>
}
function.public[] = {
	spec = static
	type = void
	name = getImplVertexAttributes
	shortDesc = Get vertex attributes
	longDesc = Get vertex attributes for the node implementation. If the optional \c colors color set is specified, the vertex colors for the box are selected from the color set according to the depth level of the node and the specified color offset. Boxes will be inset by the amount specified in \c boxInset, scaled by the leaf voxel size. Data will be appended to a specified vertex attributes for each target vertex attribute that is not null. Node colors are selected according to getImplColor(). If the optional \c positionOffset or \c positionScale are specified, vertex positions will be scaled or translated by these vectors.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::GeoUtils::VertexAttribute*
        name = positionTarget
        desc = target for position data
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::VertexAttribute*
        name = colorTarget
        desc = target for color data
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::VertexAttribute*
        name = normalTarget
        desc = target for normal data
        default = 0
    }
	param[] = {
	    type = Ionflux::GeoUtils::NFaceTypeID
	    name = nFaceType
	    desc = Mesh N-face type
	    default = Ionflux::GeoUtils::NFace::TYPE_FACE
	}
    param[] = {
        type = double
        name = boxInset
        desc = box inset per depth level
        default = Ionflux::VolGfx::Context::DEFAULT_BOX_INSET
    }
    param[] = {
        type = Ionflux::Altjira::ColorSet*
        name = colors
        desc = vertex colors
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexOffset
        desc = color index offset
        default = 0
    }
    param[] = {
        type = unsigned int
        name = colorIndexRange
        desc = color index range
        default = 0
    }
    param[] = {
        type = int
        name = colorIndex
        desc = color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = int
        name = leafColorIndex
        desc = leaf color index
        default = COLOR_INDEX_UNSPECIFIED
    }
    param[] = {
        type = Ionflux::VolGfx::VoxelClassColorVector*
        name = voxelClassColors
        desc = voxel class colors
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::Vector*
        name = positionOffset
        desc = position offset
        default = 0
    }
    param[] = {
        type = Ionflux::GeoUtils::Vector*
        name = positionScale
        desc = position scale
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively get vertex attributes
        default = false
    }
    param[] = {
        type = bool
        name = boundaryFacesOnly
        desc = show only boundary faces
        default = false
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplVertexAttributes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::getImplVertexAttributes", "Context");
NodeID nid0 = getImplNodeID(otherImpl, context);
if ((filter == 0) 
    || NodeProcessor::checkFlags(
        filter->process(otherImpl), NodeFilter::RESULT_PASS))
{
    // get vertex attributes for this node
    Ionflux::Altjira::Color* c0 = getImplColor(otherImpl, context, 
        colors, colorIndexOffset, colorIndexRange, colorIndex, 
        leafColorIndex, voxelClassColors);
    FaceMaskInt fm0 = FACE_ALL;
    FaceMaskInt flipFM = FACE_UNDEFINED;
    if (boundaryFacesOnly)
    {
        fm0 = getImplBoundaryFaces(otherImpl);
        flipFM = fm0;
    }
    context->getVoxelVertexAttributes(nid0, positionTarget, 
        colorTarget, normalTarget, nFaceType, boxInset, c0, 
        positionOffset, positionScale, fm0, flipFM);
}
if (filter != 0)
{
    int maxDepth = filter->getMaxDepth();
    if (!context->checkDepthRange(nid0.depth, 0, maxDepth))
        return;
}
if (!recursive)
    return;
// process child nodes recursively
int n0 = getImplNumChildNodes(otherImpl);
for (int i = 0; i < n0; i++)
{
    NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
        getImplChildByValidIndex(otherImpl, i), 
        "Node::getImplVertexAttributes", 
        "Child node implementation");
    getImplVertexAttributes(cn0, context, positionTarget, 
        colorTarget, normalTarget, nFaceType, boxInset, colors, 
        colorIndexOffset, colorIndexRange, colorIndex, leafColorIndex, 
        voxelClassColors, positionOffset, positionScale, filter, true, 
        boundaryFacesOnly);
}
>>>
}
function.public[] = {
	spec = static
	type = unsigned int
	name = getImplNumFaces
	shortDesc = Get number of faces
	longDesc = Get the number of faces for the node implementation. This is the total number of faces attached to the node or, if \c recursive is set to \c true, the hierarchy of nodes starting at this node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = bool
        name = recursive
        desc = count faces recursively
        default = false
    }
    impl = <<<
unsigned int result = 0;
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplNumFaces", "Node implementation");
NodeDataImpl* d0 = otherImpl->data;
if ((d0 != 0) 
    && (d0->type == DATA_TYPE_FACE_VEC))
{
    Ionflux::GeoUtils::FaceVector* fv0 = 
        Ionflux::ObjectBase::nullPointerCheck(
            static_cast<Ionflux::GeoUtils::FaceVector*>(d0->data));
    result += fv0->size();
}
if (recursive)
{
    int n0 = getImplNumChildNodes(otherImpl);
    for (int i = 0; i < n0; i++)
    {
        NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
            getImplChildByValidIndex(otherImpl, i), 
            "Node::getImplNumFaces", "Child node implementation");
        result += getImplNumFaces(cn0, true);
    }
}
>>>
    return = {
        value = result
        desc = Number of faces
    }
}
function.public[] = {
	spec = static
	type = double
	name = getImplFaceColorNormal
	shortDesc = Get face color/normal
	longDesc = Get the area-weighted average face color and normal for the node implementation. If \c recursive is set to \c true, the face color/normals are calculated for the hierarchy of nodes starting at this node. Colors and normals are assumed to be uniform across each face. Only the first entry in each face data set will be used.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::Altjira::Color&
        name = targetColor
        desc = target color
    }
    param[] = {
        type = Ionflux::GeoUtils::Vector3&
        name = targetNormal
        desc = target color
    }
    param[] = {
        type = bool
        name = recursive
        desc = count faces recursively
        default = false
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::getImplFaceColorNormal", "Node implementation");
NodeDataImpl* d0 = otherImpl->data;
double at0 = 0.;
double at1 = 0.;
Ionflux::GeoUtils::Vector4 c0;
Ionflux::GeoUtils::Vector3 n0;
Ionflux::GeoUtils::Vector4 c1;
Ionflux::GeoUtils::Vector3 n1;
if ((d0 != 0) 
    && (d0->type == DATA_TYPE_FACE_VEC))
{
    // process attached faces
    Ionflux::GeoUtils::FaceVector* fv0 = 
        Ionflux::ObjectBase::nullPointerCheck(
            static_cast<Ionflux::GeoUtils::FaceVector*>(d0->data), 
                "Node::getImplFaceColorNormal", "Face vector");
    for (Ionflux::GeoUtils::FaceVector::iterator i = fv0->begin(); 
        i != fv0->end(); i++)
    {
        Ionflux::GeoUtils::Face* cf0 = 
            Ionflux::ObjectBase::nullPointerCheck(*i, 
                "Node::getImplFaceColorNormal", "Face");
        double a0 = cf0->getArea();
        at0 += a0;
        // vertex colors
        Ionflux::GeoUtils::FaceData* vc0 = cf0->getVertexColors0();
        if (vc0 != 0)
        {
            Ionflux::GeoUtils::Vector4* cc0 = 
                Ionflux::GeoUtils::Vector4::upcast(vc0->getVector(0));
            if (cc0 != 0)
                c0.addIP((*cc0) * a0);
        }
        c0.multiplyIP(1. / at0);
        // vertex normals
        Ionflux::GeoUtils::FaceData* vn0 = cf0->getVertexNormals0();
        if (vn0 != 0)
        {
            Ionflux::GeoUtils::Vector3* cn0 = 
                Ionflux::GeoUtils::Vector3::upcast(vc0->getVector(0));
            if (cn0 != 0)
                n0.addIP((*cn0) * a0);
        }
        n0.multiplyIP(1. / at0);
    }
}
if (recursive)
{
    // process child nodes
    int n0 = getImplNumChildNodes(otherImpl);
    for (int i = 0; i < n0; i++)
    {
        NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
            getImplChildByValidIndex(otherImpl, i), 
            "Node::getImplNumFaces", "Child node implementation");
        Ionflux::Altjira::Color cc1;
        Ionflux::GeoUtils::Vector3 cn1;
        double ca0 = getImplFaceColorNormal(cn0, cc1, cn1);
        at1 += ca0;
        Ionflux::GeoUtils::Vector4 cc2;
        Ionflux::GeoUtils::colorToVec(cc1, cc2);
        c1.addIP(ca0 * cc2);
        n1.addIP(ca0 * cn1);
    }
    c1.multiplyIP(1. / at1);
    n1.multiplyIP(1. / at1);
}
// calculate total area-weighted color and normal
double area0 = at0 + at1;
Ionflux::GeoUtils::Vector4 c2;
c2.addIP(at0 * c0 + at1 * c1);
c2.multiplyIP(1. / area0);
Ionflux::GeoUtils::vecToColor(c2, targetColor);
targetNormal = (at0 * n0 + at1 * n1) / area0;
>>>
    return = {
        value = area0
        desc = total area of faces
    }
}
function.public[] = {
	spec = static
	type = bool
	name = voxelizeImplInsertFace
	shortDesc = Insert face for voxelization
	longDesc = Insert a face into the node hierarchy for voxelization. The face will be attached to the deepest node that completely contains its voxelization.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::GeoUtils::Face*
        name = face
        desc = face
    }
	param[] = {
	    type = Ionflux::VolGfx::SeparabilityID
	    name = sep
	    desc = separability
	    value = SEPARABILITY_26
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::voxelizeInsertImplFace", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::voxelizeInsertImplFace", "Context");
Ionflux::ObjectBase::nullPointerCheck(face, 
    "Node::voxelizeInsertImplFace", "Face");
int depth = getImplDepth(otherImpl, context);
TriangleVoxelizationData tvd0;
// NOTE: We need the triangle voxelization data for the leaf nodes here.
context->initTriangleVoxelizationData(*face, tvd0, sep);
/* <---- DEBUG ----- //
std::cerr << "[Node::voxelizeInsertImplFace] DEBUG: "
    "node: [" << getImplValueString(otherImpl, context) << "]; "
    "face: [" << face->getValueString() << "], tvd: [" 
    << getTriangleVoxelizationDataString(tvd0) << "]" 
    << std::endl;
// ----- DEBUG ----> */
if ((tvd0.node.depth < depth) 
    || (!context->locEqual(tvd0.node.loc, otherImpl->loc, depth)))
{
    // Node does not contain the voxelization.
    return false;
}
NodeImpl* cn0 = 0;
if (tvd0.node.depth > depth)
{
    // insert child node at target location and depth
    cn0 = insertImplChild(otherImpl, context, tvd0.node, fill0);
    if (cn0 == 0)
    {
        Ionflux::GeoUtils::Vector3 lv0;
        context->getVoxelLocation(tvd0.node, lv0);
        std::ostringstream status;
        status << "[Node::voxelizeInsertImplFace] "
            "Containing node implementation is null (node: [" 
                << getImplValueString(otherImpl, context) << "]; "
            << "target node: [" << tvd0.node.depth << ", (" 
            << lv0.getValueString() << ")]; "
            << "face: [" << face->getValueString() << "], tvd: [" 
            << getTriangleVoxelizationDataString(tvd0) << "]";
        throw IFVGError(status.str());
    }
} else
{
    // attach face to this node
    /* <---- DEBUG ----- //
    if (depth == 0)
    {
        std::cerr << "[Node::voxelizeInsertImplFace] DEBUG: "
            "tvd = [" << getTriangleVoxelizationDataString(tvd0) << "]" 
            << std::endl;
    }
    // ----- DEBUG ----> */
    cn0 = otherImpl;
}
NodeDataImpl* d0 = cn0->data;
if (d0 != 0)
{
    if (d0->type != DATA_TYPE_FACE_VEC)
    {
        std::ostringstream status;
        status << "[Node::voxelizeInsertImplFace] " 
            "Unexpected node data type: " 
            << getDataTypeString(d0->type) << "(" << d0->type 
            << ")";
        throw IFVGError(status.str());
    }
} else
{
    d0 = createDataImpl(DATA_TYPE_FACE_VEC);
    cn0->data = d0;
}
Ionflux::GeoUtils::FaceVector* fv0 = 
    Ionflux::ObjectBase::nullPointerCheck(
        static_cast<Ionflux::GeoUtils::FaceVector*>(d0->data), 
        "Node::voxelizeInsertImplFace", "Face vector");
fv0->push_back(face);
/* <---- DEBUG ----- //
std::cerr << "[Node::voxelizeInsertImplFace] DEBUG: "
    "appending face to node: [" << getImplValueString(cn0, context) 
    << "] (numFaces = " << fv0->size() << ")" << std::endl;
// ----- DEBUG ----> */
>>>
    return = {
        value = true
        desc = \c true if the face was inserted into the node hierarchy, \c false if the node hierarchy does not contain the face voxelization
    }
}
function.public[] = {
	spec = static
	type = unsigned int
	name = voxelizeImplInsertFaces
	shortDesc = Insert faces for voxelization
	longDesc = Insert faces from the mesh into the node hierarchy for voxelization. Each face will be attached to the deepest node that completely contains its voxelization.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = const Ionflux::GeoUtils::Mesh&
        name = mesh
        desc = mesh
    }
	param[] = {
	    type = Ionflux::VolGfx::SeparabilityID
	    name = sep
	    desc = separability
	    value = SEPARABILITY_26
	}
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes if one is missing
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::voxelizeInsertImplFaces", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::voxelizeInsertImplFaces", "Context");
unsigned int numFaces = mesh.getNumFaces();
unsigned int nf0 = 0;
for (unsigned int i = 0; i < numFaces; i++)
{
    Ionflux::GeoUtils::Face* f0 = mesh.getFace(i);
    if (f0 != 0)
    {
        if (voxelizeImplInsertFace(otherImpl, context, f0, sep, fill0))
            nf0++;
    }
}
>>>
    return = {
        value = nf0
        desc = number of faces that were inserted into the node hierarchy
    }
}
function.public[] = {
	spec = static
	type = unsigned int
	name = voxelizeImplFaces
	shortDesc = Voxelize faces
	longDesc = Voxelize faces that are attached to the node hierarchy. The voxelization data will replace any data currently attached to the nodes (including face data). Data will be generated according to the \c target parameter, at the depth level specified via the \c targetDepth parameter. If \c targetDepth is negative, the target depth is set to the maximum depth. Faces passed in via the optional \c faces parameter will be appended to the face list for the node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = Ionflux::VolGfx::NodeProcessor*
	    name = processor
	    desc = node processor
	    value = 0
	}
	param[] = {
	    type = int
	    name = targetDepth
	    desc = target depth
	    value = DEPTH_UNSPECIFIED
	}
	param[] = {
	    type = Ionflux::VolGfx::SeparabilityID
	    name = sep
	    desc = separability
	    value = SEPARABILITY_26
	}
	param[] = {
	    type = bool
	    name = fillTargetDepth
	    desc = Create a full set of child nodes at the target depth if one is missing
	    default = false
	}
	param[] = {
	    type = bool
	    name = pruneEmpty0
	    desc = Prune empty child nodes after voxelization
	    default = false
	}
	param[] = {
	    type = Ionflux::GeoUtils::FaceVector*
	    name = faces0
	    desc = additional faces
	    default = 0
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::voxelizeImplFaces", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::voxelizeImplFaces", "Context");
int maxNumLevels = context->getMaxNumLevels();
if ((targetDepth < 0) 
    || (targetDepth >= maxNumLevels))
    targetDepth = maxNumLevels - 1;
int depth = getImplDepth(otherImpl, context);
// obtain set of faces for this node
/* <---- DEBUG ----- //
std::cerr << "[Node::voxelizeImplFaces] DEBUG: "
    "node [" << getImplValueString(otherImpl, context, false) << "]: "
    "Initializing faces..." << std::endl;
// ----- DEBUG ----> */
NodeDataImpl* d0 = otherImpl->data;
Ionflux::GeoUtils::FaceVector fv0;
if (faces0 != 0)
{
    // add faces passed in to the function
    fv0.insert(fv0.end(), faces0->begin(), faces0->end());
}
if ((d0 != 0) 
    && (d0->type == DATA_TYPE_FACE_VEC))
{
    // add faces attached to this node
    Ionflux::GeoUtils::FaceVector* fv1 = 
        Ionflux::ObjectBase::nullPointerCheck(
            static_cast<Ionflux::GeoUtils::FaceVector*>(d0->data));
    fv0.insert(fv0.end(), fv1->begin(), fv1->end());
}
// voxelize faces
unsigned int numFaces = fv0.size();
unsigned int numVoxels = 0;
/* <---- DEBUG ----- //
std::cerr << "[Node::voxelizeImplFaces] DEBUG: "
    "node: [" << getImplValueString(otherImpl, context, false) << "], "
    "numFaces = " << numFaces << std::endl;
// ----- DEBUG ----> */
if (depth == targetDepth)
{
    /* voxelize on this level.
       If there is at least one face in the herarchy starting at this 
       node or passed down to this node, we can set the voxelization 
       data for this node, since all faces that were passed down have 
       already been checked by the parent node and faces contained in 
       child nodes are also contained in this node. */
    unsigned int fc0 = getImplNumFaces(otherImpl, true);
    unsigned int fc1 = numFaces + fc0;
    if (fc1 > 0)
    {
        if (processor != 0)
            processor->process(otherImpl);
        numVoxels++;
    }
} else
{
    // process child nodes
    /* <---- DEBUG ----- //
    std::cerr << "[Node::voxelizeImplFaces] DEBUG: "
        "processing child nodes (child node depth = " << (depth + 1) 
        << ")" << std::endl;
    // ----- DEBUG ----> */
    bool fill0 = false;
    bool checkBounds0 = false;
    if ((depth + 1) == targetDepth)
    {
        fill0 = fillTargetDepth;
        checkBounds0 = true;
    }
    // create triangle voxelization data
    TriangleVoxelizationData* tvd0 = 
        new TriangleVoxelizationData[numFaces];
    if (tvd0 == 0)
    {
        throw IFVGError("[Node::voxelizeImplFaces] "
            "Could not allocate triangle voxelization data.");
    }
    for (unsigned int k = 0; k < numFaces; k++)
    {
        Ionflux::GeoUtils::Face* cf = 
            Ionflux::ObjectBase::nullPointerCheck(fv0[k], 
                "Node::voxelizeImplFaces", "Face");
        TriangleVoxelizationData& ctv = tvd0[k];
        context->initTriangleVoxelizationData(*cf, ctv, sep, 
            depth + 1, checkBounds0);
        /* <---- DEBUG ----- //
        std::cerr << "[Node::voxelizeImplFaces] DEBUG: "
            "created triangle voxelization data:" << std::endl;
        printTriangleVoxelizationDataDebugInfo(ctv);
        // ----- DEBUG ----> */
    }
    // iterate over all child nodes by order index
    unsigned int n0 = context->getMaxNumLeafChildNodesPerNode();
    Ionflux::GeoUtils::Range3 r0;
    for (unsigned int i = 0; i < n0; i++)
    {
        NodeLoc3 cl0 = getImplChildLoc(otherImpl, context, i);
        context->getVoxelRange(cl0, depth + 1, r0);
        Ionflux::GeoUtils::Vector3 c0 = r0.getCenter();
        /* <---- DEBUG ----- //
        std::cerr << "[Node::voxelizeImplFaces] DEBUG: "
            "processing child node #" << std::setw(3) 
            << std::setfill('0') << i << " [depth = " 
            << (depth + 1) << ", loc = [" << getLocString(cl0) 
            << "; (" << r0.getRMin().getValueString() 
            << ")], size = " << (2. * r0.getRadius().getX0()) 
            << ", center = (" << c0.getValueString() << ")]" 
            << std::endl;
        // ----- DEBUG ----> */
        // create list of faces for child node
        Ionflux::GeoUtils::FaceVector fv2;
        bool createCN = false;
        for (unsigned int k = 0; k < numFaces; k++)
        {
            Ionflux::GeoUtils::Face* cf = fv0[k];
            TriangleVoxelizationData& ctv = tvd0[k];
            /* <---- DEBUG ----- //
            std::cerr << "[Node::voxelizeImplFaces] DEBUG: "
                "testing face: (" << cf->getValueString() << "), tvd: " 
                << std::endl;
            //printTriangleVoxelizationDataDebugInfo(ctv);
            // ----- DEBUG ----> */
            if (voxelizePointTest(ctv, c0))
            {
                /* <---- DEBUG ----- //
                std::cerr << "[Node::voxelizeImplFaces] DEBUG: "
                    "voxelize point test: true" << std::endl;
                // ----- DEBUG ----> */
                fv2.push_back(cf);
                /* create child node if it does not exist if there is 
                   at least one potential face intersection */
                createCN = true;
            } else
            {
                /* <---- DEBUG ----- //
                std::cerr << "[Node::voxelizeImplFaces] DEBUG: "
                    "voxelize point test: false" << std::endl;
                // ----- DEBUG ----> */
            }
        }
        NodeImpl* cn0 = getImplChildByOrderIndex(otherImpl, context, 
            i, createCN, fill0);
        if (cn0 != 0)
        {
            // voxelize recursively
            /* <---- DEBUG ----- //
            std::cerr << "[Node::voxelizeImplFaces] DEBUG: "
                "voxelizing child node #" << std::setw(3) 
                << std::setfill('0') << i << " [depth = " 
                << (depth + 1) << ", loc = [" << getLocString(cl0) 
                << "; (" << r0.getRMin().getValueString() 
                << ")], size = " << (2. * r0.getRadius().getX0()) 
                << ", center = (" << c0.getValueString() 
                << ")], numFaces = " << fv2.size() << std::endl;
            // ----- DEBUG ----> */
            numVoxels += voxelizeImplFaces(cn0, context, processor, 
                targetDepth, sep, fill0, pruneEmpty0, &fv2);
        }
    }
    // clean up
    delete[] tvd0;
    clearImpl(otherImpl, false, true, false);
    if (pruneEmpty0)
        pruneEmptyImpl(otherImpl, context);
}
>>>
    return = {
        value = numVoxels
        desc = number of voxels that were set
    }
}
function.public[] = {
    spec = static
    type = unsigned int
    name = getImplMemSize
    shortDesc = Get node implementation allocated size
    longDesc = Get the allocated size in memory for a node implementation, including the size of the allocated data.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively calculate allocated size
        default = false
    }
    impl = <<<
if (otherImpl == 0)
    return 0;
unsigned int s0 = sizeof(NodeImpl) 
    + getDataImplMemSize(otherImpl->data);
int n0 = otherImpl->valid.count();
if (n0 > 0)
{
    NodeImpl* cp = otherImpl->child;
    if (cp != 0)
    {
        s0 += (n0 * sizeof(NodeImpl*));
        if (recursive)
        {
            for (int i = 0; i < n0; i++)
            {
                NodeImpl& cn = cp[i];
                s0 += getImplMemSize(&cn, true);
            }
        }
    }
}
>>>
    return = {
        value = s0
        desc = allocated size of the node implementation
    }
}
function.public[] = {
    spec = static
    type = void
    name = serializeDataImpl
    shortDesc = Serialize data implementation
    longDesc = Serialize data implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeDataImpl*
        name = dataImpl
        desc = Node data implementation
    }
    param[] = {
        type = std::string&
        name = target
        desc = where to store the serialized data
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(dataImpl, 
    "Node::serializeDataImpl", "Node data implementation");
Ionflux::ObjectBase::pack(MAGIC_SYLLABLE_BASE, MAGIC_SYLLABLE_DATA, 
    target, true);
pack(*dataImpl, target, true);
>>>
}
function.public[] = {
    spec = static
    type = Ionflux::ObjectBase::DataSize
    name = getDataValueSerializedSize
    shortDesc = Get serialized size of data value
    longDesc = Get the serialized size of a single data value.
    impl = <<<
std::string t0;
NodeDataValue v0 = 0.;
Ionflux::ObjectBase::pack(v0, t0);
>>>
    return = {
        value = t0.size()
        desc = serialized size of data value
    }
}
function.public[] = {
    spec = static
    type = Ionflux::ObjectBase::DataSize
    name = getDataImplSerializedSize
    shortDesc = Get serialized size of data implementation
    longDesc = Get the serialized size of a data implementation of the specified type.
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = t
        desc = Node data type
        default = DATA_TYPE_NULL
    }
    impl = <<<
if (t == DATA_TYPE_UNKNOWN)
{
    throw IFVGError(Ionflux::ObjectBase::getErrorString(
        "Data type 'unknown' does not have a serialized size.", 
        "Node::getDataImplSerializedSize"));
}
std::string t0;
Ionflux::ObjectBase::pack(MAGIC_SYLLABLE_BASE, MAGIC_SYLLABLE_DATA, 
    t0, true);
NodeDataImpl* d0 = createDataImpl(DATA_TYPE_NULL);
pack(*d0, t0, true);
delete d0;
Ionflux::ObjectBase::DataSize n0 = t0.size();
if ((t == DATA_TYPE_DENSITY) 
    || (t == DATA_TYPE_COLOR_RGBA) 
    || (t == DATA_TYPE_DISTANCE_8) 
    || (t == DATA_TYPE_COLOR_NORMAL))
{
    // array types
    Ionflux::ObjectBase::DataSize n1 = getDataTypeNumElements(t);
    Ionflux::ObjectBase::DataSize n2 = 0;
    if (n1 != Ionflux::ObjectBase::DATA_SIZE_INVALID)
        n2 = getDataValueSerializedSize();
    return n0 + n1 * n2;
} else
if (t == DATA_TYPE_VOXEL_CLASS)
{
    // voxel class
    return n0 + sizeof(VoxelClassID);
} else
if (t == DATA_TYPE_VOXEL_IOB)
{
    // voxel inside/outside/boundary
    VoxelDataIOB d0 = createVoxelDataIOB();
    pack(d0, t0, false);
    return n0 + t0.size();
}
>>>
    return = {
        value = 0
        desc = serialized size of node data implementation
    }
}
function.public[] = {
    spec = static
    type = Ionflux::ObjectBase::DataSize
    name = deserializeDataImpl
    shortDesc = Deserialize data implementation
    longDesc = Deserialize data implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeDataImpl*
        name = dataImpl
        desc = Node data implementation
    }
    param[] = {
        type = const std::string&
        name = source
        desc = serialized data
    }
    param[] = {
        type = Ionflux::ObjectBase::DataSize
        name = offset
        desc = deserialization offset
        default = 0
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(dataImpl, 
    "Node::deserializeDataImpl", "Node data implementation");
// Magic word check
Ionflux::ObjectBase::DataSize o0 = 
    Ionflux::ObjectBase::unpackAndCheckMagicWord(source, 
        MAGIC_SYLLABLE_BASE, MAGIC_SYLLABLE_DATA, offset, 0, 
        "Node::deserializeDataImpl");
// unpack the data
o0 = unpack(source, *dataImpl, o0);
if (o0 == Ionflux::ObjectBase::DATA_SIZE_INVALID)
{
    std::ostringstream status;
    status << "Could not deserialize node data implementation (" 
        "offset = " << offset << ", source.size = " << source.size() 
        << ").";
    throw IFVGError(Ionflux::ObjectBase::getErrorString(
        status.str(), "Node::deserializeDataImpl"));
}
>>>
    return = {
        value = o0
        desc = offset of remaining data
    }
}
function.public[] = {
    bindings.disable = true
    spec = static
    type = void
    name = deserializeDataImpl
    shortDesc = Deserialize node data implementation
    longDesc = Deserialize a node data implementation from the specified stream.
    param[] = {
        type = Ionflux::VolGfx::NodeDataImpl*
        name = dataImpl
        desc = Node data implementation
    }
    param[] = {
        type = std::istream&
        name = source
        desc = data source
    }
    param[] = {
        type = Ionflux::ObjectBase::DataSize
        name = offset
        desc = offset
        default = Ionflux::ObjectBase::DATA_SIZE_INVALID
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap*
        name = poMapCurrent
        desc = pointer/offset map (current)
        default = 0
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(dataImpl, 
    "Node::deserializeDataImpl", "Node data implementation");
if (offset != Ionflux::ObjectBase::DATA_SIZE_INVALID)
{
    source.seekg(offset);
    if (!source.good())
    {
        std::ostringstream status;
        status << "Invalid stream offset: " << offset;
        throw IFVGError(Ionflux::ObjectBase::getErrorString(
            status.str(), "Node::deserializeDataImpl"));
    }
} else
    offset = source.tellg();
std::streampos p0 = source.tellg();
// Magic word check
std::string t0;
Ionflux::ObjectBase::readFromStream(source, t0, 
    sizeof(Ionflux::ObjectBase::MagicWord));
Ionflux::ObjectBase::unpackAndCheckMagicWord(t0, 
    MAGIC_SYLLABLE_BASE, MAGIC_SYLLABLE_DATA, 0, 0, 
    "Node::deserializeDataImpl");
// unpack data type
NodeDataType dt0 = Node::DATA_TYPE_UNKNOWN;
Ionflux::ObjectBase::readFromStream(source, t0, sizeof(NodeDataType));
Ionflux::ObjectBase::unpack(t0, dt0, 0);
Ionflux::ObjectBase::DataSize s0 = getDataImplSerializedSize(dt0);
// deserialize data
source.seekg(p0);
Ionflux::ObjectBase::readFromStream(source, t0, s0);
deserializeDataImpl(dataImpl, t0, 0);
if (poMapCurrent != 0)
{
    // update the current pointer/offset map
    Ionflux::ObjectBase::GenericPointer dp0 = 
        static_cast<Ionflux::ObjectBase::GenericPointer>(dataImpl);
    (*poMapCurrent)[dp0] = offset;
}
>>>
}
function.public[] = {
    spec = static
    type = void
    name = deserializeDataImpl
    shortDesc = Deserialize node data implementation
    longDesc = Deserialize a node data implementation from the specified stream.
    param[] = {
        type = Ionflux::VolGfx::NodeDataImpl*
        name = dataImpl
        desc = Node data implementation
    }
    param[] = {
        type = Ionflux::VolGfx::IOContext&
        name = ioContext
        desc = I/O context
    }
    param[] = {
        type = Ionflux::ObjectBase::DataSize
        name = offset
        desc = offset
        default = Ionflux::ObjectBase::DATA_SIZE_INVALID
    }
    impl = <<<
std::istream* source = Ionflux::ObjectBase::nullPointerCheck(
    ioContext.getInputStream(), "Node::deserializeDataImpl", 
    "Input stream");
deserializeDataImpl(dataImpl, *source, offset, 
    ioContext.getPoMapCurrent());
>>>
}
function.public[] = {
    spec = static
    type = void
    name = serializeImpl
    shortDesc = Serialize node implementation
    longDesc = Serialize node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = std::string&
        name = target
        desc = where to store the serialized data
    }
    param[] = {
        type = Ionflux::ObjectBase::MagicSyllable
        name = magicSyllable
        desc = magic syllable to be used to indicate the node type
        default = MAGIC_SYLLABLE_NODE
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::serializeImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::serializeImpl", "Context");
Ionflux::ObjectBase::pack(MAGIC_SYLLABLE_BASE, magicSyllable, 
    target, true);
pack(*otherImpl, target, true);
>>>
}
function.public[] = {
    bindings.disable = true
    spec = static
    type = void
    name = serializeImplChildNodes
    shortDesc = Serialize child node implementations
    longDesc = Serialize child node implementations of the specified node implementation. Child node implementations will be serialized in order of increasing depth, between the minimum and maximum depth specified. If \c recursive is set to \c true, child node implementations will be serialized recursively. Offsets for the child node implementations will be stored in the pointer/offset map.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = std::ostream&
        name = target
        desc = where to store the serialized data
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap&
        name = poMap
        desc = pointer/offset map
    }
    param[] = {
        type = int
        name = minDepth
        desc = minimum depth
        default = 1
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth
        default = DEPTH_UNSPECIFIED
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively serialize child node implementations
        default = true
    }
    param[] = {
        type = bool
        name = serializeData
        desc = serialize child node data
        default = true
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::serializeImplChildNodes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::serializeImplChildNodes", "Context");
int depth = getImplDepth(otherImpl, context);
int maxNumLevels = context->getMaxNumLevels();
if (minDepth < 1)
{
    // There are no child nodes on level 0.
    minDepth = 1;
}
if ((maxDepth == DEPTH_UNSPECIFIED) 
    || (maxDepth >= maxNumLevels))
    maxDepth = maxNumLevels - 1;
if (minDepth > maxDepth)
    return;
if (depth > maxDepth)
    return;
if ((depth < minDepth)
    && (!recursive))
    return;
NodeImplQueue q0;
q0.push_back(otherImpl);
std::string t0;
Ionflux::ObjectBase::DataSize offset = target.tellp();
while (!q0.empty())
{
    NodeImpl* ci = q0.front();
    q0.pop_front();
    int d0 = getImplDepth(ci, context);
    if ((d0 >= minDepth) 
        && (d0 <= maxDepth))
    {
        /* <---- DEBUG ----- //
        std::cout << "[Node::serializeImplHierarchy] DEBUG: "
            "serializing node implementation: " << ci << " (depth = " 
            << d0 << ", offset = " << offset << ")." << std::endl;
        // ----- DEBUG ----> */
        // serialize node implementation
        poMap[ci] = offset;
        serializeImpl(ci, context, t0, MAGIC_SYLLABLE_NODE);
        target.write(t0.c_str(), t0.size());
        offset += t0.size();
        t0.assign("");
        // serialize node data
        if ((ci->data != 0) 
            && serializeData)
        {
            /* <---- DEBUG ----- //
            std::cout << "[Node::serializeImplHierarchy] DEBUG: "
                "serializing node data: " << ci->data 
                << ", offset = " << offset << ")." << std::endl;
            // ----- DEBUG ----> */
            poMap[ci->data] = offset;
            serializeDataImpl(ci->data, t0);
            target.write(t0.c_str(), t0.size());
            offset += t0.size();
            t0.assign("");
        }
    }
    if ((d0 < maxDepth) 
        && recursive)
    {
        // enqueue child nodes
        int n0 = getImplNumChildNodes(ci);
        for (int i = 0; i < n0; i++)
        {
            NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
                getImplChildByValidIndex(ci, i), 
                "Node::serializeImplChildNodes", 
                "Child node implementation");
            /* <---- DEBUG ----- //
            std::cout << "[Node::serializeImplHierarchy] DEBUG: "
                "enqueuing child node: " << cn0 << " (depth = " 
                << (d0 + 1) << ")" << std::endl;
            // ----- DEBUG ----> */
            q0.push_back(cn0);
        }
    }
}
>>>
}
function.public[] = {
    spec = static
    type = void
    name = serializeImplChildNodes
    shortDesc = Serialize child node implementations
    longDesc = Serialize child node implementations of the specified node implementation. Child node implementations will be serialized in order of increasing depth, between the minimum and maximum depth specified. If \c recursive is set to \c true, child node implementations will be serialized recursively. Offsets for the child node implementations will be stored in the pointer/offset map.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::IOContext&
        name = ioContext
        desc = I/O context
    }
    param[] = {
        type = int
        name = minDepth
        desc = minimum depth
        default = 1
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth
        default = DEPTH_UNSPECIFIED
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively serialize child node implementations
        default = true
    }
    param[] = {
        type = bool
        name = serializeData
        desc = serialize child node data
        default = true
    }
    impl = <<<
std::ostream* target = Ionflux::ObjectBase::nullPointerCheck(
    ioContext.getOutputStream(), "Node::serializeImplChildNodes", 
    "Output stream");
Ionflux::ObjectBase::PointerOffsetMap* poMap = 
    Ionflux::ObjectBase::nullPointerCheck(
        ioContext.getPoMapSerialized(), 
    "Node::serializeImplChildNodes", 
    "Pointer/offset map (serialized)");
serializeImplChildNodes(otherImpl, context, *target, *poMap, minDepth, 
    maxDepth, recursive, serializeData);
>>>
}
function.public[] = {
    spec = static
    type = Ionflux::ObjectBase::DataSize
    name = getImplSerializedSize
    shortDesc = Get serialized size of node implementation
    longDesc = Get the serialized size of a node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeDataType
        name = t
        desc = Node data type
        default = DATA_TYPE_NULL
    }
    impl = <<<
std::string t0;
Ionflux::ObjectBase::pack(MAGIC_SYLLABLE_BASE, MAGIC_SYLLABLE_NODE, 
    t0, true);
NodeImpl* n0 = createImpl();
pack(*n0, t0, true);
delete n0;
>>>
    return = {
        value = t0.size()
        desc = serialized size of node implementation
    }
}
function.public[] = {
    bindings.disable = true
    spec = static
    type = void
    name = serializeImplHierarchy
    shortDesc = Serialize node implementation hierarchy
    longDesc = Serialize the node implementation hierarchy of which the specified node is the root node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = std::ostream&
        name = target
        desc = where to store the serialized data
    }
    param[] = {
        type = Ionflux::VolGfx::NodeImplHierarchyHeader*
        name = header
        desc = where to store the header
        default = 0
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap*
        name = poMap
        desc = where to store the pointer/offset map
        default = 0
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::serializeImplHierarchy", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::serializeImplHierarchy", "Context");
Ionflux::ObjectBase::DataSize offset = 0;
// header
std::string t0;
Ionflux::ObjectBase::pack(MAGIC_SYLLABLE_BASE, MAGIC_SYLLABLE_HEADER, 
    t0, true);
// pointer/offset map offset to be set later
Ionflux::ObjectBase::DataSize poMapOffsetPos = t0.size();
NodeImplHierarchyHeader* header0 = 0;
if (header == 0)
{
    header0 = Ionflux::ObjectBase::create<NodeImplHierarchyHeader>(
        "Node::serializeImplHierarchy", "header");
    header = header0;
}
header->poMapOffset = 0;
header->implArrayStride = 
    static_cast<Ionflux::ObjectBase::UInt16>(
        getImplArrayStride());
header->implSize = 
    static_cast<Ionflux::ObjectBase::UInt16>(
        getImplSerializedSize());
header->dataImplSize = 
    static_cast<Ionflux::ObjectBase::UInt16>(
        getDataImplSerializedSize());
header->dataValueSize = 
    static_cast<Ionflux::ObjectBase::UInt8>(
        getDataValueSerializedSize());
header->rootNodeDepth = 
    static_cast<Ionflux::ObjectBase::UInt8>(
        getImplDepth(otherImpl, context));
header->rootNodePointer = 
    static_cast<Ionflux::ObjectBase::GenericPointer>(otherImpl);
pack(*header, t0, true);
target.write(t0.c_str(), t0.size());
offset += t0.size();
t0.assign("");
// root node
/* <---- DEBUG ----- //
std::cout << "[Node::serializeImplHierarchy] DEBUG: "
    "root node: " << otherImpl << std::endl;
// ----- DEBUG ----> */
Ionflux::ObjectBase::PointerOffsetMap* poMap0 = 0;
if (poMap == 0)
{
    poMap0 = Ionflux::ObjectBase::create<
        Ionflux::ObjectBase::PointerOffsetMap>(
            "Node::serializeImplHierarchy", 
            "pointer/offset map (serialized)");
    poMap = poMap0;
}
(*poMap)[otherImpl] = offset;
serializeImpl(otherImpl, context, t0, MAGIC_SYLLABLE_ROOT);
target.write(t0.c_str(), t0.size());
offset += t0.size();
t0.assign("");
// root node data
if (otherImpl->data != 0)
{
    /* <---- DEBUG ----- //
    std::cout << "[Node::serializeImplHierarchy] DEBUG: "
        "root node data: " << otherImpl->data << std::endl;
    // ----- DEBUG ----> */
    (*poMap)[otherImpl->data] = offset;
    serializeDataImpl(otherImpl->data, t0);
    target.write(t0.c_str(), t0.size());
    offset += t0.size();
    t0.assign("");
}
// serialize child nodes.
serializeImplChildNodes(otherImpl, context, target, *poMap);
offset = target.tellp();
// pointer/offset map
header->poMapOffset = offset;
Ionflux::ObjectBase::pack(MAGIC_SYLLABLE_BASE, 
    MAGIC_SYLLABLE_OFFSET_MAP, t0, false);
Ionflux::ObjectBase::pack(*poMap, t0, true);
target.write(t0.c_str(), t0.size());
std::streampos p0 = target.tellp();
Ionflux::ObjectBase::pack(header->poMapOffset, t0, false);
Ionflux::ObjectBase::writeToStream(target, t0, poMapOffsetPos);
target.seekp(p0);
// clean up
if (header0 != 0)
    delete header0;
header0 = 0;
if (poMap0 != 0)
    delete poMap0;
poMap0 = 0;
>>>
}
function.public[] = {
    spec = static
    type = void
    name = serializeImplHierarchy
    shortDesc = Serialize node implementation hierarchy
    longDesc = Serialize the node implementation hierarchy of which the specified node is the root node.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::IOContext&
        name = ioContext
        desc = I/O context
    }
    impl = <<<
std::ostream* target = Ionflux::ObjectBase::nullPointerCheck(
    ioContext.getOutputStream(), "Node::serializeImplHierarchy", 
    "Output stream");
Ionflux::ObjectBase::PointerOffsetMap* poMap = 
    Ionflux::ObjectBase::nullPointerCheck(
        ioContext.getPoMapSerialized(), 
    "Node::serializeImplHierarchy", 
    "Pointer/offset map (serialized)");
NodeImplHierarchyHeader header;
serializeImplHierarchy(otherImpl, context, *target, &header, poMap);
ioContext.setHeader(header);
>>>
}
function.public[] = {
    spec = static
    type = Ionflux::ObjectBase::DataSize
    name = getImplHierarchyHeaderSerializedSize
    shortDesc = Get serialized size of node implementation hierarchy header
    longDesc = Get the serialized size of a node implementation hierarchy header.
    impl = <<<
std::string t0;
NodeImplHierarchyHeader h0;
pack(h0, t0, true);
>>>
    return = {
        value = t0.size() + sizeof(Ionflux::ObjectBase::MagicWord)
        desc = serialized size of node implementation
    }
}
function.public[] = {
    spec = static
    type = Ionflux::ObjectBase::DataSize
    name = deserializeImpl
    shortDesc = Deserialize node implementation
    longDesc = Deserialize node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = const std::string&
        name = source
        desc = serialized data
    }
    param[] = {
        type = Ionflux::ObjectBase::DataSize
        name = offset
        desc = deserialization offset
        default = 0
    }
    param[] = {
        type = Ionflux::ObjectBase::MagicSyllable
        name = magicSyllable
        desc = magic syllable to be used to indicate the node type
        default = MAGIC_SYLLABLE_NODE
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::deserializeImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::deserializeImpl", "Context");
// Magic word check
Ionflux::ObjectBase::DataSize o0 = 
    Ionflux::ObjectBase::unpackAndCheckMagicWord(source, 
        MAGIC_SYLLABLE_BASE, magicSyllable, offset, 0, 
        "Node::deserializeImpl");
// unpack the node
clearImpl(otherImpl, true, true, true);
o0 = unpack(source, *otherImpl, o0);
if (o0 == Ionflux::ObjectBase::DATA_SIZE_INVALID)
{
    std::ostringstream status;
    status << "Could not deserialize node implementation (" 
        "offset = " << offset << ", source.size = " << source.size() 
        << ").";
    throw IFVGError(Ionflux::ObjectBase::getErrorString(
        status.str(), "Node::deserializeImpl"));
}
>>>
    return = {
        value = o0
        desc = offset of remaining data
    }
}
function.public[] = {
    bindings.disable = true
    spec = static
    type = void
    name = deserializeImpl
    shortDesc = Deserialize node implementation
    longDesc = Deserialize node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = std::istream&
        name = source
        desc = source stream
    }
    param[] = {
        type = const Ionflux::VolGfx::NodeImplHierarchyHeader&
        name = header
        desc = node implementation hierarchy header
    }
    param[] = {
        type = const Ionflux::ObjectBase::PointerOffsetMap&
        name = poMap
        desc = pointer/offset map
    }
    param[] = {
        type = Ionflux::ObjectBase::DataSize
        name = offset
        desc = deserialization offset
        default = Ionflux::ObjectBase::DATA_SIZE_INVALID
    }
    param[] = {
        type = Ionflux::ObjectBase::MagicSyllable
        name = magicSyllable
        desc = magic syllable to be used to indicate the node type
        default = MAGIC_SYLLABLE_NODE
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap*
        name = poMapCurrent
        desc = pointer/offset map (current)
        default = 0
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize node data
        default = true
    }
    param[] = {
        type = bool
        name = zeroChildPointer
        desc = zero the child pointer
        default = true
    }
    param[] = {
        type = bool
        name = zeroParentPointer
        desc = zero the parent pointer
        default = true
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::deserializeImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::deserializeImpl", "Context");
if (offset != Ionflux::ObjectBase::DATA_SIZE_INVALID)
{
    source.seekg(offset);
    if (!source.good())
    {
        std::ostringstream status;
        status << "Invalid stream offset: " << offset;
        throw IFVGError(Ionflux::ObjectBase::getErrorString(
            status.str(), "Node::deserializeImpl"));
    }
} else
    offset = source.tellg();
// Magic word check
std::string t0;
Ionflux::ObjectBase::readFromStream(source, t0, 
    sizeof(Ionflux::ObjectBase::MagicWord) + header.implSize);
Ionflux::ObjectBase::DataSize o0 = 
    Ionflux::ObjectBase::unpackAndCheckMagicWord(t0, 
        MAGIC_SYLLABLE_BASE, magicSyllable, 0, 0, 
        "Node::deserializeImpl");
// unpack node implementation
unpack(t0, *otherImpl, o0);
/* NOTE: Set parent/child node pointers to null to prevent accesses 
         into unallocated memory. */
if (zeroChildPointer)
    otherImpl->child = 0;
if (zeroParentPointer)
    otherImpl->parent = 0;
if (poMapCurrent != 0)
{
    // update the current pointer/offset map
    Ionflux::ObjectBase::GenericPointer np0 = 
        static_cast<Ionflux::ObjectBase::GenericPointer>(otherImpl);
    (*poMapCurrent)[np0] = offset;
}
NodeDataImpl* dp0 = otherImpl->data;
otherImpl->data = 0;
if ((dp0 != 0) 
    && (deserializeData))
{
    // unpack node data
    Ionflux::ObjectBase::DataSize do0 = 
        Ionflux::ObjectBase::checkedLookup(poMap, 
            static_cast<Ionflux::ObjectBase::GenericPointer>(dp0), 
            "Node::deserializeImpl", "Node data offset");
    dp0 = createDataImpl(DATA_TYPE_NULL);
    deserializeDataImpl(dp0, source, do0, poMapCurrent);
    otherImpl->data = dp0;
}
>>>
}
function.public[] = {
    spec = static
    type = void
    name = deserializeImpl
    shortDesc = Deserialize node implementation
    longDesc = Deserialize node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::IOContext&
        name = ioContext
        desc = I/O context
    }
    param[] = {
        type = Ionflux::ObjectBase::DataSize
        name = offset
        desc = deserialization offset
        default = Ionflux::ObjectBase::DATA_SIZE_INVALID
    }
    param[] = {
        type = Ionflux::ObjectBase::MagicSyllable
        name = magicSyllable
        desc = magic syllable to be used to indicate the node type
        default = MAGIC_SYLLABLE_NODE
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize node data
        default = true
    }
    param[] = {
        type = bool
        name = zeroChildPointer
        desc = zero the child pointer
        default = true
    }
    param[] = {
        type = bool
        name = zeroParentPointer
        desc = zero the parent pointer
        default = true
    }
    impl = <<<
std::istream* source = Ionflux::ObjectBase::nullPointerCheck(
    ioContext.getInputStream(), "Node::deserializeImpl", 
    "Input stream");
Ionflux::ObjectBase::PointerOffsetMap* poMap = 
    Ionflux::ObjectBase::nullPointerCheck(
        ioContext.getPoMapSerialized(), 
    "Node::deserializeImpl", 
    "Pointer/offset map (serialized)");
Ionflux::ObjectBase::PointerOffsetMap* poMapCurrent = 
    Ionflux::ObjectBase::nullPointerCheck(
        ioContext.getPoMapCurrent(), 
    "Node::deserializeImpl", 
    "Pointer/offset map (current)");
NodeImplHierarchyHeader header = ioContext.getHeader();
deserializeImpl(otherImpl, context, *source, header, *poMap, offset, 
    magicSyllable, poMapCurrent, deserializeData, zeroChildPointer, 
    zeroParentPointer);
>>>
}
function.public[] = {
    bindings.disable = true
    spec = static
    type = void
    name = deserializeImplChildNodes
    shortDesc = Deserialize child node implementations
    longDesc = <<<
Deserialize child node implementations of the node implementation with the specified serialized child pointer from the source stream. Deserialized child node implementations will be added as descendants of the specified node implementation. Child node implementations will be deserialized up to the maximum depth specified. If \c recursive is set to \c true, child node implementations will be serialized recursively. Offsets for the child node implementations will be obtained from the pointer/offset map. \c magicSyllable will be used for extracting the node implementation at the specified stream offset. For all other node implementations, MAGIC_SYLLABLE_NODE will be used.

\note This function requires \c otherImpl to be the deserialized node implementation data, with a zero child pointer, corresponding to \c childPointer. The original node data for this node will not be read from the stream. To use any existing node as the target node implementation, use the version of deserializeImplChildNodes() that takes a stream offset as a parameter.
>>>
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = std::istream&
        name = source
        desc = source stream
    }
    param[] = {
        type = Ionflux::ObjectBase::GenericPointer
        name = childPointer
        desc = serialized child pointer
    }
    param[] = {
        type = const Ionflux::VolGfx::NodeImplHierarchyHeader&
        name = header
        desc = node implementation hierarchy header
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap&
        name = poMap
        desc = pointer/offset map
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap*
        name = poMapCurrent
        desc = pointer/offset map (current)
        default = 0
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth
        default = DEPTH_UNSPECIFIED
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively deserialize child node implementations
        default = true
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize child node data
        default = true
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::deserializeImplChildNodes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::deserializeImplChildNodes", "Context");
int depth = getImplDepth(otherImpl, context);
int maxNumLevels = context->getMaxNumLevels();
if ((maxDepth == DEPTH_UNSPECIFIED) 
    || (maxDepth >= maxNumLevels))
    maxDepth = maxNumLevels - 1;
if (depth >= maxDepth)
    return;
/* <---- DEBUG ----- //
std::cout << "[Node::deserializeImplChildNodes] DEBUG: "
    "node: " << getImplValueString(otherImpl, context, false) 
    << std::endl;
// ----- DEBUG ----> */
NodeImpl* cp0 = static_cast<NodeImpl*>(childPointer);
if (otherImpl->child != 0)
{
    throw IFVGError("[Node::deserializeImplChildNodes] "
        "Node implementation has non-zero child node pointer.");
}
int n0 = getImplNumChildNodes(otherImpl);
// allocate new child node array
NodeImpl* cp1 = new NodeImpl[n0];
if (cp1 == 0)
{
    throw IFVGError("Node::deserializeImplChildNodes"
        "Could not allocate child node implementations.");
}
Ionflux::ObjectBase::UInt64 cpi0 = 
    reinterpret_cast<Ionflux::ObjectBase::UInt64>(cp0);
for (int i = 0; i < n0; i++)
{
    Ionflux::ObjectBase::GenericPointer cpc0 = 
        reinterpret_cast<Ionflux::ObjectBase::GenericPointer>(cpi0);
    Ionflux::ObjectBase::PointerOffsetMap::const_iterator poi0 = 
        poMap.find(cpc0);
    if (poi0 == poMap.end())
    {
        std::ostringstream status;
        status << "Offset not found for child node implementation "
            "(child pointer = " << cp0 << ", child node = " 
            << cpc0 << ", implArrayStride = " << header.implArrayStride 
            << ").";
        throw IFVGError(Ionflux::ObjectBase::getErrorString(
            status.str(), "Node::deserializeImplChildNodes"));
    }
    Ionflux::ObjectBase::DataSize co0 = (*poi0).second;
    NodeImpl* cc0 = &(cp1[i]);
    // refCount not set by deserializeImpl()
    cc0->refCount = 0;
    // This reference will be cleared by clearImpl().
    refImpl(cc0);
    deserializeImpl(cc0, context, source, header, poMap, co0, 
        MAGIC_SYLLABLE_NODE, poMapCurrent, deserializeData, false, 
        true);
    cp0 = cc0->child;
    cc0->child = 0;
    if (recursive)
    {
        // deserialize child nodes recursively
        deserializeImplChildNodes(cc0, context, source, 
            static_cast<Ionflux::ObjectBase::GenericPointer>(cp0), 
            header, poMap, poMapCurrent, maxDepth, true, 
            deserializeData);
    }
    cpi0 += header.implArrayStride;
}
otherImpl->child = cp1;
setImplParent(otherImpl);
>>>
}
function.public[] = {
    spec = static
    type = void
    name = deserializeImplChildNodes
    shortDesc = Deserialize child node implementations
    longDesc = <<<
Deserialize child node implementations of the node implementation with the specified serialized child pointer from the source stream. Deserialized child node implementations will be added as descendants of the specified node implementation. Child node implementations will be deserialized up to the maximum depth specified. If \c recursive is set to \c true, child node implementations will be serialized recursively. Offsets for the child node implementations will be obtained from the pointer/offset map. \c magicSyllable will be used for extracting the node implementation at the specified stream offset. For all other node implementations, MAGIC_SYLLABLE_NODE will be used.

\note This function requires \c otherImpl to be the deserialized node implementation data, with a zero child pointer, corresponding to \c childPointer. The original node data for this node will not be read from the stream. To use any existing node as the target node implementation, use the version of deserializeImplChildNodes() that takes a stream offset as a parameter.
>>>
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::IOContext&
        name = ioContext
        desc = I/O context
    }
    param[] = {
        type = Ionflux::ObjectBase::GenericPointer
        name = childPointer
        desc = serialized child pointer
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth
        default = DEPTH_UNSPECIFIED
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively deserialize child node implementations
        default = true
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize child node data
        default = true
    }
    impl = <<<
std::istream* source = Ionflux::ObjectBase::nullPointerCheck(
    ioContext.getInputStream(), "Node::deserializeImplChildNodes", 
    "Input stream");
Ionflux::ObjectBase::PointerOffsetMap* poMap = 
    Ionflux::ObjectBase::nullPointerCheck(
        ioContext.getPoMapSerialized(), 
    "Node::deserializeImplChildNodes", 
    "Pointer/offset map (serialized)");
Ionflux::ObjectBase::PointerOffsetMap* poMapCurrent = 
    Ionflux::ObjectBase::nullPointerCheck(
        ioContext.getPoMapCurrent(), 
    "Node::deserializeImplChildNodes", 
    "Pointer/offset map (current)");
NodeImplHierarchyHeader header = ioContext.getHeader();
deserializeImplChildNodes(otherImpl, context, *source, childPointer, 
    header, *poMap, poMapCurrent, maxDepth, recursive, deserializeData);
>>>
}
function.public[] = {
    bindings.disable = true
    spec = static
    type = void
    name = deserializeImplChildNodes
    shortDesc = Deserialize child node implementations
    longDesc = <<<
Deserialize child node implementations of the node implementation with the specified stream offset from the source stream. Deserialized child node implementations will be added as descendants of the specified node implementation. Child node implementations will be deserialized up to the maximum depth specified. If \c recursive is set to \c true, child node implementations will be serialized recursively. Offsets for the child node implementations will be obtained from the pointer/offset map. \c magicSyllable will be used for extracting the node implementation at the specified stream offset. For all other node implementations, MAGIC_SYLLABLE_NODE will be used.

\note This function will read the original node implementation data from the stream and initialize \c otherImpl accordingly.
>>>
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = std::istream&
        name = source
        desc = source stream
    }
    param[] = {
        type = Ionflux::ObjectBase::DataSize
        name = offset
        desc = stream offset of the node implementation
    }
    param[] = {
        type = const Ionflux::VolGfx::NodeImplHierarchyHeader&
        name = header
        desc = node implementation hierarchy header
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap&
        name = poMap
        desc = pointer/offset map
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap*
        name = poMapCurrent
        desc = pointer/offset map (current)
        default = 0
    }
    param[] = {
        type = Ionflux::ObjectBase::MagicSyllable
        name = magicSyllable
        desc = magic syllable to be used to indicate the node type
        default = MAGIC_SYLLABLE_NODE
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth
        default = DEPTH_UNSPECIFIED
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively deserialize child node implementations
        default = true
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize child node data
        default = true
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::deserializeImplChildNodes", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::deserializeImplChildNodes", "Context");
int depth = getImplDepth(otherImpl, context);
int maxNumLevels = context->getMaxNumLevels();
if ((maxDepth == DEPTH_UNSPECIFIED) 
    || (maxDepth >= maxNumLevels))
    maxDepth = maxNumLevels - 1;
if (depth >= maxDepth)
    return;
// get the child node pointer from the stream
NodeImpl* cn0 = createImpl();
refImpl(cn0);
deserializeImpl(cn0, context, source, header, poMap, offset, 
    magicSyllable, poMapCurrent, true, false, true);
// <---- DEBUG ----- //
std::cout << "[Node::deserializeImplChildNodes] DEBUG: "
    "node: " << getImplValueString(cn0, context, false) 
    << std::endl;
// ----- DEBUG ----> */
NodeImpl* cp0 = cn0->child;
cn0->child = 0;
int n0 = getImplNumChildNodes(cn0);
if (n0 == 0)
{
    // node has no child nodes.
    return;
}
deserializeImplChildNodes(cn0, context, source, 
    static_cast<Ionflux::ObjectBase::GenericPointer>(cp0), header, 
    poMap, poMapCurrent, maxDepth, recursive, deserializeData);
clearImpl(otherImpl, true, true, true);
copyImpl(*cn0, *otherImpl, true);
setImplParent(otherImpl);
unrefImpl(cn0);
>>>
}
function.public[] = {
    spec = static
    type = void
    name = deserializeImplChildNodes
    shortDesc = Deserialize child node implementations
    longDesc = <<<
Deserialize child node implementations of the node implementation with the specified stream offset from the source stream. Deserialized child node implementations will be added as descendants of the specified node implementation. Child node implementations will be deserialized up to the maximum depth specified. If \c recursive is set to \c true, child node implementations will be serialized recursively. Offsets for the child node implementations will be obtained from the pointer/offset map. \c magicSyllable will be used for extracting the node implementation at the specified stream offset. For all other node implementations, MAGIC_SYLLABLE_NODE will be used.

\note This function will read the original node implementation data from the stream and initialize \c otherImpl accordingly.
>>>
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::IOContext&
        name = ioContext
        desc = I/O context
    }
    param[] = {
        type = Ionflux::ObjectBase::DataSize
        name = offset
        desc = stream offset of the node implementation
    }
    param[] = {
        type = Ionflux::ObjectBase::MagicSyllable
        name = magicSyllable
        desc = magic syllable to be used to indicate the node type
        default = MAGIC_SYLLABLE_NODE
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth
        default = DEPTH_UNSPECIFIED
    }
    param[] = {
        type = bool
        name = recursive
        desc = recursively deserialize child node implementations
        default = true
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize child node data
        default = true
    }
    impl = <<<
std::istream* source = Ionflux::ObjectBase::nullPointerCheck(
    ioContext.getInputStream(), "Node::deserializeImplChildNodes", 
    "Input stream");
Ionflux::ObjectBase::PointerOffsetMap* poMap = 
    Ionflux::ObjectBase::nullPointerCheck(
        ioContext.getPoMapSerialized(), 
    "Node::deserializeImplChildNodes", 
    "Pointer/offset map (serialized)");
Ionflux::ObjectBase::PointerOffsetMap* poMapCurrent = 
    Ionflux::ObjectBase::nullPointerCheck(
        ioContext.getPoMapCurrent(), 
    "Node::deserializeImplChildNodes", 
    "Pointer/offset map (current)");
NodeImplHierarchyHeader header = ioContext.getHeader();
deserializeImplChildNodes(otherImpl, context, *source, offset, 
    header, *poMap, poMapCurrent, magicSyllable, maxDepth, recursive, 
    deserializeData);
>>>
}
function.public[] = {
    bindings.disable = true
    spec = static
    type = void
    name = deserializeImplHierarchy
    shortDesc = Deserialize node implementation hierarchy
    longDesc = Deserialize a node implementation hierarchy from the specified source. The specified node implementation will become the root of the hierarchy. If \c targetNode is specified, the node ID of the root node of the deserialized hierarchy will be stored in \c targetNode.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = std::istream&
        name = source
        desc = data source
    }
    param[] = {
        type = Ionflux::VolGfx::NodeImplHierarchyHeader*
        name = header
        desc = where to store the node implementation hierarchy header
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeID*
        name = targetNode
        desc = where to store the node ID
        default = 0
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap*
        name = poMap
        desc = where to store the pointer/offset map (serialized)
        default = 0
    }
    param[] = {
        type = Ionflux::ObjectBase::PointerOffsetMap*
        name = poMapCurrent
        desc = where to store the pointer/offset map (current)
        default = 0
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize node data
        default = true
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth for deserializing child nodes
        default = DEPTH_UNSPECIFIED
    }
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::deserializeImplHierarchy", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::deserializeImplHierarchy", "Context");
// Magic word check
std::string t0;
Ionflux::ObjectBase::DataSize s0 = 
    getImplHierarchyHeaderSerializedSize();
Ionflux::ObjectBase::readFromStream(source, t0, s0);
Ionflux::ObjectBase::DataSize o0 = 
    Ionflux::ObjectBase::unpackAndCheckMagicWord(t0, 
        MAGIC_SYLLABLE_BASE, MAGIC_SYLLABLE_HEADER, 0, 0, 
        "Node::deserializeImplHierarchy");
// header
NodeImplHierarchyHeader* header0 = 0;
if (header == 0)
{
    header0 = Ionflux::ObjectBase::create<NodeImplHierarchyHeader>(
        "Node::deserializeImplHierarchy", "header");
    header = header0;
}
unpack(t0, *header, o0);
/* <---- DEBUG ----- //
std::cout << "[Node::deserializeImplHierarchy] DEBUG: "
    "unpacked header: [" << getNodeImplHierarchyHeaderValueString(*header) 
    << std::endl;
// ----- DEBUG ----> */
// pointer/offset map
source.seekg(header->poMapOffset);
if (!source.good())
{
    std::ostringstream status;
    status << "Invalid stream offset for pointer/offset map (offset = " 
        << header->poMapOffset << ").";
    throw IFVGError(Ionflux::ObjectBase::getErrorString(
        status.str(), "Node::deserializeImplHierarchy"));
}
Ionflux::ObjectBase::readFromStream(source, t0, 
    sizeof(Ionflux::ObjectBase::MagicWord));
Ionflux::ObjectBase::unpackAndCheckMagicWord(t0, 
    MAGIC_SYLLABLE_BASE, MAGIC_SYLLABLE_OFFSET_MAP, 0, 0, 
    "Node::deserializeImplHierarchy");
Ionflux::ObjectBase::PointerOffsetMap* poMap0 = 0;
if (poMap == 0)
{
    poMap0 = Ionflux::ObjectBase::create<
        Ionflux::ObjectBase::PointerOffsetMap>(
            "Node::deserializeImplHierarchy", 
            "pointer/offset map (serialized)");
    poMap = poMap0;
}
Ionflux::ObjectBase::readFromStream(source, t0);
Ionflux::ObjectBase::unpack(t0, *poMap);
/* <---- DEBUG ----- //
std::cout << "[Node::deserializeImplHierarchy] DEBUG: "
    "pointer/offset map: " << std::endl;
Ionflux::ObjectBase::DataSize k = 0;
for (Ionflux::ObjectBase::PointerOffsetMap::const_iterator i = 
    poMap->begin(); i != poMap->end(); i++)
{
    std::cout << "  [" << std::setw(3) << std::setfill('0') 
        << std::right << k << "] " << (*i).first << " -> " 
        << (*i).second << std::endl;
    k++;
}
// ----- DEBUG ----> */
// root node
Ionflux::ObjectBase::DataSize ro0 = 
    Ionflux::ObjectBase::checkedLookup(*poMap, header->rootNodePointer, 
        "Node::deserializeImplHierarchy", "Root node offset");
/* <---- DEBUG ----- //
std::cout << "[Node::deserializeImplHierarchy] DEBUG: "
    "root node offset = " << ro0 << std::endl;
// ----- DEBUG ----> */
NodeImpl* root0 = createImpl();
refImpl(root0);
deserializeImpl(root0, context, source, *header, *poMap, ro0, 
    MAGIC_SYLLABLE_ROOT, poMapCurrent, true, false, true);
Ionflux::ObjectBase::GenericPointer cp0 = 
    static_cast<Ionflux::ObjectBase::GenericPointer>(root0->child);
root0->child = 0;
if (targetNode != 0)
{
    targetNode->depth = header->rootNodeDepth;
    targetNode->loc = root0->loc;
}
if ((maxDepth == DEPTH_UNSPECIFIED) 
    || (maxDepth > header->rootNodeDepth))
{
    // deserialize child nodes
    deserializeImplChildNodes(root0, context, source, cp0, *header, *poMap, 
        poMapCurrent, maxDepth, true, deserializeData);
}
/* <---- DEBUG ----- //
std::cout << "[Node::deserializeImplHierarchy] DEBUG: "
    "root node: " << getImplValueString(root0, context) 
    << std::endl;
// ----- DEBUG ----> */
clearImpl(otherImpl, true, true, true);
copyImpl(*root0, *otherImpl, true);
setImplParent(otherImpl);
unrefImpl(root0);
// clean up
if (header0 != 0)
    delete header0;
header0 = 0;
if (poMap0 != 0)
    delete poMap0;
poMap0 = 0;
>>>
}
function.public[] = {
    spec = static
    type = void
    name = deserializeImplHierarchy
    shortDesc = Deserialize node implementation hierarchy
    longDesc = Deserialize a node implementation hierarchy from the specified source. The specified node implementation will become the root of the hierarchy. If \c targetNode is specified, the node ID of the root node of the deserialized hierarchy will be stored in \c targetNode.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::IOContext&
        name = ioContext
        desc = I/O context
    }
    param[] = {
        type = bool
        name = deserializeData
        desc = deserialize node data
        default = true
    }
    param[] = {
        type = int
        name = maxDepth
        desc = maximum depth for deserializing child nodes
        default = DEPTH_UNSPECIFIED
    }
    impl = <<<
std::istream* source = Ionflux::ObjectBase::nullPointerCheck(
    ioContext.getInputStream(), "Node::deserializeImplHierarchy", 
    "Input stream");
Ionflux::ObjectBase::PointerOffsetMap* poMap = 
    Ionflux::ObjectBase::nullPointerCheck(
        ioContext.getPoMapSerialized(), 
    "Node::deserializeImplHierarchy", 
    "Pointer/offset map (serialized)");
Ionflux::ObjectBase::PointerOffsetMap* poMapCurrent = 
    Ionflux::ObjectBase::nullPointerCheck(
        ioContext.getPoMapCurrent(), 
    "Node::deserializeImplHierarchy", 
    "Pointer/offset map (current)");
NodeImplHierarchyHeader header;
NodeID rootNodeID;
deserializeImplHierarchy(otherImpl, context, *source, &header, 
    &rootNodeID, poMap, poMapCurrent, deserializeData, maxDepth);
ioContext.setHeader(header);
ioContext.setRootNodeID(rootNodeID);
>>>
}
function.public[] = {
    spec = static
    type = Ionflux::ObjectBase::DataSize
    name = getImplArrayStride
    shortDesc = Get node implementation array stride
    longDesc = Get the node implementation array stride.
    impl = <<<
NodeImpl* p0 = 0;
>>>
    return = {
        value = <<<
reinterpret_cast<Ionflux::ObjectBase::DataSize>(p0 + 1) 
    - reinterpret_cast<Ionflux::ObjectBase::DataSize>(p0)
>>>
        desc = node implementation array stride
    }
}
function.public[] = {
	spec = static
	type = bool
	name = intersectRayImpl
	shortDesc = Intersect ray
	longDesc = Find intersections between the node implementation and the specified ray.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = const Ionflux::GeoUtils::Line3&
        name = ray
        desc = ray
    }
    param[] = {
        type = Ionflux::VolGfx::NodeIntersection&
        name = target
        desc = where to store the node intersection data
    }
    param[] = {
        type = double
        name = t
        desc = tolerance
        default = DEFAULT_TOLERANCE
    }
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::intersectRayImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::intersectRayImpl", "Context");
Ionflux::GeoUtils::Range3 r0;
getImplRange(otherImpl, context, r0);
target.nodeImpl = otherImpl;
target.depth = getImplDepth(otherImpl, context);
r0.intersect(ray, target.intersection);
target.faces = (target.intersection.nearPlane 
    | target.intersection.farPlane);
>>>
    return = {
        value = target.intersection.valid
        desc = \c true if the intersection is valid, \c false otherwise
    }
}
function.public[] = {
	spec = static
	type = unsigned int
	name = intersectRayImpl
	shortDesc = Intersect ray
	longDesc = Find intersections between the node and the specified ray. Node intersections are passed to the specified intersection processor in order of occurence along the ray. Ray traversal stops when the processor returns ChainableNodeProcessor::RESULT_FINISHED. If \c filter is specified, only intersections for nodes that pass the filter will be processed. However, if \c recursive is \c true, child nodes of nodes that intersect the ray but do not pass the filter are still be processed, up to the maximum depth specified on the filter.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = const Ionflux::GeoUtils::Line3&
        name = ray
        desc = ray
    }
    param[] = {
        type = Ionflux::VolGfx::NodeIntersectionProcessor*
        name = processor
        desc = node intersection processor
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = intersect nodes recursively
        default = true
    }
    param[] = {
        type = double
        name = t
        desc = tolerance
        default = DEFAULT_TOLERANCE
    }
    param[] = {
        type = const Ionflux::VolGfx::NodeIntersection*
        name = pcIntersection
        desc = precomputed node intersection
        default = 0
    }
	param[] = {
	    type = bool
	    name = fill0
	    desc = create a full set of child nodes for nodes that intersect the ray
	    default = false
	}
	param[] = {
	    type = bool
	    name = pruneEmpty0
	    desc = prune empty child nodes after processing an intersection
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::intersectRayImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::intersectRayImpl", "Context");
int depth = getImplDepth(otherImpl, context);
int maxDepth = DEPTH_UNSPECIFIED;
bool atMaxDepth = false;
if (filter != 0)
{
    maxDepth = filter->getMaxDepth();
    if (!context->checkDepthRange(depth, 0, maxDepth))
        return 0;
    if ((maxDepth != DEPTH_UNSPECIFIED) 
        && (depth == maxDepth))
        atMaxDepth = true;
}
// get intersections for this node
NodeIntersection ni0;
if (pcIntersection != 0)
{
    ni0 = *pcIntersection;
} else
    intersectRayImpl(otherImpl, context, ray, ni0, t);
if (!ni0.intersection.valid)
    return 0;
if (fill0 && !atMaxDepth)
    fillImpl(otherImpl, context);
unsigned int numNodes = 0;
NodeProcessingResultID result = NodeProcessor::RESULT_OK;
if ((filter == 0) 
    || NodeProcessor::checkFlags(
        filter->process(otherImpl), NodeFilter::RESULT_PASS))
{
    // process this node intersection
    if (processor != 0)
        result = processor->processIntersection(ni0);
    numNodes++;
}
if (!recursive 
    || atMaxDepth 
    || NodeProcessor::checkFlags(result, 
        ChainableNodeProcessor::RESULT_FINISHED))
    return numNodes;
// get intersection order for child nodes
/* <---- DEBUG ----- //
int n1 = getImplNumChildNodes(otherImpl);
unsigned int cni1 = 0;
for (int i = 0; i < n1; i++)
{
    NodeImpl& cn = otherImpl->child[i];
    if (hasImplVoxelClass(&cn, VOXEL_CLASS_FILLED))
        cni1++;
}
if (cni1 != 0)
{
    std::cerr << "[Node::intersectRayImpl] DEBUG: " 
        "Node before filling:" << std::endl;
    printImplDebugInfo(otherImpl, context, true);
}
// ----- DEBUG ----> */
/* <---- DEBUG ----- //
if (cni1 != 0)
{
    std::cerr << "[Node::intersectRayImpl] DEBUG: " 
        "Node after filling:" << std::endl;
    printImplDebugInfo(otherImpl, context, true);
}
// ----- DEBUG ----> */
NodeIntersectionVector niv0;
int n0 = getImplNumChildNodes(otherImpl);
for (int i = 0; i < n0; i++)
{
    NodeImpl* cn0 = Ionflux::ObjectBase::nullPointerCheck(
        getImplChildByValidIndex(otherImpl, i), 
        "Node::intersectRayImpl", "Child node implementation");
    if (intersectRayImpl(cn0, context, ray, ni0, t))
    {
        /* <---- DEBUG ----- //
        if (cni1 != 0)
        {
            std::cerr << "[Node::intersectRayImpl] DEBUG: " 
                "child node intersection: " << ni0.nodeImpl << " [" 
                << getNodeIntersectionValueString(*context, ni0) << "]"
                << std::endl;
        }
        // ----- DEBUG ----> */
        niv0.push_back(ni0);
    }
}
NodeIntersectionCompare cmp0;
std::sort(niv0.begin(), niv0.end(), cmp0);
// intersect nodes recursively
/* <---- DEBUG ----- //
if (cni1 != 0)
{
    std::cerr << "[Node::intersectRayImpl] DEBUG: " 
        "Node before child intersections:" << std::endl;
    printImplDebugInfo(otherImpl, context, true);
}
// ----- DEBUG ----> */

for (NodeIntersectionVector::iterator i = niv0.begin(); 
    i != niv0.end(); i++)
{
    NodeIntersection& ci = *i;
    numNodes += intersectRayImpl(ci.nodeImpl, context, ray, 
        processor, filter, true, t, &ci, fill0, pruneEmpty0);
}
/* <---- DEBUG ----- //
if (cni1 != 0)
{
    std::cerr << "[Node::intersectRayImpl] DEBUG: " 
        "Node before pruning:" << std::endl;
    printImplDebugInfo(otherImpl, context, true);
}
// ----- DEBUG ----> */
if (pruneEmpty0)
    pruneEmptyImpl(otherImpl, context);
/* <---- DEBUG ----- //
if (cni1 != 0)
{
    std::cerr << "[Node::intersectRayImpl] DEBUG: " 
        "Node after pruning:" << std::endl;
    printImplDebugInfo(otherImpl, context, true);
}
// ----- DEBUG ----> */
>>>
    return = {
        value = numNodes
        desc = number of nodes that have intersections
    }
}
function.public[] = {
	spec = static
	type = unsigned int
	name = castRayGridImpl
	shortDesc = Cast ray grid
	longDesc = Cast a number of rays arranged in a grid defined by the specified parameters. Rays are arranged in a two-dimensional grid, where each ray is offset from the next along each coordinate by the ray origin step specified for that coordinate. The grid has a number of rays in each coordinate according to the specified number of rays.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = const Ionflux::GeoUtils::Vector3&
        name = rayOrigin
        desc = ray origin
    }
    param[] = {
        type = const Ionflux::GeoUtils::Vector3&
        name = rayDirection
        desc = ray direction
    }
    param[] = {
        type = const Ionflux::GeoUtils::Vector3&
        name = originStepX
        desc = ray origin step (X)
    }
    param[] = {
        type = const Ionflux::GeoUtils::Vector3&
        name = originStepY
        desc = ray origin step (Y)
    }
    param[] = {
        type = unsigned int
        name = numRaysX
        desc = number of rays in X direction
    }
    param[] = {
        type = unsigned int
        name = numRaysY
        desc = number of rays in Y direction
    }
    param[] = {
        type = Ionflux::VolGfx::NodeIntersectionProcessor*
        name = processor
        desc = node intersection processor
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = intersect nodes recursively
        default = true
    }
    param[] = {
        type = double
        name = t
        desc = tolerance
        default = DEFAULT_TOLERANCE
    }
	param[] = {
	    type = bool
	    name = fill0
	    desc = create a full set of child nodes for nodes that intersect a ray
	    default = false
	}
	param[] = {
	    type = bool
	    name = pruneEmpty0
	    desc = prune empty child nodes after processing an intersection
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::castRayGridImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::castRayGridImpl", "Context");
unsigned int numNodes = 0;
Ionflux::ObjectBase::IFObject mm;
Ionflux::GeoUtils::Line3* ray0 = 
    Ionflux::GeoUtils::Line3::create(rayOrigin, rayDirection);
mm.addLocalRef(ray0);
if (processor != 0)
    processor->setRay(ray0);
Ionflux::GeoUtils::Vector3 ox;
// <---- DEBUG ----- //
std::cerr << "[Node::castRayGridImpl] DEBUG: "
    "ray = [" << ray0->getValueString() << "], numRays = (" 
    << numRaysX << ", " << numRaysY << "), originStep = [(" 
    << originStepX.getValueString() << "), (" 
    << originStepY.getValueString() << ")]" << std::endl;
// ----- DEBUG ----> */
for (unsigned int i = 0; i < numRaysX; i++)
{
    Ionflux::GeoUtils::Vector3 oy;
    for (unsigned int j = 0; j < numRaysY; j++)
    {
        ray0->setP(rayOrigin + ox + oy);
        if (processor != 0)
            processor->begin();
        numNodes += intersectRayImpl(otherImpl, context, *ray0, 
            processor, filter, recursive, t, 0, fill0, pruneEmpty0);
        if (processor != 0)
            processor->finish();
        oy.addIP(originStepY);
    }
    ox.addIP(originStepX);
}
mm.removeLocalRef(ray0);
>>>
    return = {
        value = numNodes
        desc = number of nodes that have intersections
    }
}
function.public[] = {
	spec = static
	type = unsigned int
	name = castRayGridImpl
	shortDesc = Cast ray grid
	longDesc = Cast a number of rays arranged in a grid defined by the specified parameters. Rays are arranged in a regular grid in such a way that nodes on the specified target depth level are covered by one ray each that passes through the center of each node at that depth level. Rays in the grid are cast along the specified axis, and they are offset from the node by the specified \c planeOffset, given as a fraction of the node size at the target level.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = const Ionflux::GeoUtils::AxisID&
        name = axis
        desc = axis to be used as the direction vector
    }
    param[] = {
        type = int
        name = targetDepth
        desc = target depth level
        default = DEPTH_UNSPECIFIED
    }
    param[] = {
        type = double
        name = planeOffset
        desc = ray plane offset
        default = DEFAULT_RAY_PLANE_OFFSET
    }
    param[] = {
        type = Ionflux::VolGfx::NodeIntersectionProcessor*
        name = processor
        desc = node intersection processor
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = filter
        desc = node filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = intersect nodes recursively
        default = true
    }
    param[] = {
        type = double
        name = t
        desc = tolerance
        default = DEFAULT_TOLERANCE
    }
	param[] = {
	    type = bool
	    name = fill0
	    desc = create a full set of child nodes for nodes that intersect a ray
	    default = false
	}
	param[] = {
	    type = bool
	    name = pruneEmpty0
	    desc = prune empty child nodes after processing an intersection
	    default = false
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(otherImpl, 
    "Node::castRayGridImpl", "Node implementation");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::castRayGridImpl", "Context");
int maxNumLevels = context->getMaxNumLevels();
if ((targetDepth < 0) 
    || (targetDepth >= maxNumLevels))
    targetDepth = maxNumLevels - 1;
// calculate number of rays
int depth = getImplDepth(otherImpl, context);
LocInt dm0 = context->getDepthMask(depth).to_ulong();
LocInt dm1 = context->getDepthMask(targetDepth).to_ulong();
unsigned int numRaysXY = dm0 / dm1;
// calculate ray origin, direction, and step
double ts0 = context->getVoxelSize(targetDepth);
double po0 = -planeOffset * ts0;
Ionflux::GeoUtils::Vector3 rayDir(
    Ionflux::GeoUtils::Vector3::axis(axis));
Ionflux::GeoUtils::Vector3 originStepX;
Ionflux::GeoUtils::Vector3 originStepY;
Ionflux::GeoUtils::Vector3::getOtherAxes(axis, 
    originStepX, originStepY);
originStepX.multiplyIP(ts0);
originStepY.multiplyIP(ts0);
Ionflux::GeoUtils::Vector3 rayOrigin(
    getImplLocation(otherImpl, context));
rayOrigin.addIP(po0 * rayDir + 0.5 * originStepX + 0.5 * originStepY);
// <---- DEBUG ----- //
std::cerr << "[Node::castRayGridImpl] DEBUG: "
    "depth = " << depth << ", targetDepth = " << targetDepth 
    << ", depthMask0 = " << dm0 << ", depthMask1 = " << dm1 
    << ", numRaysXY = " << numRaysXY << ", targetVoxelSize = " << ts0 
    << ", planeOffset = " << po0 << ", rayDirection = (" 
    << rayDir.getValueString() << "), rayOrigin = (" 
    << rayOrigin.getValueString() << "), originStepX = (" 
    << originStepX.getValueString() << "), originStepY = (" 
    << originStepY.getValueString() << ")" << std::endl;
// ----- DEBUG ----> */
>>>
    return = {
        value = <<<
castRayGridImpl(otherImpl, context, rayOrigin, rayDir, 
    originStepX, originStepY, numRaysXY, numRaysXY, 
    processor, filter, recursive, t, fill0, pruneEmpty0)
>>>
        desc = number of nodes that have intersections
    }
}
function.public[] = {
	spec = static
	type = unsigned int
	name = mergeImpl
	shortDesc = Merge node hierarchies
	longDesc = Merge two node implementation hierarchies. The merging operation will be applied to a source and a target node if they pass their respective filters (if set). A valid source child node will be taken over by the target node if either the corresponding target child note is not set or the child merge policy is \c MERGE_POLICY_TAKE_OVER_SOURCE and the source child node passes the source merge filter (if set). A valid source data entry will be taken over by the target node if either there is no data record attached to the target node or the data merge policy is \c MERGE_POLICY_TAKE_OVER_SOURCE and the source child node passes the source merge filter (if set). If \c recursive is set to true, child nodes will be merged recursively if both the target and its corresponding source child node are set and the child node merge policy is either not \c MERGE_POLICY_TAKE_OVER_SOURCE, or the source child node did not pass the filter.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = sourceImpl
        desc = Source node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = targetImpl
        desc = Target node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = Ionflux::VolGfx::MergePolicyID
        name = childPolicy
        desc = Policy for merging child nodes
        default = MERGE_POLICY_KEEP_TARGET
    }
    param[] = {
        type = Ionflux::VolGfx::MergePolicyID
        name = dataPolicy
        desc = Policy for merging data
        default = MERGE_POLICY_KEEP_TARGET
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = sourceFilter
        desc = source node filter
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = targetFilter
        desc = target node filter
        default = 0
    }
    param[] = {
        type = Ionflux::VolGfx::NodeFilter*
        name = sourceMergeFilter
        desc = source node merge filter
        default = 0
    }
    param[] = {
        type = bool
        name = recursive
        desc = merge nodes recursively
        default = true
    }
	param[] = {
	    type = bool
	    name = fill0
	    desc = Create a full set of child nodes on the target node if one is missing
	    default = false
	}
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(sourceImpl, 
    "Node::mergeImpl", "Node implementation (source)");
Ionflux::ObjectBase::nullPointerCheck(targetImpl, 
    "Node::mergeImpl", "Node implementation (target)");
Ionflux::ObjectBase::nullPointerCheck(context, 
    "Node::mergeImpl", "Context");
// check filters
if ((sourceFilter != 0) 
    && !NodeProcessor::checkFlags(sourceFilter->process(sourceImpl), 
        NodeFilter::RESULT_PASS))
{
    return 0;
}
if ((targetFilter != 0) 
    && !NodeProcessor::checkFlags(targetFilter->process(targetImpl), 
        NodeFilter::RESULT_PASS))
{
    return 0;
}
unsigned int numNodes = 1;
// merge child nodes
int n0 = context->getMaxNumLeafChildNodesPerNode();
NodeImplVector niv;
NodeChildMask takeOver = 0;
for (int i = 0; i < n0; i++)
{
    bool cs0 = sourceImpl->valid.test(i);
    bool ct0 = targetImpl->valid.test(i);
    NodeImpl* cnm = 0;
    bool toCN = false;
    if (cs0)
    {
        if ((!ct0) 
            || (childPolicy == MERGE_POLICY_TAKE_OVER_SOURCE))
        {
            cnm = Ionflux::ObjectBase::nullPointerCheck(
                getImplChildByOrderIndex(sourceImpl, context, i), 
                "Node::mergeImpl", "Child node (source)");
            if ((sourceMergeFilter == 0) 
                || NodeProcessor::checkFlags(
                    sourceMergeFilter->process(cnm), 
                    NodeFilter::RESULT_PASS))
            {
                // take over source child node
                niv.push_back(cnm);
                takeOver.set(i, true);
                toCN = true;
                numNodes++;
            }
        }
        if (!toCN && cs0 && ct0 && recursive)
        {
            // merge child nodes recursively
            NodeImpl* cns = Ionflux::ObjectBase::nullPointerCheck(
                getImplChildByOrderIndex(sourceImpl, context, i), 
                "Node::mergeImpl", "Child node (source)");
            NodeImpl* cnt = Ionflux::ObjectBase::nullPointerCheck(
                getImplChildByOrderIndex(targetImpl, context, i), 
                "Node::mergeImpl", "Child node (target)");
            numNodes += mergeImpl(cns, cnt, context, childPolicy, 
                dataPolicy, sourceFilter, targetFilter, 
                sourceMergeFilter, true, fill0);
        }
    }
    if (!toCN)
    {
        // keep target child node
        niv.push_back(0);
    }
}
if (takeOver.any())
    mergeImplChildNodes(targetImpl, context, niv, fill0);
// merge data
NodeDataImpl* ds0 = sourceImpl->data;
NodeDataImpl* dt0 = targetImpl->data;
if (ds0 != 0)
{
    if ((dt0 == 0) 
        || (dataPolicy == MERGE_POLICY_TAKE_OVER_SOURCE))
    {
        if ((sourceMergeFilter == 0) 
            || NodeProcessor::checkFlags(
                sourceMergeFilter->process(sourceImpl), 
                NodeFilter::RESULT_PASS))
        {
            // take over source data
            if (dt0 != 0)
                clearImpl(targetImpl, false, true, false);
            targetImpl->data = ds0;
            sourceImpl->data = 0;
        }
    }
}
>>>
    return = {
        value = numNodes
        desc = number of nodes that have been merged
    }
}
function.public[] = {
	spec = static
	type = std::string
	name = getImplValueString
	shortDesc = Get string representation of node implementation
	longDesc = Get a string representation of the value of the node implementation.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
    param[] = {
        type = bool
        name = showData
        desc = show data
        default = true
    }
	impl = <<<
std::ostringstream status;
if (otherImpl == 0)
    status << "<null>";
else
{
    int depth = -1;
    if (context != 0)
    {
        //status << "ctx = [" << context->getValueString() << "]; ";
        depth = getImplDepth(otherImpl, context);
    }
    status << "refCount = " << otherImpl->refCount 
        << "; loc.x = " << otherImpl->loc.x 
        << ", loc.y = " << otherImpl->loc.y 
        << ", loc.z = " << otherImpl->loc.z 
        << ", valid = " << otherImpl->valid 
        << ", leaf = " << otherImpl->leaf 
        << ", parent = " << otherImpl->parent 
        << ", child = " << otherImpl->child;
    if (depth != -1)
        status << ", depth = " << depth;
    if (isImplLeaf(otherImpl))
    {
        status << "; (leaf)";
    }
    if (otherImpl->data != 0)
    {
        status << "; ";
        if (showData)
        {
            NodeDataImpl* dp = otherImpl->data;
            status << getDataTypeString(dp->type);
            if ((dp->type != DATA_TYPE_NULL) 
                && (dp->type != DATA_TYPE_UNKNOWN))
            {
                status << " (" << getDataValueString(dp) << ")";
            }
        } else
            status << otherImpl->data;
    } else
        status << "; <null>";
}
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}
function.public[] = {
	spec = static
	type = void
	name = printImplDebugInfo
	shortDesc = Print debug information
	longDesc = Print debug information.
    param[] = {
        type = Ionflux::VolGfx::NodeImpl*
        name = otherImpl
        desc = Node implementation
    }
    param[] = {
        type = Ionflux::VolGfx::Context*
        name = context
        desc = Voxel tree context
    }
	param[] = {
	    type = bool
	    name = recursive
	    desc = List child nodes recursively
	    default = false
	}
	param[] = {
	    type = unsigned int
	    name = indentWidth
	    desc = Indentation width
	    default = Ionflux::ObjectBase::DEFAULT_INDENT_WIDTH
	}
	param[] = {
	    type = char
	    name = indentChar
	    desc = Indentation character
	    default = ' '
	}
	param[] = {
	    type = unsigned int
	    name = depth
	    desc = Depth
	    default = 0
	}
	impl = <<<
std::string indent0 = Ionflux::ObjectBase::getIndent(depth, 
    indentWidth, indentChar);
std::string indent1 = Ionflux::ObjectBase::getIndent(depth + 1, 
    indentWidth, indentChar);
std::cout << indent0 << "[";
NodeImpl* p0 = otherImpl->parent;
if (p0 != 0)
{
    int orderIndex = getImplChildOrderIndex(p0, otherImpl);
    std::cout << "#" << std::setw(3) << std::setfill('0') 
        << orderIndex << " ";
}
std::cout << "Node: ";
if (otherImpl == 0)
{
    std::cout << "<null>]" << std::endl;
    return;
}
std::cout << "impl = " << otherImpl;
if (p0 != 0)
    std::cout << ", parent = " << p0;
std::cout << ", refCount = " << otherImpl->refCount;
if (context != 0)
{
    Ionflux::GeoUtils::Vector3 loc = 
        getImplLocation(otherImpl, context);
    double size = getImplVoxelSize(otherImpl, context);
    int d0 = getImplDepth(otherImpl, context);
    std::cout << std::endl << indent1 << "depth = " << d0 
        << ", loc = (" << loc.getValueString() << "), size = " 
        << size;
    Region3 r0;
    NodeID nid0;
    nid0.loc = otherImpl->loc;
    nid0.depth = d0;
    context->getVoxelRegion(nid0, r0);
    std::cout << std::endl << indent1 << "region = " 
        << getRegionString(r0);
}
std::cout << std::endl;
std::cout << indent1 << "loc.x  = " << otherImpl->loc.x << std::endl;
std::cout << indent1 << "loc.y  = " << otherImpl->loc.y << std::endl;
std::cout << indent1 << "loc.z  = " << otherImpl->loc.z << std::endl;
if (otherImpl->valid.any())
    std::cout << indent1 << "valid  = " << otherImpl->valid << std::endl;
if (otherImpl->leaf.any())
    std::cout << indent1 << "leaf   = " << otherImpl->leaf << std::endl;
if (otherImpl->data != 0)
{
    // Node data
    std::cout << indent1 << "data: ";
    NodeDataImpl* dp = static_cast<NodeDataImpl*>(
        otherImpl->data);
    std::cout << getDataTypeString(dp->type) << " (" 
        << otherImpl->data;
    if ((dp->type != DATA_TYPE_NULL) 
        && (dp->type != DATA_TYPE_UNKNOWN))
    {
        std::cout << ", " << getDataValueString(dp);
    }
    std::cout << ")";
    if (isImplLeaf(otherImpl))
        std::cout << "]" << std::endl;
    else
        std::cout << std::endl;
}
if (!isImplLeaf(otherImpl))
{
    // Child nodes.
    int n0 = getImplNumChildNodes(otherImpl);
    NodeImpl* cp = otherImpl->child;
    std::cout << indent1 << "child nodes (" << n0 
        << ", cp = " << cp << ")";
    if (recursive 
        && (cp != 0))
    {
        std::cout << ":" << std::endl;
        for (int i = 0; i < n0; i++)
        {
            NodeImpl* ci = &(cp[i]);
            if (ci != 0)
            {
                printImplDebugInfo(ci, context, recursive, 
                    indentWidth, indentChar, depth + 2);
            }
        }
        std::cout << indent0 << "]" << std::endl;
    } else
        std::cout << "]" << std::endl;
}
>>>
}

# Pure virtual member functions.

# operations

# Global functions.

