# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2010-2013 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Face.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GeoUtils - Ionflux' Geometry Library; if not, write to the 
# Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
# 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/types.hpp"'
        '"geoutils/Matrix3.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"ifobject/objectutils.hpp"'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/Vertex3Set.hpp"'
        '"geoutils/VectorSetSet.hpp"'
        '"geoutils/FaceData.hpp"'
    }
}

# forward declarations
forward = {
    'class VectorSetSet'
    'class FaceData'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Face
	shortDesc = Mesh face
	title = Mesh face
	longDesc = A mesh face.
	group.name = geoutils
	base = {
		## base classes from the IFObject hierarchy
		#ifobject[] = {
		#	name = IFObject
		#}
        # other base classes
        other[] = {
			name = Ionflux::GeoUtils::BoxBoundsItem
            include = geoutils/BoxBoundsItem.hpp
		}
        other[] = {
			name = Ionflux::GeoUtils::TransformableObject
            include = geoutils/TransformableObject.hpp
            xml = {
                enabled = true
                getFunc = getTransformableObject
                include = geoutils/TransformableObject
            }
		}
	}
    features = {
        'logmessage'
        'classinfo'
        'copy'
        'upcast'
        'create'
        'xmlio'
    }
    create = {
        allocationError = GeoUtilsError("Could not allocate object.")
        extendedCreate = true
    }
    xml.elementName = face
}

# Member variables.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    style = vector
    name = vertices
    desc = Vertex index vector
    element = {
        type = unsigned int
        name = Vertex
        plural = Vertices
        #managed = true
        valueType = integer
        createExpr = 0
    }
    xml = {
        child.name = vertices
    }
    extendedAddFuncs = true
}
property.protected[] = {
    # NOTE: There should be no need for the vertex source to be managed by 
    #       the faces, since usually the faces are managed by a higher level 
    #       object that also manages the vertex source.
	type = Ionflux::GeoUtils::Vertex3Set*
	setFromType = Ionflux::GeoUtils::Vertex3Set*
	name = vertexSource
	desc = Vertex source
#   managed = true
#   copy = true
#   proxy = true
}
property.protected[] = {
    type = Ionflux::GeoUtils::VectorSetSet*
    setFromType = Ionflux::GeoUtils::VectorSetSet*
    name = faceData
    desc = face data
    xml = {
        child = {
            name = fds
            elementName = data
        }
        createFunc = createVectorSetSet
    }
    valueType = object
}

# Protected variables.
variable.protected[] = {
       type = Ionflux::GeoUtils::Vector3*
       name = tangent
       desc = Tangent vector
}
variable.protected[] = {
       type = Ionflux::GeoUtils::Vector3*
       name = normal
       desc = Normal vector
}
variable.protected[] = {
       type = Ionflux::GeoUtils::Vector3*
       name = binormal
       desc = Binormal vector
}
variable.protected[] = {
       type = Ionflux::GeoUtils::Polygon3*
       name = polygon
       desc = Polygon
}

# Public static constants.
constant.public[] = {
       type = unsigned int
       name = VERTEX_INDEX_NONE
       desc = Vertex index not pointing at any vertex
       value = UINT_MAX
}

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = tangent
        value = 0
    }
    initializer[] = {
        name = normal
        value = 0
    }
    initializer[] = {
        name = binormal
        value = 0
    }
    initializer[] = {
        name = polygon
        value = 0
    }
    initializer[] = {
        name = vertexSource
        value = 0
    }
    initializer[] = {
        name = faceData
        value = 0
    }
    impl = 
}
constructor.public[] = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = tangent
        value = 0
    }
    initializer[] = {
        name = normal
        value = 0
    }
    initializer[] = {
        name = binormal
        value = 0
    }
    initializer[] = {
        name = polygon
        value = 0
    }
    initializer[] = {
        name = vertexSource
        value = initVertexSource
    }
    initializer[] = {
        name = faceData
        value = 0
    }
    param[] = {
        name = initVerts
        type = const Ionflux::ObjectBase::UIntVector*
        desc = Vertex index vector
    }
    param[] = {
        name = initVertexSource
        type = Ionflux::GeoUtils::Vertex3Set*
        desc = Vertex source
        default = 0
    }
    param[] = {
        name = initUV
        type = Ionflux::GeoUtils::FaceData*
        desc = Texture coordinates
        default = 0
    }
    param[] = {
        name = initVertexColors
        type = Ionflux::GeoUtils::FaceData*
        desc = Vertex colors
        default = 0
    }
    impl = <<<
if (initVerts != 0)
    addVertices(*initVerts);
if (initVertexSource != 0)
    setVertexSource(initVertexSource);
if (initUV != 0)
    addFaceData(initUV);
if (initVertexColors != 0)
    addFaceData(initVertexColors);
update();
>>>
}
constructor.public[] = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = tangent
        value = 0
    }
    initializer[] = {
        name = normal
        value = 0
    }
    initializer[] = {
        name = binormal
        value = 0
    }
    initializer[] = {
        name = polygon
        value = 0
    }
    initializer[] = {
        name = vertexSource
        value = initVertexSource
    }
    initializer[] = {
        name = faceData
        value = 0
    }
	param[] = {
		type = unsigned int
		name = v0
		desc = Vertex index (0)
	}
	param[] = {
		type = unsigned int
		name = v1
		desc = Vertex index (1)
	}
	param[] = {
		type = unsigned int
		name = v2
		desc = Vertex index (2)
	}
	param[] = {
		type = unsigned int
		name = v3
		desc = Vertex index (3)
		default = Ionflux::GeoUtils::Face::VERTEX_INDEX_NONE
	}
    param[] = {
        name = initVertexSource
        type = Ionflux::GeoUtils::Vertex3Set*
        desc = Vertex source
        default = 0
    }
    param[] = {
        name = initUV
        type = Ionflux::GeoUtils::FaceData*
        desc = Texture coordinates
        default = 0
    }
    param[] = {
        name = initVertexColors
        type = Ionflux::GeoUtils::FaceData*
        desc = Vertex colors
        default = 0
    }
    impl = <<<
addVertices(v0, v1, v2, v3);
if (initVertexSource != 0)
    setVertexSource(initVertexSource);
if (initUV != 0)
    addFaceData(initUV);
if (initVertexColors != 0)
    addFaceData(initVertexColors);
update();
>>>
}

# Destructor.
destructor.impl = clear();

# Protected member functions.

# Public member functions.
function.copy.impl = <<<
clear();
for (UIntVector::const_iterator i = other.vertices.begin(); 
    i != other.vertices.end(); i++)
    vertices.push_back(*i);
setFaceData(other.faceData->copy());
TransformableObject::operator=(other);
update();
>>>
function.public[] = {
	spec = virtual
	type = void
	name = copyVertices
	shortDesc = Copy vertices
	longDesc = Create a new vertex set with copies of the current vertices. This makes the face the (current) single owner of its vertices.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "copyVertices", "Vertex source");
setVertexSource(&(vertexSource->duplicate()));
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = update
	shortDesc = Update
	longDesc = Update all state according to the vertices of the face.
    impl = <<<
if ((vertexSource == 0) 
    || (vertices.size() == 0))
    return;
clearTangentSpace();
clearPolygon();
recalculateBounds();
updateRadiusAndCenter();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = clearTangentSpace
	shortDesc = Clear tangent space
	longDesc = Clear the tangent space vectors.
    impl = <<<
if (tangent != 0)
    removeLocalRef(tangent);
tangent = 0;
if (normal != 0)
    removeLocalRef(normal);
normal = 0;
if (binormal != 0)
    removeLocalRef(binormal);
binormal = 0;
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = clearPolygon
	shortDesc = Clear polygon
	longDesc = Clear the face polygon.
    impl = <<<
if (polygon != 0)
    removeLocalRef(polygon);
polygon = 0;
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = clear
	shortDesc = Clear
	longDesc = Removes all items and resets state.
    impl = <<<
vertices.clear();
setVertexSource(0);
setFaceData(0);
clearTangentSpace();
clearPolygon();
BoxBoundsItem::clear();
TransformableObject::clear();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = addVertices
	shortDesc = Add vertex indices
	longDesc = Add vertex indices for a triangle or quad.
	param[] = {
		type = unsigned int
		name = v0
		desc = Vertex index (0)
	}
	param[] = {
		type = unsigned int
		name = v1
		desc = Vertex index (1)
	}
	param[] = {
		type = unsigned int
		name = v2
		desc = Vertex index (2)
	}
	param[] = {
		type = unsigned int
		name = v3
		desc = Vertex index (3)
		default = Ionflux::GeoUtils::Face::VERTEX_INDEX_NONE
	}
    impl = <<<
addVertex(v0);
addVertex(v1);
addVertex(v2);
if (v3 != VERTEX_INDEX_NONE)
    addVertex(v3);
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addFaceData
	shortDesc = Add face data
	longDesc = Add a face data entry.
	param[] = {
		type = Ionflux::GeoUtils::FaceData*
		name = newFaceData
		desc = Face data
	}
    impl = <<<
if (faceData == 0)
    faceData = VectorSetSet::create();
faceData->addVectorSet(newFaceData);
>>>
    return = {
        value = newFaceData
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addFaceData
	shortDesc = Add face data
	longDesc = Add a face data entry of a certain type.
	param[] = {
		type = Ionflux::GeoUtils::FaceDataTypeID
		name = dataType
		desc = Face data type ID
	}
    impl = <<<
FaceData* newData = FaceData::create(dataType);
addFaceData(newData);
>>>
    return = {
        value = newData
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addFaceData
	shortDesc = Add face data
	longDesc = Add a face data entry of a certain type. The face data entry will be composed of the specified input vectors.
	param[] = {
		type = Ionflux::GeoUtils::FaceDataTypeID
		name = dataType
		desc = Face data type ID
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v0
		desc = Face data vector (0)
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v1
		desc = Face data vector (1)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v2
		desc = Face data vector (2)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v3
		desc = Face data vector (3)
		default = 0
	}
    impl = <<<
FaceData* newData = FaceData::create(dataType);
unsigned int numNonNull = 0;
if (v0 != 0)
{
    newData->addVector(v0);
    numNonNull++;
}
if (v1 != 0)
{
    newData->addVector(v1);
    numNonNull++;
}
if (v2 != 0)
{
    newData->addVector(v2);
    numNonNull++;
}
if (v3 != 0)
{
    newData->addVector(v3);
    numNonNull++;
}
unsigned int expected = getNumVertices();
if (numNonNull < expected)
{
    std::ostringstream status;
    status << "Not enough input vectors for face data (" 
        << FaceData::getTypeIDString(dataType) << ", expected " 
        << expected << ", have " << numNonNull << ")";
    throw GeoUtilsError(getErrorString(status.str(), "addFaceData"));
}
addFaceData(newData);
>>>
    return = {
        value = newData
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addTexCoords
	shortDesc = Add texture coordinates
	longDesc = Add texture coordinates. The face data entry will be composed of the specified input vectors.
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v0
		desc = Face data vector (0)
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v1
		desc = Face data vector (1)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v2
		desc = Face data vector (2)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v3
		desc = Face data vector (3)
		default = 0
	}
    impl = 
    return = {
        value = addFaceData(FaceData::TYPE_TEX_COORD, v0, v1, v2, v3)
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addVertexColors
	shortDesc = Add vertex colors
	longDesc = Add vertex colors. The face data entry will be composed of the specified input vectors.
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v0
		desc = Face data vector (0)
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v1
		desc = Face data vector (1)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v2
		desc = Face data vector (2)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v3
		desc = Face data vector (3)
		default = 0
	}
    impl = 
    return = {
        value = addFaceData(FaceData::TYPE_VERTEX_COLOR, v0, v1, v2, v3)
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addVertexNormals
	shortDesc = Add vertex normals
	longDesc = Add vertex normals. The face data entry will be composed of the specified input vectors.
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v0
		desc = Face data vector (0)
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v1
		desc = Face data vector (1)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v2
		desc = Face data vector (2)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v3
		desc = Face data vector (3)
		default = 0
	}
    impl = 
    return = {
        value = addFaceData(FaceData::TYPE_VERTEX_NORMAL, v0, v1, v2, v3)
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getFaceDataByType
	shortDesc = Get face data by type
	longDesc = Get face data entries of a certain type.
	param[] = {
		type = Ionflux::GeoUtils::FaceDataTypeID
		name = dataType
		desc = Face data type ID
	}
	param[] = {
		type = Ionflux::GeoUtils::VectorSetSet&
		name = target
		desc = Where to store the face data
	}
    impl = <<<
if (faceData == 0)
    return;
for (unsigned int i = 0; i < faceData->getNumVectorSets(); i++)
{
    FaceData* cfd = FaceData::upcast(faceData->getVectorSet(i));
    if ((cfd != 0) 
        && cfd->hasType(dataType))
        target.addVectorSet(cfd);
}
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FaceData*
	name = getFaceDataByType0
	shortDesc = Get face data by type and index.
	longDesc = Get face data by type and index. This gets the face data record that represents the \c index-th occurence of face data of the specified type.
	param[] = {
		type = Ionflux::GeoUtils::FaceDataTypeID
		name = dataType
		desc = Face data type ID
	}
	param[] = {
		type = unsigned int
		name = index
		desc = face data index
		default = 0
	}
    impl = <<<
if (faceData == 0)
    return 0;
FaceData* result = 0;
unsigned int i = 0;
unsigned int k = 0;
while ((i < faceData->getNumVectorSets()) 
    && (result == 0))
{
    FaceData* cfd = FaceData::upcast(faceData->getVectorSet(i));
    if ((cfd != 0) 
        && cfd->hasType(dataType))
    {
        if (k == index)
            result = cfd;
        else
            k++;
    }
    i++;
}
>>>
    return = {
        value = result
        desc = Face data entry, or 0 if no matching face data exists
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getTexCoords
	shortDesc = Get texture coordinates
	longDesc = Get texture coordinates.
	param[] = {
		type = Ionflux::GeoUtils::VectorSetSet&
		name = target
		desc = Where to store the face data
	}
    impl = getFaceDataByType(FaceData::TYPE_TEX_COORD, target);
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FaceData*
	name = getTexCoords0
	shortDesc = Get texture coordinates
	longDesc = Get texture coordinates by index.
	param[] = {
		type = unsigned int
		name = index
		desc = face data index
		default = 0
	}
    impl = 
    return = {
        value = getFaceDataByType0(FaceData::TYPE_TEX_COORD, index);
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getVertexColors
	shortDesc = Get vertex colors
	longDesc = Get vertex colors.
	param[] = {
		type = Ionflux::GeoUtils::VectorSetSet&
		name = target
		desc = Where to store the face data
	}
    impl = getFaceDataByType(FaceData::TYPE_VERTEX_COLOR, target);
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FaceData*
	name = getVertexColors0
	shortDesc = Get vertex colors
	longDesc = Get vertex colors by index.
	param[] = {
		type = unsigned int
		name = index
		desc = face data index
		default = 0
	}
    impl = 
    return = {
        value = getFaceDataByType0(FaceData::TYPE_VERTEX_COLOR, index);
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getVertexNormals
	shortDesc = Get vertex normals
	longDesc = Get vertex normals.
	param[] = {
		type = Ionflux::GeoUtils::VectorSetSet&
		name = target
		desc = Where to store the face data
	}
    impl = getFaceDataByType(FaceData::TYPE_VERTEX_NORMAL, target);
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FaceData*
	name = getVertexNormals0
	shortDesc = Get vertex normals
	longDesc = Get vertex normals by index.
	param[] = {
		type = unsigned int
		name = index
		desc = face data index
		default = 0
	}
    impl = 
    return = {
        value = getFaceDataByType0(FaceData::TYPE_VERTEX_NORMAL, index);
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getTangent
	shortDesc = Get tangent vector
	longDesc = Get the tangent vector for the face.
    impl = <<<
if (tangent != 0)
    return *tangent;
if (vertexSource == 0)
    throw GeoUtilsError(getErrorString("Vertex source is not set.", 
        "getTangent"));
if (vertices.size() < 3)
    throw GeoUtilsError(getErrorString(
        "Face does not have enough vertices.", "getTangent"));
Vertex3* pv0 = vertexSource->getVertex(vertices[0]);
Vector3 p0 = pv0->getVector();
Vertex3* pv1 = vertexSource->getVertex(vertices[1]);
Vector3 p1 = pv1->getVector();
tangent = Vector3::create();
addLocalRef(tangent);
Vector3 b = getBinormal();
FaceData* uv = getTexCoords0();
if ((uv == 0) 
    || (uv->getNumVectors() < 3))
{
    *tangent = b.ortho(p1 - p0).normalize();
    return *tangent;
}
// Calculate tangent vector according to texture coordinates.
Vector* uv0 = Ionflux::ObjectBase::nullPointerCheck(
    uv->getVector(0), this, "getTangent", "Texture coordinate vector");
Vector* uv1 = Ionflux::ObjectBase::nullPointerCheck(
    uv->getVector(1), this, "getTangent", "Texture coordinate vector");
double u0 = uv0->getElement(0);
double v0 = uv0->getElement(1);
double u1 = uv1->getElement(0);
double v1 = uv1->getElement(1);
*tangent = 1. / (u1 - u0) * ((p1 - p0) - (v1 - v0) * b);
>>>
    return = {
        value = *tangent
        desc = Tangent vector
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getBinormal
    desc = Get binormal vector
	longDesc = Get the binormal vector for the face.
    impl = <<<
if (binormal != 0)
    return *binormal;
if (vertexSource == 0)
    throw GeoUtilsError("Vertex source is not set.");
if (vertices.size() < 3)
    throw GeoUtilsError("Face does not have enough vertices.");
binormal = Vector3::create();
addLocalRef(binormal);
Vertex3* pv0 = vertexSource->getVertex(vertices[0]);
Vector3 p0 = pv0->getVector();
Vertex3* pv1 = vertexSource->getVertex(vertices[1]);
Vector3 p1 = pv1->getVector();
Vertex3* pv2 = vertexSource->getVertex(vertices[2]);
Vector3 p2 = pv2->getVector();
FaceData* uv = getTexCoords0();
if ((uv == 0) 
    || (uv->getNumVectors() < 3))
{
    *binormal = (p2 - p0).normalize();
    return *binormal;
}
// Calculate binormal vector according to texture coordinates.
Vector* uv0 = Ionflux::ObjectBase::nullPointerCheck(
    uv->getVector(0), this, "getBinormal", "Texture coordinate vector");
Vector* uv1 = Ionflux::ObjectBase::nullPointerCheck(
    uv->getVector(1), this, "getBinormal", "Texture coordinate vector");
Vector* uv2 = Ionflux::ObjectBase::nullPointerCheck(
    uv->getVector(2), this, "getBinormal", "Texture coordinate vector");
double u0 = uv0->getElement(0);
double v0 = uv0->getElement(1);
double u1 = uv1->getElement(0);
double v1 = uv1->getElement(1);
double u2 = uv2->getElement(0);
double v2 = uv2->getElement(1);
*binormal = 1. / ((v2 - v0) * (u1 - u0) 
    - (v1 - v0) * (u2 - u0)) 
    * ((u1 - u0) * (p2 - p0) - (u2 - u0) * (p1 - p0));
>>>
    return = {
        value = *binormal
        desc = Binormal vector
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getNormal
    desc = Get normal vector
	longDesc = Get the normal vector for the face.
    impl = <<<
if (normal != 0)
    return *normal;
Vector3 t = getTangent();
Vector3 b = getBinormal();
normal = new Vector3();
if (normal == 0)
    throw GeoUtilsError(getErrorString("Could not allocate object.", 
        "getNormal"));
addLocalRef(normal);
*normal = t.cross(b).normalize();
>>>
    return = {
        value = *normal
        desc = Normal vector
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix3
	name = getTangentBase
    desc = Get tangent base matrix
	longDesc = Calculates the base matrix of the tangent space for the face.
    impl = <<<
Matrix3 m;
m.setC0(getTangent());
m.setC1(getBinormal());
m.setC2(getNormal());
>>>
    return = {
        value = m
        desc = Tangent space base matrix
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3*
	name = getPolygon
    desc = Get polygon
	longDesc = Get a polygon corresponding to the (transformed) face. The polygon uses copies of the face vertices since polygons may be transformed individually.
    impl = <<<
if (vertexSource == 0)
    throw GeoUtilsError(getErrorString("Vertex source is not set.", 
        "getPolygon"));
if (polygon != 0)
    return polygon;
polygon = Polygon3::create();
addLocalRef(polygon);
polygon->copyTransform(*vertexSource);
for (UIntVector::iterator i = vertices.begin(); i != vertices.end(); i++)
    polygon->addVertex(vertexSource->getVertex(*i)->copy());
polygon->createEdges();
if (useTransform);
    polygon->transform(transformMatrix);
if (useVI);
    polygon->transformVI(viewMatrix, &imageMatrix);
>>>
    return = {
        value = polygon
        desc = Polygon corresponding to the face
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkLineInner
	shortDesc = Check line intersection
	longDesc = Check whether the specified line intersects the object. Returns \c true if the line intersects the object, \c false otherwise.
    param[] = {
        type = const Ionflux::GeoUtils::Line3&
        name = line
        desc = Line
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
Polygon3* p = getPolygon();
bool result = line.intersectionInPoly(*p, t);
>>>
    return = {
        desc = Result of the test
        value = result
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkPlaneInner
	shortDesc = Check position relative to plane
	longDesc = Check the object position relative to a plane. Unlike checkPlane(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is above the plane (in direction of the normal of the plane), 0 if the object intersects the plane, and -1 if the object is below the plane.
    param[] = {
        type = const Ionflux::GeoUtils::Plane3&
        name = plane
        desc = Plane
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
Polygon3* p = getPolygon();
bool e0 = true;
int c0 = 0;
int c1 = 1;
for (unsigned int i = 0; i < p->getNumVertices(); i++)
{
    double d = p->getVertex(i)->distanceToPlane(plane);
    if (lt(d, 0., t))
        c1 = -1;
    else
    if (gt(d, 0., t))
        c1 = 1;
    else
        c1 = 0;
    if (e0)
    {
        // Initialize comparison value on first iteration.
        c0 = c1;
        e0 = false;
    }
    else 
    {
        /* If there are two vertices on opposite sides of the plane, 
           there is some intersection for this face. */
        if (c0 != c1)
            return 0;
    }
}
>>>
    return = {
        desc = Result of the test
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkSphereInner
	shortDesc = Check position relative to sphere
	longDesc = Check the object position relative to a sphere. Unlike checkSphere(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is inside the sphere, 0 if the object intersects the sphere, and -1 if the object is outside the sphere.
    param[] = {
        type = const Ionflux::GeoUtils::Sphere3&
        name = sphere
        desc = Sphere
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
Polygon3* p = getPolygon();
Plane3 pl0 = p->getPlane();
// Check planarity of the face.
double d0 = 0.;
for (unsigned int i = 0; i < p->getNumVertices(); i++)
{
    double d0 = p->getVertex(i)->distanceToPlane(pl0);
    if (!eq(d0, 0., t))
    {
        // Face is not planar, we have to stick with the bounding box.
        return checkSphere(sphere, t);
    }
}
// Polygon is planar.
Vertex3 sp = Vertex3(sphere.getP());
d0 = sp.distanceToPlane(pl0);
double sr = sphere.getR();
if (gt(d0, sr, t))
{
    /* Face is outside the sphere, since the minimum distance 
       between the face and the sphere center is greater than the 
       sphere radius. */
    return 1;
}
// There may be some intersection, check all vertices.
int c0 = 0;
int c1 = 0;
bool e0 = true;
for (unsigned int i = 0; i < p->getNumVertices(); i++)
{
    double d = (p->getVertex(i)->getVector() - sphere.getP()).norm();
    if (lt(d, sr, t))
        c1 = -1;
    else
    if (gt(d, sr, t))
        c1 = 1;
    else
        c1 = 0;
    if (e0)
    {
        // Initialize comparison value on first iteration.
        c0 = c1;
        e0 = false;
    }
    else 
    {
        /* If there are two vertices on opposite sides of the sphere, 
           there is some intersection for this face. */
        if (c0 != c1)
            return 0;
    }
}
>>>
    return = {
        desc = Result of the test
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkBoxInner
	shortDesc = Check box intersection.
	longDesc = Check whether the specified box intersects the object. Unlike checkBox(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is inside the other box, 0 if the object intersects the other box, and -1 if the object is outside the other box.
    param[] = {
        type = const Ionflux::GeoUtils::BoxBoundsItem&
        name = other
        desc = Box bounds item
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
Polygon3* p = getPolygon();
if (!p->isPlanar())
    // Face is not planar, we have to stick with the bounding box.
    return checkBox(other, t);
// Polygon is planar.
Plane3 pl0 = p->getPlane();
Vertex3 bc = Vertex3(other.getCenter());
double d0 = bc.distanceToPlane(pl0);
double br = other.getRadius();
if (gt(d0, br, t))
{
    /* Face is outside the box, since the minimum distance 
       between the face and the box center is greater than the 
       radius of the bounding sphere of the box. */
    return 1;
}
// There may be some intersection, check all vertices.
int c0 = 0;
int c1 = 0;
bool e0 = true;
Range3 r0 = other.getBounds();
for (unsigned int i = 0; i < p->getNumVertices(); i++)
{
    Range3 r1(p->getVertex(i)->getVector());
    RangeCompResult rcs0 = r0.compare(r1, t);
    if (rcs0 == RANGE_FIRST_CONTAINS)
        c1 = -1;
    else
    if (rcs0 == RANGE_DISJOINT)
        c1 = 1;
    else
        c1 = 0;
    if (e0)
    {
        // Initialize comparison value on first iteration.
        c0 = c1;
        e0 = false;
    }
    else 
    {
        /* If there are two vertices on opposite sides of the box, 
           there is some intersection for this face. */
        if (c0 != c1)
            return 0;
    }
}
>>>
    return = {
        desc = Result of the comparison
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FaceVector
	name = getTris
	shortDesc = Get triangle faces
	longDesc = Create triangles for a quad face. The new faces are not referenced and must be managed by the caller.
    impl = <<<
if (vertexSource == 0)
    throw GeoUtilsError("Vertex source is not set.");
if (vertices.size() != 4)
    throw GeoUtilsError("Face is not a quad.");
FaceVector result;
UIntVector v0;
v0.push_back(vertices[0]);
v0.push_back(vertices[1]);
v0.push_back(vertices[2]);
UIntVector v1;
v1.push_back(vertices[0]);
v1.push_back(vertices[2]);
v1.push_back(vertices[3]);
FaceData* uv0 = 0;
FaceData* uv1 = 0;
FaceData* uv = getTexCoords0();
if ((uv != 0) 
    && (uv->getNumVectors() == vertices.size()))
{
    uv0 = FaceData::create();
    uv0->addVector(Ionflux::ObjectBase::nullPointerCheck(
        uv->getVector(0), this, "Texture coordinate vector")->copy());
    uv0->addVector(Ionflux::ObjectBase::nullPointerCheck(
        uv->getVector(1), this, "Texture coordinate vector")->copy());
    uv0->addVector(Ionflux::ObjectBase::nullPointerCheck(
        uv->getVector(2), this, "Texture coordinate vector")->copy());
    uv1 = FaceData::create();
    uv1->addVector(Ionflux::ObjectBase::nullPointerCheck(
        uv->getVector(0), this, "Texture coordinate vector")->copy());
    uv1->addVector(Ionflux::ObjectBase::nullPointerCheck(
        uv->getVector(2), this, "Texture coordinate vector")->copy());
    uv1->addVector(Ionflux::ObjectBase::nullPointerCheck(
        uv->getVector(3), this, "Texture coordinate vector")->copy());
}
Face* f0 = Face::create(&v0, vertexSource, uv0);
result.push_back(f0);
Face* f1 = Face::create(&v1, vertexSource, uv1);
result.push_back(f1);
>>>
    return = {
        desc = Vector containing triangle faces
        value = result
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isPlanar
	shortDesc = Planar face check
	longDesc = Check whether the face is planar.
    impl = Polygon3* p = getPolygon();
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    return = {
        value = p->isPlanar(t)
        desc = \c true if the face is planar, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = makePlanar
	shortDesc = Make face planar
	longDesc = Make the face planar. If the optional parameter is specified, vertices will be moved only by the specified fraction of the offset required to make the face planar. The transformations (if any) are applied immediately to the vertices.
	param[] = {
	    type = double
	    name = p
	    desc = Parameter
	    default = 1.
	}
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
if (isPlanar(t))
    return;
if (vertexSource == 0)
    throw GeoUtilsError(getErrorString("Vertex source is not set.", 
        "makePlanar"));
if (vertices.size() < 3)
    throw GeoUtilsError(getErrorString(
        "Face does not have enough vertices.", "makePlanar"));
Vertex3Set vs;
for (UIntVector::iterator i = vertices.begin(); i != vertices.end(); i++)
    vs.addVertex(vertexSource->getVertex(*i)->copy());
Plane3 pl = vs.getPlaneFit();
Vector3 n0 = pl.getNormal();
for (UIntVector::iterator i = vertices.begin(); i != vertices.end(); i++)
{
    Vertex3* v0 = vertexSource->getVertex(*i);
    double d0 = v0->distanceToPlane(pl);
    Vector3 offset = n0 * (-d0 * p);
    v0->translate(offset);
    v0->applyTransform();
}
update();
>>>
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator==
	const = true
	shortDesc = Comparison operator: equality
	longDesc = Compare equality.
	param[] = {
		type = const Ionflux::GeoUtils::Face&
		name = other
		desc = Face
	}
    impl = <<<
if (vertices.size() != other.vertices.size()) 
    return false;
if (vertexSource != other.vertexSource)
    return false;
bool result = true;
unsigned int i = 0;
while (result 
    && (i < vertices.size()))
{
    if (vertices[i] != other.vertices[i])
        result = false;
    i++;
}
if ((faceData == 0) 
    && (other.faceData == 0))
    return result;
if ((faceData == 0) 
    && (other.faceData != 0))
    return false;
if ((faceData != 0) 
    && (other.faceData == 0))
    return false;
if (*faceData != *other.faceData)
    return false;
>>>
	return = {
        value = result
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator!=
	const = true
	shortDesc = Comparison operator: inequality
	longDesc = Compare inequality.
	param[] = {
		type = const Ionflux::GeoUtils::Face&
		name = other
		desc = Face
	}
	return = {
        value = !(*this == other);
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isBackface
	shortDesc = Backface check
	longDesc = Check whether the face faces backwards relative to the specified front vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = front
		desc = Front vector
	}
    impl = <<<
if (normal == 0)
    getNormal();
if (normal->angle(front) > (0.5 * M_PI))
    return true;
>>>
    return = {
        value = false
        desc = The duplicated object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getBarycenter
	shortDesc = Get barycenter
	longDesc = Get the barycenter vector for the face.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "getBarycenter", "Vertex source");
Polygon3* p0 = getPolygon();
Vector3 b0 = p0->getBarycenter();
>>>
    return = {
        value = b0
        desc = Barycenter vector
    }
}
function.protected[] = {
	spec = virtual
	type = void
	name = recalculateBounds
	shortDesc = Recalculate bounds
	longDesc = Recalculate the bounds for the face.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "recalculateBounds", "Vertex source");
TransformableObject::recalculateBounds();
Polygon3* p0 = getPolygon();
*boundsCache = p0->getBounds();
bounds = *boundsCache;
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Range3
	name = getBounds
	shortDesc = Get bounds
	longDesc = Get the bounds for the transformable object.
	impl = bounds = TransformableObject::getBounds();
    return = {
        value = bounds
        desc = Bounds
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = applyTransform
	shortDesc = Apply transformations
	longDesc = Apply transformations that have been accumulated in the transformation matrices.
	param[] = {
	    type = bool
	    name = recursive
	    desc = Apply transformations recursively
	    default = false
	}
    impl = <<<
log(IFLogMessage("Cannot apply transform to face "
    "(should be applied to vertex source instead).", VL_WARNING, 
    this, "applyTransform"));
clearTransformations();
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = scale
	shortDesc = Scale
	longDesc = Scale the object by the specified scale factors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = s
		desc = Vector of scale factors
	}
    impl = TransformableObject::scale(s);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = translate
	shortDesc = Translate
	longDesc = Translate the object by the specified vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = t
		desc = Translation vector
	}
    impl = TransformableObject::translate(t);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = rotate
	shortDesc = Rotate
	longDesc = Rotate the object by the specified angle around the specified axis.
	param[] = {
		type = double
		name = phi
		desc = Angle
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = axis
		desc = Axis
        default = Ionflux::GeoUtils::AXIS_Z
	}
    impl = TransformableObject::rotate(phi, axis);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = normalize
	shortDesc = Normalize
	longDesc = Normalize the object, i.e. scale to unit size.
    impl = TransformableObject::normalize();
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = center
	shortDesc = Center
	longDesc = Center the object using the specified method and origin vector.
	param[] = {
		type = Ionflux::GeoUtils::CenteringMethod
		name = method
		desc = Centering method
        default = Ionflux::GeoUtils::CENTER_BARYCENTER
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector3*
		name = origin
		desc = Origin or offset vector
        default = 0
	}
    impl = TransformableObject::center(method, origin);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix4&
		name = matrix
		desc = Transformation matrix
	}
    impl = <<<
log(IFLogMessage("Transforming face.", VL_WARNING, this, 
    "transform"));
TransformableObject::transform(matrix);
>>>
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = matrix
		desc = Transformation matrix
	}
    impl = TransformableObject::transform(matrix);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = duplicate
	shortDesc = Duplicate
	longDesc = Create an exact duplicate of the object. The duplicate is a new object which must be managed by the caller.
    impl = 
    return = {
        value = *copy()
        desc = The duplicated object
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object
	impl = <<<
std::ostringstream status;
bool e0 = true;
// vertices
status << "verts: ";
unsigned int numVerts = vertices.size();
if (numVerts > 0)
{
    status << "(";
    for (UIntVector::const_iterator i = vertices.begin(); 
        i != vertices.end(); i++)
    {
        if (!e0)
            status << ", ";
        else
            e0 = false;
        status << *i;
    }
    status << ")";
} else
    status << "<none>";
// face data
if (faceData != 0)
{
    status << "; faceData: [" 
        << faceData->getValueString() << "]";
}
// transformable object data
std::string ts0(TransformableObject::getValueString());
if (ts0.size() > 0)
    status << "; " << ts0;
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}

# Legacy functions.
function.public[] = {
	spec = virtual
	type = std::string
	name = getXMLDataVertices_legacy
	const = true
	shortDesc = Get XML data representation for vertex indices
	longDesc = Get a representation of the vertex indices suitable for use in an XML data attribute.
	impl = ostringstream d0;\
bool first = true;\
for (UIntVector::const_iterator i = vertices.begin(); \
    i != vertices.end(); i++)\
\{\
    if (!first)\
        d0 << " ";\
    else\
        first = false;\
    d0 << (*i);\
\}
    return = {
        value = d0.str()
        desc = XML data representation of vertex indices
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getXMLDataTexCoords_legacy
	const = true
	shortDesc = Get XML data representation for texture coordinates
	longDesc = Get a representation of the texture coordinates suitable for use in an XML data attribute.
	impl = // NOTE: Not implemented, use the new XML I/O API instead.
    return = {
        value = ""
        desc = XML data representation of UV coordinates
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getXML_legacy
	const = true
	shortDesc = Get XML representation
	longDesc = Get an XML representation of the object.
	impl = ostringstream d0;\
d0 << "<f d=\"" << getXMLDataVertices_legacy() << "\" uv=\"" \
    << getXMLDataTexCoords_legacy() << "\" />";
    return = {
        value = d0.str()
        desc = XML representation
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setFromXMLData_legacy
	shortDesc = Initialize from XML data
	longDesc = Initialize the face from XML data.
	param[] = {
	    type = const std::string&
	    name = vertexData
	    desc = Vertex index data
	}
	param[] = {
	    type = const std::string&
	    name = texCoordData
	    desc = Texture coordinate data
	}
	impl = Ionflux::ObjectBase::StringVector parts0;\
explode(vertexData, " ", parts0);\
for (Ionflux::ObjectBase::StringVector::const_iterator i = \
    parts0.begin(); i != parts0.end(); i++)\
    addVertex(strtol((*i).c_str(), 0, 10));
}

# Pure virtual member functions.

# operations

# Global functions.

