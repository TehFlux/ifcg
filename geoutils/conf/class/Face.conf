# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2010-2012 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Face.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GeoUtils - Ionflux' Geometry Library; if not, write to the 
# Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
# 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/types.hpp"'
        '"geoutils/Matrix3.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/Vertex3Set.hpp"'
    }
}

# forward declarations
#forward = {
#}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Face
	shortDesc = Mesh face
	title = Mesh face
	longDesc = A mesh face.
	group.name = geoutils
	base = {
		## base classes from the IFObject hierarchy
		#ifobject[] = {
		#	name = IFObject
		#}
        # other base classes
        other[] = {
			name = Ionflux::GeoUtils::BoxBoundsItem
            include = geoutils/BoxBoundsItem.hpp
		}
        other[] = {
			name = Ionflux::GeoUtils::TransformableObject
            include = geoutils/TransformableObject.hpp
		}
	}
    features = {
        'logmessage'
        'classinfo'
        'copy'
        'upcast'
        'create'
    }
    create.allocationError = GeoUtilsError("Could not allocate object.")
}

# Member variables.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    style = vector
    name = vertices
    desc = Vertex index vector
    element = {
        type = unsigned int
        name = Vertex
        plural = Vertices
        #managed = true
    }
}
property.protected[] = {
    style = vector
    name = uv
    desc = Texture coordinates vector
    element = {
        type = Ionflux::GeoUtils::TexCoords
        name = TexCoord
        defaultValue = Ionflux::GeoUtils::DEFAULT_TEX_COORDS
        #plural = TexCoords
        #managed = true
    }
}
property.protected[] = {
    style = vector
    name = vertexColors
    desc = Vertex color vector
    element = {
        type = Ionflux::GeoUtils::Color
        name = VertexColor
        defaultValue = Ionflux::GeoUtils::DEFAULT_VERTEX_COLOR
        #plural = Colors
        #managed = true
    }
#    extendedAddFuncs = true
}
property.protected[] = {
    # NOTE: There should be no need for the vertex source to be managed by 
    #       the faces, since usually the faces are managed by a higher level 
    #       object that also manages the vertex source.
	type = Ionflux::GeoUtils::Vertex3Set*
	setFromType = Ionflux::GeoUtils::Vertex3Set*
	name = vertexSource
	desc = Vertex source
#   managed = true
#   copy = true
#   proxy = true
}

# Protected variables.
variable.protected[] = {
       type = Ionflux::GeoUtils::Vector3*
       name = tangent
       desc = Tangent vector
}
variable.protected[] = {
       type = Ionflux::GeoUtils::Vector3*
       name = normal
       desc = Normal vector
}
variable.protected[] = {
       type = Ionflux::GeoUtils::Vector3*
       name = binormal
       desc = Binormal vector
}
variable.protected[] = {
       type = Ionflux::GeoUtils::Polygon3*
       name = polygon
       desc = Polygon
}

# Public static constants.
constant.public[] = {
       type = unsigned int
       name = VERTEX_INDEX_NONE
       desc = Vertex index not pointing at any vertex
       value = UINT_MAX
}

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = tangent
        value = 0
    }
    initializer[] = {
        name = normal
        value = 0
    }
    initializer[] = {
        name = binormal
        value = 0
    }
    initializer[] = {
        name = polygon
        value = 0
    }
    initializer[] = {
        name = vertexSource
        value = 0
    }
    impl = 
}
constructor.public[] = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = tangent
        value = 0
    }
    initializer[] = {
        name = normal
        value = 0
    }
    initializer[] = {
        name = binormal
        value = 0
    }
    initializer[] = {
        name = polygon
        value = 0
    }
    initializer[] = {
        name = vertexSource
        value = initVertexSource
    }
    param[] = {
        name = initVerts
        type = const Ionflux::ObjectBase::UIntVector*
        desc = Vertex index vector
    }
    param[] = {
        name = initVertexSource
        type = Ionflux::GeoUtils::Vertex3Set*
        desc = Vertex source
        default = 0
    }
    param[] = {
        name = initUV
        type = const Ionflux::GeoUtils::TexCoordsVector*
        desc = Texture coordinates
        default = 0
    }
    param[] = {
        name = initVertexColors
        type = const Ionflux::GeoUtils::ColorVector*
        desc = Vertex colors
        default = 0
    }
    impl = if (initVerts != 0)\
    addVertices(*initVerts);\
if (initVertexSource != 0)\
    setVertexSource(initVertexSource);\
if (initUV != 0)\
    addTexCoords(*initUV);\
if (initVertexColors != 0)\
    addVertexColors(*initVertexColors);\
update();
}
constructor.public[] = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = tangent
        value = 0
    }
    initializer[] = {
        name = normal
        value = 0
    }
    initializer[] = {
        name = binormal
        value = 0
    }
    initializer[] = {
        name = polygon
        value = 0
    }
    initializer[] = {
        name = vertexSource
        value = initVertexSource
    }
	param[] = {
		type = unsigned int
		name = v0
		desc = Vertex index (0)
	}
	param[] = {
		type = unsigned int
		name = v1
		desc = Vertex index (1)
	}
	param[] = {
		type = unsigned int
		name = v2
		desc = Vertex index (2)
	}
	param[] = {
		type = unsigned int
		name = v3
		desc = Vertex index (3)
		default = Ionflux::GeoUtils::Face::VERTEX_INDEX_NONE
	}
    param[] = {
        name = initVertexSource
        type = Ionflux::GeoUtils::Vertex3Set*
        desc = Vertex source
        default = 0
    }
    param[] = {
        name = initUV
        type = const Ionflux::GeoUtils::TexCoordsVector*
        desc = Texture coordinates
        default = 0
    }
    param[] = {
        name = initVertexColors
        type = const Ionflux::GeoUtils::ColorVector*
        desc = Vertex colors
        default = 0
    }
    impl = addVertices(v0, v1, v2, v3);\
if (initVertexSource != 0)\
    setVertexSource(initVertexSource);\
if (initUV != 0)\
    addTexCoords(*initUV);\
if (initVertexColors != 0)\
    addVertexColors(*initVertexColors);\
update();
}

# Destructor.
destructor.impl = clear();

# Protected member functions.

# Public member functions.
function.copy.impl = clear();\
for (UIntVector::const_iterator i = other.vertices.begin(); \
    i != other.vertices.end(); i++)\
    vertices.push_back(*i);\
uv = other.uv;\
vertexColors = other.vertexColors;\
setVertexSource(other.vertexSource);\
update();
function.public[] = {
	spec = virtual
	type = void
	name = copyVertices
	shortDesc = Copy vertices
	longDesc = Create a new vertex set with copies of the current vertices. This makes the face the (current) single owner of its vertices.
    impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source not set.");\
setVertexSource(&(vertexSource->duplicate()));
}
function.public[] = {
	spec = virtual
	type = void
	name = update
	shortDesc = Update
	longDesc = Update all state according to the vertices of the face.
    impl = if ((vertexSource == 0) \
    || (vertices.size() == 0))\
    return;\
clearTangentSpace();\
clearPolygon();\
recalculateBounds();\
updateRadiusAndCenter();
}
function.public[] = {
	spec = virtual
	type = void
	name = clearTangentSpace
	shortDesc = Clear tangent space
	longDesc = Clear the tangent space vectors.
    impl = if (tangent != 0)\
    removeLocalRef(tangent);\
tangent = 0;\
if (normal != 0)\
    removeLocalRef(normal);\
normal = 0;\
if (binormal != 0)\
    removeLocalRef(binormal);\
binormal = 0;
}
function.public[] = {
	spec = virtual
	type = void
	name = clearPolygon
	shortDesc = Clear polygon
	longDesc = Clear the face polygon.
    impl = if (polygon != 0)\
    removeLocalRef(polygon);\
polygon = 0;
}
function.public[] = {
	spec = virtual
	type = void
	name = clear
	shortDesc = Clear
	longDesc = Removes all items and resets state.
    impl = vertices.clear();\
setVertexSource(0);\
uv.clear();\
clearTangentSpace();\
clearPolygon();\
BoxBoundsItem::clear();
}
function.public[] = {
	spec = virtual
	type = void
	name = addVertices
	shortDesc = Add vertex indices
	longDesc = Add vertex indices for a triangle or quad.
	param[] = {
		type = unsigned int
		name = v0
		desc = Vertex index (0)
	}
	param[] = {
		type = unsigned int
		name = v1
		desc = Vertex index (1)
	}
	param[] = {
		type = unsigned int
		name = v2
		desc = Vertex index (2)
	}
	param[] = {
		type = unsigned int
		name = v3
		desc = Vertex index (3)
		default = Ionflux::GeoUtils::Face::VERTEX_INDEX_NONE
	}
    impl = addVertex(v0);\
addVertex(v1);\
addVertex(v2);\
if (v3 != VERTEX_INDEX_NONE)\
    addVertex(v3);
}
function.public[] = {
	spec = virtual
	type = void
	name = addVertices
	shortDesc = Add vertex indices
	longDesc = Add vertex indices from a vertex vector.
	param[] = {
		type = const Ionflux::ObjectBase::UIntVector&
		name = newVerts
		desc = Vertex indices
	}
    impl = for (UIntVector::const_iterator i = newVerts.begin(); \
    i != newVerts.end(); i++)\
    addVertex(*i);
}
function.public[] = {
	spec = virtual
	type = void
	name = addTexCoords
	shortDesc = Add texture coordinates
	longDesc = Add texture coordinates from a texture coordinates vector.
	param[] = {
		type = const Ionflux::GeoUtils::TexCoordsVector&
		name = newTexCoords
		desc = Texture coordinates
	}
    impl = for (TexCoordsVector::const_iterator i = newTexCoords.begin(); \
    i != newTexCoords.end(); i++)\
    addTexCoord(*i);
}
function.public[] = {
	spec = virtual
	type = void
	name = addVertexColors
	shortDesc = Add vertex colors
	longDesc = Add vertex colors from a vertex color vector.
	param[] = {
		type = const Ionflux::GeoUtils::ColorVector&
		name = newVertexColors
		desc = Vertex colors
	}
    impl = for (ColorVector::const_iterator i = newVertexColors.begin(); \
    i != newVertexColors.end(); i++)\
    addVertexColor(*i);
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getTangent
	shortDesc = Get tangent vector
	longDesc = Get the tangent vector for the face.
    impl = if (tangent != 0)\
    return *tangent;\
if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source is not set.");\
if (vertices.size() < 3)\
    throw GeoUtilsError("Face does not have enough vertices.");\
Vertex3* pv0 = vertexSource->getVertex(vertices[0]);\
Vector3 p0 = pv0->getVector();\
Vertex3* pv1 = vertexSource->getVertex(vertices[1]);\
Vector3 p1 = pv1->getVector();\
tangent = Vector3::create();\
addLocalRef(tangent);\
Vector3 b = getBinormal();\
if (uv.size() < 3)\
\{\
    *tangent = b.ortho(p1 - p0).normalize();\
    return *tangent;\
\}\
TexCoords uv0 = uv[0];\
TexCoords uv1 = uv[1];\
*tangent = 1. / (uv1.u - uv0.u) * ((p1 - p0) - (uv1.v - uv0.v) * b);
    return = {
        value = *tangent
        desc = Tangent vector
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getBinormal
    desc = Get binormal vector
	longDesc = Get the binormal vector for the face.
    impl = if (binormal != 0)\
    return *binormal;\
if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source is not set.");\
if (vertices.size() < 3)\
    throw GeoUtilsError("Face does not have enough vertices.");\
binormal = Vector3::create();\
addLocalRef(binormal);\
Vertex3* pv0 = vertexSource->getVertex(vertices[0]);\
Vector3 p0 = pv0->getVector();\
Vertex3* pv1 = vertexSource->getVertex(vertices[1]);\
Vector3 p1 = pv1->getVector();\
Vertex3* pv2 = vertexSource->getVertex(vertices[2]);\
Vector3 p2 = pv2->getVector();\
if (uv.size() < 3)\
\{\
    *binormal = (p2 - p0).normalize();\
    return *binormal;\
\}\
TexCoords uv0 = uv[0];\
TexCoords uv1 = uv[1];\
TexCoords uv2 = uv[2];\
*binormal = 1. / ((uv2.v - uv0.v) * (uv1.u - uv0.u) \
    - (uv1.v - uv0.v) * (uv2.u - uv0.u)) \
    * ((uv1.u - uv0.u) * (p2 - p0) - (uv2.u - uv0.u) * (p1 - p0));
    return = {
        value = *binormal
        desc = Binormal vector
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getNormal
    desc = Get normal vector
	longDesc = Get the normal vector for the face.
    impl = if (normal != 0)\
    return *normal;\
Vector3 t = getTangent();\
Vector3 b = getBinormal();\
normal = new Vector3();\
if (normal == 0)\
    throw GeoUtilsError("Could not allocate object.");\
addLocalRef(normal);\
*normal = t.cross(b).normalize();
    return = {
        value = *normal
        desc = Normal vector
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix3
	name = getTangentBase
    desc = Get tangent base matrix
	longDesc = Calculates the base matrix of the tangent space for the face.
    impl = Matrix3 m;\
m.setC0(getTangent());\
m.setC1(getBinormal());\
m.setC2(getNormal());
    return = {
        value = m
        desc = Tangent space base matrix
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3*
	name = getPolygon
    desc = Get polygon
	longDesc = Get a polygon corresponding to the (transformed) face. The polygon uses copies of the face vertices since polygons may be transformed individually.
    impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source is not set.");\
if (polygon != 0)\
    return polygon;\
polygon = Polygon3::create();\
addLocalRef(polygon);\
polygon->copyTransform(*vertexSource);\
for (UIntVector::iterator i = vertices.begin(); i != vertices.end(); i++)\
    polygon->addVertex(vertexSource->getVertex(*i)->copy());\
polygon->createEdges();\
if (useTransform);\
    polygon->transform(transformMatrix);\
if (useVI);\
    polygon->transformVI(viewMatrix, &imageMatrix);
    return = {
        value = polygon
        desc = Polygon corresponding to the face
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkLineInner
	shortDesc = Check line intersection
	longDesc = Check whether the specified line intersects the object. Returns \c true if the line intersects the object, \c false otherwise.
    param[] = {
        type = const Ionflux::GeoUtils::Line3&
        name = line
        desc = Line
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = Polygon3* p = getPolygon();\
bool result = line.intersectionInPoly(*p, t);
    return = {
        desc = Result of the test
        value = result
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkPlaneInner
	shortDesc = Check position relative to plane
	longDesc = Check the object position relative to a plane. Unlike checkPlane(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is above the plane (in direction of the normal of the plane), 0 if the object intersects the plane, and -1 if the object is below the plane.
    param[] = {
        type = const Ionflux::GeoUtils::Plane3&
        name = plane
        desc = Plane
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = Polygon3* p = getPolygon();\
bool e0 = true;\
int c0 = 0;\
int c1 = 1;\
for (unsigned int i = 0; i < p->getNumVertices(); i++)\
\{\
    double d = p->getVertex(i)->distanceToPlane(plane);\
    if (lt(d, 0., t))\
        c1 = -1;\
    else\
    if (gt(d, 0., t))\
        c1 = 1;\
    else\
        c1 = 0;\
    if (e0)\
    \{\
        // Initialize comparison value on first iteration.\
        c0 = c1;\
        e0 = false;\
    \}\
    else \
    \{\
        /* If there are two vertices on opposite sides of the plane, \
           there is some intersection for this face. */\
        if (c0 != c1)\
            return 0;\
    \}\
\}
    return = {
        desc = Result of the test
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkSphereInner
	shortDesc = Check position relative to sphere
	longDesc = Check the object position relative to a sphere. Unlike checkSphere(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is inside the sphere, 0 if the object intersects the sphere, and -1 if the object is outside the sphere.
    param[] = {
        type = const Ionflux::GeoUtils::Sphere3&
        name = sphere
        desc = Sphere
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = Polygon3* p = getPolygon();\
Plane3 pl0 = p->getPlane();\
// Check planarity of the face.\
double d0 = 0.;\
for (unsigned int i = 0; i < p->getNumVertices(); i++)\
\{\
    double d0 = p->getVertex(i)->distanceToPlane(pl0);\
    if (!eq(d0, 0., t))\
    \{\
        // Face is not planar, we have to stick with the bounding box.\
        return checkSphere(sphere, t);\
    \}\
\}\
// Polygon is planar.\
Vertex3 sp = Vertex3(sphere.getP());\
d0 = sp.distanceToPlane(pl0);\
double sr = sphere.getR();\
if (gt(d0, sr, t))\
\{\
    /* Face is outside the sphere, since the minimum distance \
       between the face and the sphere center is greater than the \
       sphere radius. */\
    return 1;\
\}\
// There may be some intersection, check all vertices.\
int c0 = 0;\
int c1 = 0;\
bool e0 = true;\
for (unsigned int i = 0; i < p->getNumVertices(); i++)\
\{\
    double d = (p->getVertex(i)->getVector() - sphere.getP()).norm();\
    if (lt(d, sr, t))\
        c1 = -1;\
    else\
    if (gt(d, sr, t))\
        c1 = 1;\
    else\
        c1 = 0;\
    if (e0)\
    \{\
        // Initialize comparison value on first iteration.\
        c0 = c1;\
        e0 = false;\
    \}\
    else \
    \{\
        /* If there are two vertices on opposite sides of the sphere, \
           there is some intersection for this face. */\
        if (c0 != c1)\
            return 0;\
    \}\
\}
    return = {
        desc = Result of the test
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkBoxInner
	shortDesc = Check box intersection.
	longDesc = Check whether the specified box intersects the object. Unlike checkBox(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is inside the other box, 0 if the object intersects the other box, and -1 if the object is outside the other box.
    param[] = {
        type = const Ionflux::GeoUtils::BoxBoundsItem&
        name = other
        desc = Box bounds item
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = Polygon3* p = getPolygon();\
if (!p->isPlanar())\
    // Face is not planar, we have to stick with the bounding box.\
    return checkBox(other, t);\
// Polygon is planar.\
Plane3 pl0 = p->getPlane();\
Vertex3 bc = Vertex3(other.getCenter());\
double d0 = bc.distanceToPlane(pl0);\
double br = other.getRadius();\
if (gt(d0, br, t))\
\{\
    /* Face is outside the box, since the minimum distance \
       between the face and the box center is greater than the \
       radius of the bounding sphere of the box. */\
    return 1;\
\}\
// There may be some intersection, check all vertices.\
int c0 = 0;\
int c1 = 0;\
bool e0 = true;\
Range3 r0 = other.getBounds();\
for (unsigned int i = 0; i < p->getNumVertices(); i++)\
\{\
    Range3 r1(p->getVertex(i)->getVector());\
    RangeCompResult rcs0 = r0.compare(r1, t);\
    if (rcs0 == RANGE_FIRST_CONTAINS)\
        c1 = -1;\
    else\
    if (rcs0 == RANGE_DISJOINT)\
        c1 = 1;\
    else\
        c1 = 0;\
    if (e0)\
    \{\
        // Initialize comparison value on first iteration.\
        c0 = c1;\
        e0 = false;\
    \}\
    else \
    \{\
        /* If there are two vertices on opposite sides of the box, \
           there is some intersection for this face. */\
        if (c0 != c1)\
            return 0;\
    \}\
\}
    return = {
        desc = Result of the comparison
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FaceVector
	name = getTris
	shortDesc = Get triangle faces
	longDesc = Create triangles for a quad face. The new faces are not referenced and must be managed by the caller.
    impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source is not set.");\
if (vertices.size() != 4)\
    throw GeoUtilsError("Face is not a quad.");\
FaceVector result;\
UIntVector v0;\
v0.push_back(vertices[0]);\
v0.push_back(vertices[1]);\
v0.push_back(vertices[2]);\
UIntVector v1;\
v1.push_back(vertices[0]);\
v1.push_back(vertices[2]);\
v1.push_back(vertices[3]);\
TexCoordsVector uv0;\
TexCoordsVector uv1;\
if (uv.size() == vertices.size())\
\{\
    uv0.push_back(uv[0]);\
    uv0.push_back(uv[1]);\
    uv0.push_back(uv[2]);\
    uv1.push_back(uv[0]);\
    uv1.push_back(uv[2]);\
    uv1.push_back(uv[3]);\
\}\
Face* f0 = new Face(&v0, vertexSource, &uv0);\
if (f0 == 0)\
    throw GeoUtilsError("Could not allocate object");\
result.push_back(f0);\
Face* f1 = new Face(&v1, vertexSource, &uv1);\
if (f1 == 0)\
    throw GeoUtilsError("Could not allocate object");\
result.push_back(f1);
    return = {
        desc = Vector containing triangle faces
        value = result
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isPlanar
	shortDesc = Planar face check
	longDesc = Check whether the face is planar.
    impl = Polygon3* p = getPolygon();
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    return = {
        value = p->isPlanar(t)
        desc = \c true if the face is planar, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = makePlanar
	shortDesc = Make face planar
	longDesc = Make the face planar. If the optional parameter is specified, vertices will be moved only by the specified fraction of the offset required to make the face planar. The transformations (if any) are applied immediately to the vertices.
	param[] = {
	    type = double
	    name = p
	    desc = Parameter
	    default = 1.
	}
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = if (isPlanar(t))\
    return;\
if (vertexSource == 0)\
    throw GeoUtilsError("[Face::makePlanar] "\
        "Vertex source is not set.");\
if (vertices.size() < 3)\
    throw GeoUtilsError("[Face::makePlanar] "\
        "Face does not have enough vertices.");\
Vertex3Set vs;\
for (UIntVector::iterator i = vertices.begin(); i != vertices.end(); i++)\
    vs.addVertex(vertexSource->getVertex(*i)->copy());\
Plane3 pl = vs.getPlaneFit();\
Vector3 n0 = pl.getNormal();\
for (UIntVector::iterator i = vertices.begin(); i != vertices.end(); i++)\
\{\
    Vertex3* v0 = vertexSource->getVertex(*i);\
    double d0 = v0->distanceToPlane(pl);\
    Vector3 offset = n0 * (-d0 * p);\
    v0->translate(offset);\
    v0->applyTransform();\
\}\
update();
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator==
	const = true
	shortDesc = Comparison operator: equality
	longDesc = Compare equality.
	param[] = {
		type = const Ionflux::GeoUtils::Face&
		name = other
		desc = Face
	}
    impl = if ((vertices.size() != other.vertices.size()) \
    || (uv.size() != other.uv.size()))\
    return false;\
bool result = true;\
unsigned int i = 0;\
while (result \
    && (i < vertices.size()))\
\{\
    if (vertices[i] != other.vertices[i])\
        result = false;\
    i++;\
\}\
i = 0;\
while (result \
    && (i < uv.size()))\
\{\
    if (uv[i] != other.uv[i])\
        result = false;\
    i++;\
\}\
if (!result \
    || (vertexSource != other.vertexSource))\
    return false;
	return = {
        value = true
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator!=
	const = true
	shortDesc = Comparison operator: inequality
	longDesc = Compare inequality.
	param[] = {
		type = const Ionflux::GeoUtils::Face&
		name = other
		desc = Face
	}
	return = {
        value = !(*this == other);
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getString
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	impl = ostringstream result;\
result << getClassName() << "[verts: [";\
bool e0 = true;\
for (UIntVector::const_iterator i = vertices.begin(); \
    i != vertices.end(); i++)\
\{\
    if (!e0)\
        result << ", ";\
    else\
        e0 = false;\
    result << *i;\
\}\
result << "]; uv: [";\
e0 = true;\
for (TexCoordsVector::const_iterator j = uv.begin(); \
    j != uv.end(); j++)\
\{\
    if (!e0)\
        result << ", ";\
    else\
        e0 = false;\
    result << "(" << (*j).u << ", " << (*j).v << ")";\
\}\
result << "]]";
    return = {
        value = result.str()
        desc = String representation
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isBackface
	shortDesc = Backface check
	longDesc = Check whether the face faces backwards relative to the specified front vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = front
		desc = Front vector
	}
    impl = if (normal == 0)\
    getNormal();\
if (normal->angle(front) > (0.5 * M_PI))\
    return true;
    return = {
        value = false
        desc = The duplicated object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getBarycenter
	shortDesc = Get barycenter
	longDesc = Get the barycenter vector for the face.
	impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source not set.");\
Polygon3* p0 = getPolygon();\
Vector3 b0 = p0->getBarycenter();
    return = {
        value = b0
        desc = Barycenter vector
    }
}
function.protected[] = {
	spec = virtual
	type = void
	name = recalculateBounds
	shortDesc = Recalculate bounds
	longDesc = Recalculate the bounds for the face.
	impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source not set.");\
TransformableObject::recalculateBounds();\
Polygon3* p0 = getPolygon();\
*boundsCache = p0->getBounds();\
bounds = *boundsCache;
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Range3
	name = getBounds
	shortDesc = Get bounds
	longDesc = Get the bounds for the transformable object.
	impl = bounds = TransformableObject::getBounds();
    return = {
        value = bounds
        desc = Bounds
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = applyTransform
	shortDesc = Apply transformations
	longDesc = Apply transformations that have been accumulated in the transformation matrices.
	param[] = {
	    type = bool
	    name = recursive
	    desc = Apply transformations recursively
	    default = false
	}
    impl = log(IFLogMessage("Cannot apply transform to face. "\
    "(Should be applied to vertex source instead.)", VL_WARNING, this, \
    "applyTransform"));
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = scale
	shortDesc = Scale
	longDesc = Scale the object by the specified scale factors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = s
		desc = Vector of scale factors
	}
    impl = TransformableObject::scale(s);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = translate
	shortDesc = Translate
	longDesc = Translate the object by the specified vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = t
		desc = Translation vector
	}
    impl = TransformableObject::translate(t);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = rotate
	shortDesc = Rotate
	longDesc = Rotate the object by the specified angle around the specified axis.
	param[] = {
		type = double
		name = phi
		desc = Angle
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = axis
		desc = Axis
        default = Ionflux::GeoUtils::AXIS_Z
	}
    impl = TransformableObject::rotate(phi, axis);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = normalize
	shortDesc = Normalize
	longDesc = Normalize the object, i.e. scale to unit size.
    impl = TransformableObject::normalize();
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = center
	shortDesc = Center
	longDesc = Center the object using the specified method and origin vector.
	param[] = {
		type = Ionflux::GeoUtils::CenteringMethod
		name = method
		desc = Centering method
        default = Ionflux::GeoUtils::CENTER_BARYCENTER
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector3*
		name = origin
		desc = Origin or offset vector
        default = 0
	}
    impl = TransformableObject::center(method, origin);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix4&
		name = matrix
		desc = Transformation matrix
	}
    impl = log(IFLogMessage("Transforming face.", VL_WARNING, this, \
    "transform"));\
TransformableObject::transform(matrix);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = matrix
		desc = Transformation matrix
	}
    impl = TransformableObject::transform(matrix);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Face&
	name = duplicate
	shortDesc = Duplicate
	longDesc = Create an exact duplicate of the object. The duplicate is a new object which must be managed by the caller.
    impl = 
    return = {
        value = *copy()
        desc = The duplicated object
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Face*
	name = create
	shortDesc = Create face
	longDesc = Create a triangle or a quad face.
	param[] = {
		type = unsigned int
		name = v0
		desc = Vertex index (0)
	}
	param[] = {
		type = unsigned int
		name = v1
		desc = Vertex index (1)
	}
	param[] = {
		type = unsigned int
		name = v2
		desc = Vertex index (2)
	}
	param[] = {
		type = unsigned int
		name = v3
		desc = Vertex index (3)
		default = Ionflux::GeoUtils::Face::VERTEX_INDEX_NONE
	}
    param[] = {
        name = initVertexSource
        type = Ionflux::GeoUtils::Vertex3Set*
        desc = Vertex source
        default = 0
    }
    param[] = {
        name = initUV
        type = const Ionflux::GeoUtils::TexCoordsVector*
        desc = Texture coordinates
        default = 0
    }
    impl = Face* f0 = create();\
f0->addVertices(v0, v1, v2, v3);\
if (initVertexSource != 0)\
    f0->setVertexSource(initVertexSource);\
if (initUV != 0)\
    f0->addTexCoords(*initUV);\
f0->update();
    return = {
        value = f0
        desc = New face
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getXMLDataVertices
	const = true
	shortDesc = Get XML data representation for vertex indices
	longDesc = Get a representation of the vertex indices suitable for use in an XML data attribute.
	impl = ostringstream d0;\
bool first = true;\
for (UIntVector::const_iterator i = vertices.begin(); \
    i != vertices.end(); i++)\
\{\
    if (!first)\
        d0 << " ";\
    else\
        first = false;\
    d0 << (*i);\
\}
    return = {
        value = d0.str()
        desc = XML data representation of vertex indices
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getXMLDataTexCoords
	const = true
	shortDesc = Get XML data representation for texture coordinates
	longDesc = Get a representation of the texture coordinates suitable for use in an XML data attribute.
	impl = ostringstream d0;\
bool first = true;\
for (TexCoordsVector::const_iterator i = uv.begin(); \
    i != uv.end(); i++)\
\{\
    if (!first)\
        d0 << " ";\
    else\
        first = false;\
    d0 << (*i).u << "," << (*i).v;\
\}
    return = {
        value = d0.str()
        desc = XML data representation of UV coordinates
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getXML
	const = true
	shortDesc = Get XML representation
	longDesc = Get an XML representation of the object.
	impl = ostringstream d0;\
d0 << "<f d=\"" << getXMLDataVertices() << "\" uv=\"" \
    << getXMLDataTexCoords() << "\" />";
    return = {
        value = d0.str()
        desc = XML representation
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setFromXMLData
	shortDesc = Initialize from XML data
	longDesc = Initialize the face from XML data.
	param[] = {
	    type = const std::string&
	    name = vertexData
	    desc = Vertex index data
	}
	param[] = {
	    type = const std::string&
	    name = texCoordData
	    desc = Texture coordinate data
	}
	impl = Ionflux::ObjectBase::StringVector parts0;\
explode(vertexData, " ", parts0);\
for (Ionflux::ObjectBase::StringVector::const_iterator i = \
    parts0.begin(); i != parts0.end(); i++)\
    addVertex(strtol((*i).c_str(), 0, 10));\
Vertex3Set vs0;\
extractSVGVertices(texCoordData, vs0);\
for (unsigned int k = 0; k < vs0.getNumVertices(); k++)\
\{\
    Vertex3* v0 = vs0.getVertex(k);\
    TexCoords uv0;\
    uv0.u = v0->getX();\
    uv0.v = v0->getY();\
    addTexCoord(uv0);\
\}
}

# Pure virtual member functions.

# operations

# Global functions.

