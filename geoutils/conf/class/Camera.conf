# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009-2013 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Camera.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/Vector3.hpp"'
        '"geoutils/Vector4.hpp"'
        '"geoutils/Matrix4.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"ifobject/constants.hpp"'
        '"ifobject/objectutils.hpp"'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/Vertex3.hpp"'
    }
}

## forward declarations
#forward = {
#}

# undefine macros

## typedefs
#typedef = {
#}

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Camera
	shortDesc = Camera
	title = Camera
	longDesc = This class implements calculation of camera transformations which are useful if a scene needs to be transformed as it would be seen from a camera set up at a specific point in 3D-space.\
\
The camera orientation can be controlled using several direction vectors:\
\
direction -- The direction in which the camera is pointing. The length of this  vector determines perspective.\
lookAt -- A point in space at which the camera is pointed.\
right -- Vector pointing from the left to the right edge of the screen. This vector in conjunction with up determines the screen size.\
up -- Vector pointing from the bottom to the top edge of the screen. This vector in conjunction with right determines the screen size.\
sky -- Vector pointing towards the sky. This vector can be used to roll the camera along the direction axis without explicitly calculating the up vector.\
angle -- View angle. This is equal to the twice the angle between the direction vector and the sum of the direction vector and half the right vector.
	group.name = geoutils
	base = {
        other[] = {
			name = Ionflux::GeoUtils::TransformableObject
            include = geoutils/TransformableObject.hpp
            inheritanceType = virtual public
            xml = {
                enabled = true
                #getFunc = getTransformableObject
                include = geoutils/TransformableObject
            }
		}
	}
    features = {
        'logmessage'
        'classinfo'
        'copy'
        'upcast'
        'create'
        'xmlio'
    }
    create = {
        allocationError = GeoUtilsError("Could not allocate object.")
        extendedCreate = true
    }
    xml.elementName = camera
}

# Member variables.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3*
	setFromType = Ionflux::GeoUtils::Vector3*
	managed = true
	name = location
	desc = Location vector
	valueType = object
	xml = {
	    child.elementName = location
	    createFunc = createVector3
    }
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3*
	setFromType = Ionflux::GeoUtils::Vector3*
	managed = true
	name = direction
	desc = Direction vector
	valueType = object
	xml = {
	    child.elementName = direction
	    createFunc = createVector3
    }
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3*
	setFromType = Ionflux::GeoUtils::Vector3*
	managed = true
	name = lookAt
	desc = Look-at vector
	valueType = object
	xml = {
	    child.elementName = look_at
	    createFunc = createVector3
    }
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3*
	setFromType = Ionflux::GeoUtils::Vector3*
	managed = true
	name = right
	desc = Right vector
	valueType = object
	xml = {
	    child.elementName = right
	    createFunc = createVector3
    }
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3*
	setFromType = Ionflux::GeoUtils::Vector3*
	managed = true
	name = up
	desc = Up vector
	valueType = object
	xml = {
	    child.elementName = up
	    createFunc = createVector3
    }
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3*
	setFromType = Ionflux::GeoUtils::Vector3*
	managed = true
	name = sky
	desc = Sky vector
	valueType = object
	xml = {
	    child.elementName = sky
	    createFunc = createVector3
    }
}
property.protected[] = {
	type = double
	setFromType = double
	name = angle
	desc = Angle
	valueType = float
	xml.attribute.name = angle
}
property.protected[] = {
	type = double
	setFromType = double
	name = lens
	desc = Lens
	valueType = float
	xml.attribute.name = lens
}
property.protected[] = {
	type = Ionflux::GeoUtils::CameraSetupFlags
	setFromType = const Ionflux::GeoUtils::CameraSetupFlags&
	name = setupFlags
	desc = Setup flags
}

# Public static constants.
constant.public[] = {
    desc = Default right vector
    type = Ionflux::GeoUtils::Vector3
    name = DEFAULT_RIGHT
    value = Ionflux::GeoUtils::Vector3(1.33, 0., 0.)
}
constant.public[] = {
    desc = Default camera setup flags
    type = Ionflux::GeoUtils::CameraSetupFlags
    name = DEFAULT_SETUP_FLAGS
    value = \{ true, true, true, false, false, false, false \}
}
constant.public[] = {
    desc = Camera mode: perspective
    type = Ionflux::GeoUtils::CameraMode
    name = MODE_PERSPECTIVE
    value = 0
}
constant.public[] = {
    desc = Camera mode: orthogonal
    type = Ionflux::GeoUtils::CameraMode
    name = MODE_ORTHO
    value = 1
}
constant.public[] = {
    desc = Offset camera location by direction vector by default
    type = bool
    name = DEFAULT_ADJUST_LOCATION
    value = false
}

# Protected static constants.

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = location
        value = 0
    }
    initializer[] = {
        name = direction
        value = 0
    }
    initializer[] = {
        name = lookAt
        value = 0
    }
    initializer[] = {
        name = right
        value = 0
    }
    initializer[] = {
        name = up
        value = 0
    }
    initializer[] = {
        name = sky
        value = 0
    }
    initializer[] = {
        name = angle
        value = 0.
    }
    initializer[] = {
        name = lens
        value = 0.
    }
    impl = 
}
constructor.public[] = {
    initializer[] = {
        name = location
        value = 0
    }
    initializer[] = {
        name = direction
        value = 0
    }
    initializer[] = {
        name = lookAt
        value = 0
    }
    initializer[] = {
        name = right
        value = 0
    }
    initializer[] = {
        name = up
        value = 0
    }
    initializer[] = {
        name = sky
        value = 0
    }
    initializer[] = {
        name = lens
        value = initLens
    }
    initializer[] = {
        name = setupFlags
        value = initSetupFlags
    }
    param[] = {
        name = initLocation
        type = Ionflux::GeoUtils::Vector3
        desc = Location vector
    }
    param[] = {
        name = initDirection
        type = Ionflux::GeoUtils::Vector3
        desc = Direction vector
        default = Ionflux::GeoUtils::Vector3::E_Z
    }
    param[] = {
        name = initLookAt
        type = Ionflux::GeoUtils::Vector3
        desc = Look-at vector
        default = Ionflux::GeoUtils::Vector3::E_Z
    }
    param[] = {
        name = initRight
        type = Ionflux::GeoUtils::Vector3
        desc = Right vector
        default = Ionflux::GeoUtils::Camera::DEFAULT_RIGHT
    }
    param[] = {
        name = initUp
        type = Ionflux::GeoUtils::Vector3
        desc = Up vector
        default = Ionflux::GeoUtils::Vector3::E_Y
    }
    param[] = {
        name = initSky
        type = Ionflux::GeoUtils::Vector3
        desc = Sky vector
        default = Ionflux::GeoUtils::Vector3::E_Y
    }
    param[] = {
        name = initAngle
        type = double
        desc = Angle
        default = 1.
    }
    param[] = {
        name = initLens
        type = double
        desc = Lens
        default = 24.
    }
    param[] = {
        name = initSetupFlags
        type = Ionflux::GeoUtils::CameraSetupFlags
        desc = Setup flags
        default = Ionflux::GeoUtils::Camera::DEFAULT_SETUP_FLAGS
    }
    impl = <<<
setVectors(initLocation, initDirection, initLookAt, 
    initRight, initUp, initSky);
>>>
}

# Destructor.
#destructor.impl = 

# Protected member functions.
function.protected[] = {
	spec = virtual
	type = void
	name = checkVectors
	shortDesc = Check vectors
	longDesc = Check that all camera configuration vectors are set.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(location, this, 
    "checkVectors", "Location vector");
Ionflux::ObjectBase::nullPointerCheck(direction, this, 
    "checkVectors", "Direction vector");
Ionflux::ObjectBase::nullPointerCheck(lookAt, this, 
    "checkVectors", "Look-at vector");
Ionflux::ObjectBase::nullPointerCheck(right, this, 
    "checkVectors", "Right vector");
Ionflux::ObjectBase::nullPointerCheck(up, this, 
    "checkVectors", "Up vector");
Ionflux::ObjectBase::nullPointerCheck(sky, this, 
    "checkVectors", "Sky vector");
>>>
}

# Public member functions.
function.copy.impl = <<<
if (this == &other)
    return *this;
TransformableObject::operator=(other);
if (other.location != 0)
    setLocation(other.location->copy());
else
    setLocation(0);
if (other.direction != 0)
    setDirection(other.direction->copy());
else
    setDirection(0);
if (other.lookAt != 0)
    setLookAt(other.lookAt->copy());
else
    setLookAt(0);
if (other.right != 0)
    setRight(other.right->copy());
else
    setRight(0);
if (other.up != 0)
    setUp(other.up->copy());
else
    setUp(0);
if (other.sky != 0)
    setSky(other.sky->copy());
else
    setSky(0);
lens = other.lens;
angle = other.angle;
setupFlags = other.setupFlags;
>>>
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getBarycenter
	shortDesc = Get barycenter
	longDesc = Get the barycenter vector.
	impl = <<<
if (location == 0)
    return Vector3::ZERO;
// Adjust for transformation.
Vertex3 v0(*location);
if (useTransform())
    v0.transform(*getTransformMatrix());
if (useVI())
    v0.transformVI(*getViewMatrix(), getImageMatrix());
>>>
    return = {
        value = v0.getVector()
        desc = Barycenter vector
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = applyTransform
	shortDesc = Apply transformations
	longDesc = Apply transformations that have been accumulated in the transformation matrices.
	param[] = {
	    type = bool
	    name = recursive
	    desc = Apply transformations recursively
	    default = false
	}
    impl = <<<
if (!useTransform() && !useVI())
{
    clearTransformations();
    return;
}
checkVectors();
Matrix4 T(getTranslationMatrix());
Matrix4 R(getRotationMatrix(MODE_ORTHO));
Matrix4 TR(T * R);
double dirLen = direction->norm();
/* Calculate the correct length for the direction 
   vector. */
CameraSetupFlags sf = setupFlags;
if (sf.useLens)
{
    angle = 2. * ::atan(16. / lens);
    sf.useAngle = true;
}
if (sf.useAngle)
    dirLen = 0.5 * right->norm() / ::tan(0.5 * angle);
setVectors(
    TR.getC3().getV3(), 
    TR.getC1().getV3() * dirLen, 
    *lookAt, 
    TR.getC0().getV3(), 
    TR.getC2().getV3(), 
    TR.getC2().getV3()
);
validate();
clearTransformations();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = initVectors
	shortDesc = Initialize vectors
	longDesc = Initializes the camera configuration vectors.
	impl = <<<
if (location == 0)
    setLocation(Vector3::create());
if (direction == 0)
    setDirection(Vector3::create());
if (lookAt == 0)
    setLookAt(Vector3::create());
if (right == 0)
    setRight(Vector3::create());
if (up == 0)
    setUp(Vector3::create());
if (sky == 0)
    setSky(Vector3::create());
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = setVectors
	shortDesc = Set configuration vectors
	longDesc = Set the camera configuration vectors.
    param[] = {
        name = initLocation
        type = Ionflux::GeoUtils::Vector3
        desc = Location vector
        default = Ionflux::GeoUtils::Vector3::ZERO
    }
    param[] = {
        name = initDirection
        type = Ionflux::GeoUtils::Vector3
        desc = Direction vector
        default = Ionflux::GeoUtils::Vector3::E_Z
    }
    param[] = {
        name = initLookAt
        type = Ionflux::GeoUtils::Vector3
        desc = Look-at vector
        default = Ionflux::GeoUtils::Vector3::E_Z
    }
    param[] = {
        name = initRight
        type = Ionflux::GeoUtils::Vector3
        desc = Right vector
        default = Ionflux::GeoUtils::Camera::DEFAULT_RIGHT
    }
    param[] = {
        name = initUp
        type = Ionflux::GeoUtils::Vector3
        desc = Up vector
        default = Ionflux::GeoUtils::Vector3::E_Y
    }
    param[] = {
        name = initSky
        type = Ionflux::GeoUtils::Vector3
        desc = Sky vector
        default = Ionflux::GeoUtils::Vector3::E_Y
    }
	impl = <<<
initVectors();
*location = initLocation;
*direction = initDirection;
*lookAt = initLookAt;
*right = initRight;
*up = initUp;
*sky = initSky;
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = setDefault
	shortDesc = Use default settings
	longDesc = Initializes the camera settings with default values. The default camera is at the coordinate origin, looking in positive Z direction, with a screen aspect ratio of 1.33:1.
	impl = <<<
initVectors();
*location = Vector3::ZERO;
*direction = Vector3::E_Z;
*lookAt = Vector3::E_Z;
*right = DEFAULT_RIGHT;
*up = Vector3::E_Y;
*sky = Vector3::E_Y;
angle = 2. * direction->angle((*direction) + 0.5 * (*right));
lens = 16. / ::tan(0.5 * angle);
setupFlags = DEFAULT_SETUP_FLAGS;
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = validate
	shortDesc = Validate camera settings
	longDesc = This method ensures that the camera settings are consistent and usable to generate the view transformation. The following steps are taken in order:\
\
1) Validate angle and direction vector. If angle is defined, direction is adjusted according to angle and right vector. If angle is not defined, angle is calculated according to right and direction vectors.\
2) Validate lookAt vector. If lookAt is not defined, it is set to direction. If lookAt is defined, direction is calculated according to lookAt vector.\
3) Validate direction, right and up vectors. This step ensures that the direction, right and up vectors are orthogonal to each other.\
4) Validate sky and direction vectors. If sky is not defined, sky is set to up. Otherwise, if sky and direction are not orthogonal, sky is orthogonalized to direction.\
\
A new set of setup flags for the camera can be specified as an optional parameter.
    param[] = {
		type = const Ionflux::GeoUtils::CameraSetupFlags*
		name = newSetupFlags
		desc = Setup flags
        default = 0
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
	impl = <<<
checkVectors();
if (newSetupFlags != 0)
    setSetupFlags(*newSetupFlags);
CameraSetupFlags sf = setupFlags;
// <---- DEBUG ----- //
std::ostringstream status;
// ----- DEBUG ----> */
if (sf.useLens)
{
    angle = 2. * ::atan(16. / lens);
    sf.useAngle = true;
}
// Validate angle and direction vector.
if (!eq(angle, 2. * direction->angle((*direction) + 0.5 * (*right)), t))
{
    if (sf.useAngle)
    {
        if (sf.useDirection)
        {
            status.str("");
            status << "Direction vector and angle are both enabled but "
                "not consistent, recalculating direction vector.";
            log(Ionflux::ObjectBase::IFLogMessage(status.str(), 
                Ionflux::ObjectBase::VL_WARNING, this, "validate"));
        }
        *direction = direction->normalize() * 0.5 * right->norm() 
            / ::tan(0.5 * angle);
        // <---- DEBUG ----- //
        std::cerr << "[Camera::validate] DEBUG: "
            <<< "Adjusted direction vector: (" 
            << direction->getValueString() << ")" << std::endl;
        // ----- DEBUG ----> */
        /* <---- DEBUG ----- //
        status.str("");
        status << "direction = " << direction.getString();
        log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
        // ----- DEBUG ----> */
        if (!sf.useLens)
            lens = 16. / ::tan(0.5 * angle);
    } else
    {
        // Angle not enabled.
        angle = 2. * direction->angle((*direction) + 0.5 * (*right));
        lens = 16. / ::tan(0.5 * angle);
        /* <---- DEBUG ----- //
        status.str("");
        status << "angle = " << angle << ", lens = " << lens;
        log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
        // ----- DEBUG ----> */
    }
}
// Validate lookAt vector.
if (!sf.useLookAt)
{
    *lookAt = *direction;
    // <---- DEBUG ----- //
    std::cerr << "[Camera::validate] DEBUG: "
        <<< "Adjusted lookAt vector: (" 
        << lookAt->getValueString() << ")" << std::endl;
    // ----- DEBUG ----> */
    /* <---- DEBUG ----- //
    status.str("");
    status << "lookAt = " << lookAt.getString();
    log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
    // ----- DEBUG ----> */
} else
{
    Vector3 lookAtDirection((*lookAt) - (*location));
    if (direction->angle(lookAtDirection) != 0.)
    {
        if (sf.useDirection)
        {
            status.str("");
            status << "LookAt and direction vectors are both enabled but "
                "not consistent, recalculating direction vector.";
            log(Ionflux::ObjectBase::IFLogMessage(status.str(), 
                Ionflux::ObjectBase::VL_WARNING, this, "validate"));
        }
        *direction = lookAtDirection.normalize() * direction->norm();
        // <---- DEBUG ----- //
        std::cerr << "[Camera::validate] DEBUG: "
            <<< "Adjusted direction vector: (" 
            << direction->getValueString() << ")" << std::endl;
        // ----- DEBUG ----> */
        /* <---- DEBUG ----- //
        status.str("");
        status << "direction = " << direction.getString();
        log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
        // ----- DEBUG ----> */
        // Use direction implicitly from now on.
        sf.useDirection = true;
    }
}
// Validate direction, right and up vectors.
double pi2 = M_PI / 2.;
if ((!eq(right->angle(*direction), pi2, t)) 
    || !eq(direction->angle(*up), pi2, t) 
    || !eq(right->angle(*up), pi2, t))
{
    if (!eq(right->angle(*up), pi2, t))
    {
        // Orthogonalize right and up vectors.
        if (sf.useRight)
        {
            // <---- DEBUG ----- //
            status.str("");
            status << "Up and right vectors are not orthogonal, "
                "recalculating up vector";
            log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG, this, "validate"));
            // ----- DEBUG ----> */
            *up = right->ortho(*up);
            // <---- DEBUG ----- //
            std::cerr << "[Camera::validate] DEBUG: "
                <<< "Adjusted up vector: (" 
                << up->getValueString() << ")" << std::endl;
            // ----- DEBUG ----> */
            /* <---- DEBUG ----- //
            status.str("");
            status << "up = " << up.getString();
            log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
            // ----- DEBUG ----> */
        } else
        {
            // Right not enabled.
            // <---- DEBUG ----- //
            status.str("");
            status << "Up and right vectors are not orthogonal, "
                "recalculating right vector";
            log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG, this, "validate"));
            // ----- DEBUG ----> */
            *right = up->ortho(*right);
            // <---- DEBUG ----- //
            std::cerr << "[Camera::validate] DEBUG: "
                <<< "Adjusted right vector: (" 
                << right->getValueString() << ")" << std::endl;
            // ----- DEBUG ----> */
            /* <---- DEBUG ----- //
            status.str("");
            status << "right = " << right.getString();
            log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
            // ----- DEBUG ----> */
        }
    }
    if (!sf.useDirection)
    {
        // Recalculate direction based on right and up vectors.
        double directionLength = direction->norm();
        *direction = right->cross(*up).normalize() * directionLength;
        // <---- DEBUG ----- //
        std::cerr << "[Camera::validate] DEBUG: "
            <<< "Adjusted direction vector: (" 
            << direction->getValueString() << ")" << std::endl;
        // ----- DEBUG ----> */
        /* <---- DEBUG ----- //
        status.str("");
        status << "direction = " << direction.getString();
        log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
        // ----- DEBUG ----> */
    } else
    {
        // Direction is enabled.
        if (!eq(right->angle(*direction), pi2, t))
        {
            // Orthogonalize direction and right vectors.
            if (sf.useRight)
            {
                // <---- DEBUG ----- //
                status.str("");
                status << "Direction and right vectors are not "
                    "orthogonal, recalculating right vector";
                log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG, this, 
                    "validate"));
                // ----- DEBUG ----> */
            }
            *right = direction->ortho(*right);
            // <---- DEBUG ----- //
            std::cerr << "[Camera::validate] DEBUG: "
                <<< "Adjusted right vector: (" 
                << direction->getValueString() << ")" << std::endl;
            // ----- DEBUG ----> */
            /* <---- DEBUG ----- //
            status.str("");
            status << "right = " << right.getString();
            log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
            // ----- DEBUG ----> */
        }
        if (!eq(direction->angle(*up), pi2, t))
        {
            // Orthogonalize direction and up vectors.
            if (sf.useUp)
            {
                // <---- DEBUG ----- //
                status.str("");
                status << "Direction and up vectors are not "
                    "orthogonal, recalculating right vector";
                log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG, this, 
                    "validate"));
                // ----- DEBUG ----> */
            }
            *up = direction->ortho(*up);
            // <---- DEBUG ----- //
            std::cerr << "[Camera::validate] DEBUG: "
                <<< "Adjusted up vector: (" 
                << up->getValueString() << ")" << std::endl;
            // ----- DEBUG ----> */
            /* <---- DEBUG ----- //
            status.str("");
            status << "up = " << up.getString();
            log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
            // ----- DEBUG ----> */
        }
    }
    /* <---- DEBUG ----- //
    status.str("");
    status << "angle(right, direction) = " << right.angle(direction) 
        << ", angle(direction, up) = " << direction.angle(up) 
        << ", angle(right, up) = " << right.angle(up);
    log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
    // ----- DEBUG ----> */
}
// Validate sky and direction vectors.
if (sf.useUp && !sf.useSky)
    *sky = *up;
if (!eq(sky->angle(*direction), 0., t)
    && !eq(sky->angle(*direction), pi2, t))
{
    // Orthogonalize sky vector.
    *sky = direction->ortho(*sky);
    // <---- DEBUG ----- //
    std::cerr << "[Camera::validate] DEBUG: "
        <<< "Adjusted sky vector: (" 
        << sky->getValueString() << ")" << std::endl;
    // ----- DEBUG ----> */
    /* <---- DEBUG ----- //
    status.str("");
    status << "sky = " << sky.getString();
    log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "validate"));
    // ----- DEBUG ----> */
} else
if (eq(sky->angle(*direction), 0., t))
    *sky = *up;
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix4
	name = getRotationMatrix
	shortDesc = Get rotation matrix
	longDesc = Calculate the rotation matrix for the camera.
    param[] = {
        type = Ionflux::GeoUtils::HandednessID
        name = handedness
        desc = Handedness of the coordinate system
        default = Ionflux::GeoUtils::HANDEDNESS_RIGHT
    }
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = upAxis
        desc = Up axis
        default = Ionflux::GeoUtils::AXIS_Z
    }
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = depthAxis
        desc = Depth axis
        default = Ionflux::GeoUtils::AXIS_Y
    }
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = horizonAxis
        desc = Horizon axis
        default = Ionflux::GeoUtils::AXIS_X
    }
	impl = <<<
checkVectors();
// <---- DEBUG ----- //
std::ostringstream status;
// ----- DEBUG ----> */
/* NOTE: There is probably a way easier way of doing this by creating a 
         matrix from the orthonormalized camera axes and inverting it. */
Vector3 unitUp = Vector3::axis(upAxis);
Vector3 unitDepth = Vector3::axis(depthAxis);
Vector3 unitHorizon = Vector3::axis(horizonAxis);
/* Constants for obtaining direction of rotation depending on 
   handedness of the coordinate system. */
double c[2];
if (handedness == HANDEDNESS_LEFT)
{
    c[0] = -1.;
    c[1] = 1.;
} else
{
    // Assume right-handed coordinate system.
    c[0] = 1.;
    c[1] = -1.;
}
// Calculate yaw angle (global up axis rotation).
double yaw = 0.;
Vector3 hProj(*direction);
if (direction->angle(unitUp) != 0.)
{
    /* Camera is not pointing up. In this case, the yaw angle is the 
       angle between the projection of the direction vector in the 
       horizontal plane and the depth axis. */
    hProj.setElement(upAxis, 0.0);
    yaw = unitDepth.angle(hProj);
} else
{
    /* The camera is pointing up, so the yaw angle is undefined.
       We set the projection to the depth axis unit vector, so the 
      pitch will still be calculated correctly (this will always yield 
      pi/2). */
    hProj = unitDepth;
}
if (hProj[horizonAxis] > 0.)
    yaw *= c[1];
else
    yaw *= c[0];
Matrix3 Y(Matrix3::rotate(yaw, upAxis));
/* Calculate pitch angle (local X rotation)
   This is the angle between the direction vector and its projection in 
   the base plane. */
double pitch = direction->angle(hProj);
if ((*direction)[upAxis] > 0.)
    pitch *= c[0];
else
    pitch *= c[1];
Matrix3 P(Matrix3::rotate(pitch, horizonAxis));
Matrix3 YP = Y * P;
/* Rotate the up axis unit vector with the pitch and yaw matrices. The 
   angle between the rotated up axis unit vector and the camera up vector 
   then defines the roll angle for rotation around the depth axis. */
//Matrix3 YPInv(YP.invert());
Vector3 upRot(YP * unitUp);
double roll = up->angle(upRot);
if (upRot[horizonAxis] > 0.)
    roll *= c[0];
else
    roll *= c[1];
Matrix3 R(Matrix3::rotate(roll, depthAxis));
Matrix4 YPR(YP * R);
// <---- DEBUG ----- //
status.str("");
Vector4 zDir4(Vector3::E_Z * direction->norm());
status << "upAxis = " << axisToString(upAxis) 
    << ", depthAxis = " << axisToString(depthAxis) 
    << ", horizonAxis = " << axisToString(horizonAxis) 
    << ", handedness = " << handednessToString(handedness) 
    << ", yaw = " << yaw << " (" << (yaw * 180.0 / M_PI) << "°)"
    << ", pitch = " << pitch << " (" << (pitch * 180.0 / M_PI) << "°)"
    << ", roll = " << roll << " (" << (roll * 180.0 / M_PI) << "°)"
    << ", Y = " << Y
    << ", P = " << P
    << ", R = " << R
    << ", YPR = " << YPR
    << ", YPR * zDir4 = " << (YPR * zDir4);
log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "getRotationMatrix"));
// ----- DEBUG ----> */
>>>
    return = {
        value = YPR
        desc = Rotation matrix
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix4
	name = getTranslationMatrix
	shortDesc = Get translation matrix
	longDesc = Calculate the camera translation matrix from the camera location. If adjustLocation is set to \c true, the location of the camera will be offset by the direction vector.
    param[] = {
        type = bool
        name = adjustLocation
        desc = Offset camera location by direction vector
        default = Ionflux::GeoUtils::Camera::DEFAULT_ADJUST_LOCATION
    }
    impl = <<<
checkVectors();
if (adjustLocation)
    return Matrix4::translate((*location) + (*direction));
>>>
    return = {
        value = Matrix4::translate(*location)
        desc = Translation matrix
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix4
	name = getPerspectiveMatrix
	shortDesc = Get perspective matrix
	longDesc = Calculate the camera perspective matrix.
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = depthAxis
        desc = Depth axis
        default = Ionflux::GeoUtils::AXIS_Y
    }
    impl = checkVectors();
    return = {
        value = Matrix4::perspective(direction->norm(), depthAxis)
        desc = Perspective matrix
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix4
	name = getModelViewMatrix
	shortDesc = Get model view matrix
	longDesc = Get the model view matrix which can be applied to object coordinates to         create the camera view. mode can be either MODE_PERSPECTIVE (the default) for perspective projection, or MODE_ORTHO for orthogonal projection. If adjustLocation is set to True, the location of the camera will be offset by the direction vector.
    param[] = {
        type = Ionflux::GeoUtils::CameraMode
        name = mode
        desc = Camera mode
        default = Ionflux::GeoUtils::Camera::MODE_PERSPECTIVE
    }
    param[] = {
        type = bool
        name = adjustLocation
        desc = Offset camera location by direction vector
        default = Ionflux::GeoUtils::Camera::DEFAULT_ADJUST_LOCATION
    }
    param[] = {
        type = Ionflux::GeoUtils::HandednessID
        name = handedness
        desc = Handedness of the coordinate system
        default = Ionflux::GeoUtils::HANDEDNESS_RIGHT
    }
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = upAxis
        desc = Up axis
        default = Ionflux::GeoUtils::AXIS_Z
    }
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = depthAxis
        desc = Depth axis
        default = Ionflux::GeoUtils::AXIS_Y
    }
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = horizonAxis
        desc = Horizon axis
        default = Ionflux::GeoUtils::AXIS_X
    }
    impl = <<<
/* <---- DEBUG ----- //
ostringstream status;
// ----- DEBUG ----> */
Matrix4 T(getTranslationMatrix(adjustLocation));
Matrix4 R(getRotationMatrix(handedness, upAxis, depthAxis, horizonAxis));
Matrix4 P;
if (mode == MODE_ORTHO)
    P = Matrix4::UNIT;
else
    P = getPerspectiveMatrix();
Matrix4 TR(T * R);
Matrix4 TRInv = TR.invert();
/* <---- DEBUG ----- //
status.str("");
status << "T = " << T.getString() 
    << ", R = " << R.getString() 
    << ", P = " << P.getString();
log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "getViewMatrix"));
// ----- DEBUG ----> */
>>>
    return = {
        value = P * TRInv
        desc = View matrix
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setOriginCam
	shortDesc = Set up camera focused at the origin
	longDesc = Set up the camera to be pointed at the origin. The camera is created at the specified distance in negative Y-direction and rotated around the global coordinate axes as specified.
    param[] = {
        type = double
        name = distance0
        desc = Distance to origin
        default = 10.
    }
    param[] = {
        type = double
        name = rotX
        desc = Rotation around X axis (in degrees)
        default = -30.
    }
    param[] = {
        type = double
        name = rotY
        desc = Rotation around Y axis (in degrees)
        default = 0.
    }
    param[] = {
        type = double
        name = rotZ
        desc = Rotation around Z axis (in degrees)
        default = 30.
    }
    impl = <<<
initVectors();
/* <---- DEBUG ----- //
ostringstream status;
// ----- DEBUG ----> */
Matrix3 RX(Matrix3::rotate(rotX * M_PI / 180., AXIS_X));
Matrix3 RY(Matrix3::rotate(rotY * M_PI / 180., AXIS_Y));
Matrix3 RZ(Matrix3::rotate(rotZ * M_PI / 180., AXIS_Z));
Matrix3 R(RZ * RX * RY);
*location = R * (-distance0 * Vector3::E_Y);
*lookAt = Vector3::ZERO;
*direction = R * Vector3::E_Y;
*up = R * Vector3::E_Z;
*right = R * (1.33 * Vector3::E_X);
*sky = *up;
setupFlags = DEFAULT_SETUP_FLAGS;
/* <---- DEBUG ----- //
status.str("");
status << "RX = " << RX 
    << ", RY = " << RY 
    << ", RZ = " << RZ 
    << ", R = " << R;
log(Ionflux::ObjectBase::IFLogMessage(status.str(), Ionflux::ObjectBase::VL_DEBUG_OPT, this, "setOriginCam"));
// ----- DEBUG ----> */
validate();
>>>
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object
	impl = <<<
std::ostringstream status;
if (location != 0)
    status << "loc: (" << location->getValueString() << ")";
else
    status << "<none>";
if (direction != 0)
    status << ", dir: (" << direction->getValueString() << ")";
else
    status << "<none>";
if (lookAt != 0)
    status << ", lookAt: (" << lookAt->getValueString() << ")";
else
    status << "<none>";
if (up != 0)
    status << ", up: (" << up->getValueString() << ")";
else
    status << "<none>";
if (right != 0)
    status << ", right: (" << right->getValueString() << ")";
else
    status << "<none>";
if (sky != 0)
    status << ", sky: (" << sky->getValueString() << ")";
else
    status << "<none>";
status << ", angle: " << angle << ", lens: " << lens;
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}

# Pure virtual member functions.

# operations

# Global functions.

