# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009-2011 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# BoundingBox.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/Split.hpp"'
        '"geoutils/SplitSet.hpp"'
        '"geoutils/ItemSource.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '<fstream>'
        '"geoutils/GeoUtilsError.hpp"'
    }
}

# forward declarations
#forward = {
#}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = BoundingBox
	shortDesc = Bounding box
	title = Bounding Box
	longDesc = A bounding box which can contain other BoxBoundsItems.
	group.name = geoutils
	base = {
		## base classes from the IFObject hierarchy
		#ifobject[] = {
		#	name = IFObject
		#}
        # other base classes
        other[] = {
			name = Ionflux::GeoUtils::BoxBoundsItem
            include = geoutils/BoxBoundsItem.hpp
		}
	}
    features = {
        'logmessage'
        'classinfo'
        'copy'
        'create'
        'upcast'
    }
}

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = level
        value = 0
    }
    initializer[] = {
        name = parent
        value = 0
    }
    impl = 
}
constructor.public[] = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = level
        value = initLevel
    }
    initializer[] = {
        name = parent
        value = initParent
    }
    param[] = {
        name = initCenter
        type = const Ionflux::GeoUtils::Vector3&
        desc = Center vector
    }
    param[] = {
        name = initRVec
        type = const Ionflux::GeoUtils::Vector3&
        desc = Radius vector
        default = Ionflux::GeoUtils::Vector3::ZERO
    }
    param[] = {
        name = initItemID
        type = const std::string&
        desc = Item ID
        default = ""
    }
    param[] = {
        name = initLevel
        type = int
        desc = Level
        default = 0
    }
    param[] = {
        name = initItems
        type = const Ionflux::GeoUtils::BoxBoundsItemSet*
        desc = Items
        default = 0
    }
    param[] = {
        name = initParent
        type = Ionflux::GeoUtils::BoundingBox*
        desc = Parent
        default = 0
    }
    impl = if (initItems != 0)\
    addItems(*initItems);\
updateBounds();
}

# Destructor.
#destructor.impl = 

# Member variables.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
	type = int
	setFromType = int
	name = level
	desc = Level
#    copy = true
#    proxy = true
}
property.protected[] = {
	type = Ionflux::GeoUtils::BoundingBox*
	setFromType = Ionflux::GeoUtils::BoundingBox*
	name = parent
	desc = Parent
#   copy = true
#   proxy = true
}
# Protected variables.
variable.protected[] = {
	type = Ionflux::GeoUtils::BoxBoundsItemSet
	name = items
	desc = Items
}

# Public static constants.

# Protected static constants.

# Protected member functions.

# Public member functions.
function.copy.impl = clear();\
center = other.center;\
rVec = other.rVec;\
level = other.level;\
parent = other.parent;\
addItems(other.items);

function.public[] = {
	spec = virtual
	type = void
	name = update
	shortDesc = Update
	longDesc = Update all state according to the items contained in the bounding box. If the bounding box has a parent, the parent will also be updated to reflect the changes.
    impl = if (items.size() == 0) \
    return;\
bool e0 = true;\
for (BoxBoundsItemSet::iterator i = items.begin(); \
    i != items.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    if (e0)\
    \{\
        bounds.setBounds(it->getCenter());\
        e0 = false;\
    \}\
    bounds.extend(it->getCenter() + it->getRVec());\
    bounds.extend(it->getCenter() - it->getRVec());\
\}\
updateRadiusAndCenter();\
if (parent != 0)\
    parent->update();
}
function.public[] = {
	spec = virtual
	type = void
	name = clear
	shortDesc = Clear
	longDesc = Removes all items and resets state.
    impl = for (BoxBoundsItemSet::iterator i = items.begin(); \
    i != items.end(); i++)\
    removeLocalRef(*i);\
items.clear();\
BoxBoundsItem::clear();
}
function.public[] = {
	spec = virtual
	type = bool
	name = addItem
	shortDesc = Add an item to the bounding box.
	longDesc = The dimensions of the bounding box will be updated to reflect the new bounds. If maxRadius is specified, the item will not be added if adding the item would make the radius of the bounding box larger than maxRadius.
    param[] = {
        type = Ionflux::GeoUtils::BoxBoundsItem*
        name = item
        desc = Box bounds item
    }
    param[] = {
        type = double
        name = maxRadius
        desc = Maximum radius
        default = 0.
    }
    impl = if (item == 0)\
    throw GeoUtilsError("Attempt to add null item!");\
if (items.size() == 0)\
    bounds = item->getBounds();\
if (maxRadius > 0)\
\{\
    Range3 b = bounds;\
    b.extend(item->getCenter() + item->getRVec());\
    b.extend(item->getCenter() - item->getRVec());\
    if (b.getRadius().norm() > maxRadius)\
        return false;\
\}\
bounds.extend(item->getCenter() + item->getRVec());\
bounds.extend(item->getCenter() - item->getRVec());\
addLocalRef(item);\
BoundingBox* b0 = dynamic_cast<BoundingBox*>(item);\
if (b0 != 0)\
\{\
    if (b0->getParent() == 0)\
        b0->setParent(this);\
    else\
    \{\
        ostringstream status;\
        status << "Bounding box " << b0->getString() \
            << " is already a child of " << b0->getParent()->getString() \
            << ", parent entry will be left unchanged.";\
        log(IFLogMessage(status.str(), VL_WARNING, this, "addItem"));\
    \}\
\}\
items.insert(item);\
updateRadiusAndCenter();
    return = {
        value = true
        desc = \c true if the item has been added, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = removeItem
	shortDesc = Remove an item from the bounding box.
	longDesc = Remove an item from the bounding box.
    param[] = {
        type = Ionflux::GeoUtils::BoxBoundsItem*
        name = item
        desc = Box bounds item
    }
    param[] = {
        type = bool
        name = update0
        desc = Update state according to changed elements
        default = true
    }
    impl = if (item == 0)\
    throw GeoUtilsError("Attempt to remove null item!");\
BoxBoundsItemSet::iterator i = items.find(item);\
if (i == items.end())\
    return false;\
BoundingBox* b0 = dynamic_cast<BoundingBox*>(item);\
if ((b0 != 0) && (b0->getParent() == this))\
    b0->setParent(0);\
items.erase(i);\
removeLocalRef(*i);\
if (update0)\
    update();
    return = {
        value = true
        desc = \c true if the item has been removed, \c false if the item is not contained in the bounding box
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::BoxBoundsItemSet
	name = addItems
	shortDesc = Add items to the bounding box.
	longDesc = Add items from the specified set to the bounding box. If maxItems is specified, items will not be added if the number of items in the bounding box would exceed maxItems. If maxRadius is specified, items will not be added if the radius of the bounding box would exceed maxRadius.
    param[] = {
        type = const Ionflux::GeoUtils::BoxBoundsItemSet&
        name = newItems
        desc = Set of box bounds items
    }
    param[] = {
        type = unsigned int
        name = maxItems
        desc = Maximum number of items
        default = 0
    }
    param[] = {
        type = double
        name = maxRadius
        desc = Maximum radius
        default = 0.
    }
    impl = Ionflux::GeoUtils::BoxBoundsItemSet remaining;\
for (BoxBoundsItemSet::iterator i = newItems.begin(); \
    i != newItems.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    // Check for maximum number of items.\
    if ((maxItems > 0) \
        && (items.size() >= maxItems))\
        remaining.insert(it);\
    else \
    if (!addItem(it, maxRadius))\
        remaining.insert(it);\
\}
    return = {
        value = remaining
        desc = Set of items that have not been added
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = takeItems
	shortDesc = Add items to the bounding box.
	longDesc = Add items from the specified set to the bounding box. This method removes the items which are added to the bounding box from the source set. If maxItems is specified, items will not be added if the number of items in the bounding box would exceed maxItems. If maxRadius is specified, items will not be added if the radius of the bounding box would exceed maxRadius.
    param[] = {
        type = Ionflux::GeoUtils::BoxBoundsItemSet&
        name = newItems
        desc = Set of box bounds items
    }
    param[] = {
        type = unsigned int
        name = maxItems
        desc = Maximum number of items
        default = 0.
    }
    param[] = {
        type = double
        name = maxRadius
        desc = Maximum radius
        default = 0.
    }
    impl = unsigned int numTaken = 0;\
BoxBoundsItemSet putBack;\
bool finished = false;\
while ((newItems.size() > 0) \
    && !finished)\
\{\
    // Check for maximum number of items.\
    if ((maxItems > 0) \
        && (items.size() >= maxItems)) \
        finished = true;\
    else \
    \{\
        BoxBoundsItemSet::iterator i = newItems.begin();\
        BoxBoundsItem* it = *i;\
        newItems.erase(i);\
        if (addItem(it, maxRadius))\
            numTaken++;\
        else \
            putBack.insert(it);\
    \}\
\}\
newItems.insert(putBack.begin(), putBack.end());
    return = {
        value = numTaken
        desc = Number of items that have been added
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::SplitTestResult
	name = splitTest
	shortDesc = Test bounding box split.
	longDesc = Split the bounding box along the specified axis, but do not change the actual structure of the bounding box contents. The split parameter s is used to determine the position where the split should occur. If s is 0.5, the split occurs at the center of the axis. If 0 < s < 0.5, the split occurs in the lower coordinate half of the axis. If 0.5 > s > 0, the split occurs in the upper coordinate half of the axis.
    param[] = {
        type = const Ionflux::GeoUtils::Split&
        name = split
        desc = Split
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = Ionflux::GeoUtils::SplitTestResult result;\
Range b = bounds.getAxisRange(split.getAxis());\
double sc = b.getValue(split.getS());\
for (BoxBoundsItemSet::iterator i = items.begin(); \
    i != items.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    if (ltOrEq(it->getCenter()[split.getAxis()], sc, t))\
        result.items0.insert(it);\
    else \
        result.items1.insert(it);\
\}
    return = {
        value = result
        desc = Test result
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = updateBestSplit
	shortDesc = Update best split.
	longDesc = Compare the quality parameters of a split to the quality parameters of the best split as specified. If the split is better than the best split, replace the best split with the specified split.
    param[] = {
        type = const Ionflux::GeoUtils::SplitParams&
        name = s
        desc = Split quality parameters
    }
    param[] = {
        type = Ionflux::GeoUtils::SplitParams&
        name = best
        desc = Best split quality parameters
    }
    impl = /* <---- DEBUG ----- //\
ostringstream status;\
// ----- DEBUG ----> */\
if (best.split == 0) \
\{\
    best.split = s.split;\
    best.d = s.d;\
    best.r = s.r;\
\}\
else \
\{\
    if (s.d < best.d)\
    \{\
        best.split = s.split;\
        best.d = s.d;\
        best.r = s.r;\
    \} else \
    if (s.d == best.d)\
    \{\
        // Take the split that is more balanced.\
        unsigned int d0 = ::abs(best.split->getS() - 0.5);\
        unsigned int d1 = ::abs(s.split->getS() - 0.5);\
        /* <---- DEBUG ----- //\
        status.str("");\
        status << "Testing balance for " << *(s.split) \
            << ": (" << d0 << ", " << d1 << ") " << s.d;\
        log(IFLogMessage(status.str(), VL_DEBUG, this, \
            "updateBestSplit"));\
        // ----- DEBUG ----> */\
        if (d1 < d0)\
        \{\
            best.split = s.split;\
            best.d = s.d;\
            best.r = s.r;\
        \}\
    \}\
\}
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Split*
	name = getBestSplit
	shortDesc = Determine best split.
	longDesc = Tests all of the specified splits and returns the one where the difference between item counts in both sets is minimal. Returns 0 if none of the splits results in two sets with at least minItems items per set.
    param[] = {
        type = Ionflux::GeoUtils::SplitSet&
        name = splits
        desc = Splits
    }
    param[] = {
        type = unsigned int
        name = minItems
        desc = Minimum number of items per set
        default = 0
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
	param[] = {
		type = bool
		name = preferLongestAxis
		desc = Prefer split along longest axis.
        default = false
	}
	param[] = {
		type = double
		name = longestAxisTolerance
		desc = Tolerance for preferring the longest axis.
        default = 0.1
	}
    impl = SplitParams best;\
SplitParams prefAxisBest;\
best.split = 0;\
best.d = 0;\
best.r = 0;\
prefAxisBest.split = 0;\
prefAxisBest.d = 0;\
prefAxisBest.r = 0;\
AxisID prefAxis = bounds.getAxisOrder().a0;\
/* <---- DEBUG ----- //\
ostringstream status;\
// ----- DEBUG ----> */\
if (items.size() < (2 * minItems))\
\{\
    /* <---- DEBUG ----- //\
    status.str("");\
    status << "Not enough items in box for splitting (n = " \
        << items.size() << ", minItems = " << minItems << ").";\
    log(IFLogMessage(status.str(), VL_DEBUG, this, \
        "getBestSplit"));\
    // ----- DEBUG ----> */\
    return 0;\
\}\
for (unsigned int i = 0; i < splits.getNumSplits(); i++)\
\{\
    Split* s = splits.getSplit(i);\
    SplitTestResult sr = splitTest(*s, t);\
    unsigned int n0 = sr.items0.size();\
    unsigned int n1 = sr.items1.size();\
    if ((n0 >= minItems) \
        && (n1 >= minItems)) \
    \{\
        // Both sets have enough elements.\
        SplitParams sp0;\
        sp0.split = s;\
        sp0.d = ::abs(n0 - n1);\
        sp0.r = ::abs(1. - (static_cast<double>(n0) / n1));\
        /* <---- DEBUG ----- //\
        status.str("");\
        status << "Testing " << *s \
            << ": (" << n0 << ", " << n1 << ") " << sp0.d;\
        log(IFLogMessage(status.str(), VL_DEBUG, this, \
            "getBestSplit"));\
        // ----- DEBUG ----> */\
        updateBestSplit(sp0, best);\
        if (s->getAxis() == prefAxis)\
            // Update best split along preferred axis.\
            updateBestSplit(sp0, prefAxisBest);\
    \} else \
    \{\
        /* <---- DEBUG ----- //\
        status.str("");\
        status << "Split " << s->getString() << ": (" << n0 << ", " \
            << n1 << ") not usable (minItems = " << minItems << ").";\
        log(IFLogMessage(status.str(), VL_DEBUG, this, \
            "getBestSplit"));\
        // ----- DEBUG ----> */\
    \}\
\}\
if (best.split != 0)\
\{\
    /* <---- DEBUG ----- //\
    status.str("");\
    status << "Best split: (" << axisToString(best.split->getAxis()) \
        << ") " << *(best.split) << " (r = " << best.r << ").";\
    log(IFLogMessage(status.str(), VL_DEBUG, this, "getBestSplit"));\
    // ----- DEBUG ----> */\
    if (prefAxisBest.split != 0)\
    \{\
        /* <---- DEBUG ----- //\
        status.str("");\
        status << "Best split along preferred axis (" \
            << axisToString(prefAxis) << "): " << *(prefAxisBest.split) \
            << " (r = " << prefAxisBest.r << ").";\
        log(IFLogMessage(status.str(), VL_DEBUG, this, "getBestSplit"));\
        // ----- DEBUG ----> */\
        double r0 = 0.;\
        if (prefAxisBest.r != 0.)\
            r0 = ::abs(1. - best.r / prefAxisBest.r);\
        if (preferLongestAxis \
            && (r0 <= longestAxisTolerance))\
        \{\
            // Use the split along the preferred axis.\
            /* <---- DEBUG ----- //\
            status.str("");\
            status << "Using split along preferred axis (" \
                << axisToString(prefAxis) << "): best.r = " << best.r \
                << ", prefAxisBest.r = " << prefAxisBest.r << ", r0 = " \
                << r0;\
            log(IFLogMessage(status.str(), VL_DEBUG, this, \
                "getBestSplit"));\
            // ----- DEBUG ----> */\
            return prefAxisBest.split;\
        \}\
    \}\
    return best.split;\
\}
    return = {
        value = 0
        desc = Best split, or 0 if none of the splits is suitable
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::SplitResult
	name = split
	shortDesc = Split bounding box.
	longDesc = Split the bounding box along the specified axis. If the set of splits contains multiple splits, the best split will be determined and used. The split parameter s is used to determine the position where the split should occur. If s is 0.5, the split occurs at the center of the axis. If 0 < s < 0.5, the split occurs in the lower coordinate half of the axis. If 0.5 > s > 0, the split occurs in the upper coordinate half of the axis. If recursive is set to \c true, the contained boxes will be split recursively until the split boxes contain either less than minItems items or maxLevel is reached. If the split is successful, the split result contains two bounding boxes, which are the new items contained in the bounding box. The success flag of the split result will be set to \c false if the box cannot be split because it does not contain any items, or if one of the recursion limits is reached.
    param[] = {
        type = Ionflux::GeoUtils::SplitSet&
        name = splits
        desc = Splits
    }
    param[] = {
        type = bool
        name = recursive
        desc = Split box hierarchy recursively
        default = false
    }
    param[] = {
        type = unsigned int
        name = minItems
        desc = Minimum number of items per set
        default = 0
    }
    param[] = {
        type = unsigned int
        name = maxLevel
        desc = Maximum split depth
        default = 0
    }
    param[] = {
        type = unsigned int
        name = splitLevel
        desc = Current split level
        default = 0
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
	param[] = {
		type = bool
		name = preferLongestAxis
		desc = Prefer split along longest axis.
        default = false
	}
	param[] = {
		type = double
		name = longestAxisTolerance
		desc = Tolerance for preferring the longest axis.
        default = 0.1
	}
    impl = SplitResult result;\
// <---- DEBUG ----- //\
ostringstream status;\
// ----- DEBUG ----> */\
if (items.size() == 0)\
\{\
    /* <---- DEBUG ----- //\
    status << "Nothing to split (level = " << splitLevel << ").";\
    log(IFLogMessage(status.str(), VL_DEBUG, this, "split"));\
    // ----- DEBUG ----> */\
    result.success = false;\
    return result;\
\}\
if (recursive)\
\{\
    // Check the abort conditions for recursive splitting.\
    if ((minItems > 0) \
        && (items.size() <= minItems))\
    \{\
        /* <---- DEBUG ----- //\
        status.str("");\
        status << "Not enough items for splitting (level = " \
            << splitLevel << ").";\
        log(IFLogMessage(status.str(), VL_DEBUG, this, "split"));\
        // ----- DEBUG ----> */\
        result.success = false;\
        return result;\
    \}\
    if ((maxLevel > 0) \
        && (splitLevel >= maxLevel))\
    \{\
        /* <---- DEBUG ----- //\
        status.str("");\
        status << "Maximum level reached (level = " \
            << splitLevel << ").";\
        log(IFLogMessage(status.str(), VL_DEBUG, this, "split"));\
        // ----- DEBUG ----> */\
        result.success = false;\
        return result;\
    \}\
\}\
Split* split = 0;\
if (splits.getNumSplits() == 1)\
    split = splits.getSplit(0);\
else\
    split = getBestSplit(splits, minItems, t, preferLongestAxis, \
        longestAxisTolerance);\
if (split == 0)\
\{\
    // There is no split that does anything useful.\
    /* <---- DEBUG ----- //\
    status.str("");\
    status << "No suitable split (level = " \
        << splitLevel << ").";\
    log(IFLogMessage(status.str(), VL_DEBUG, this, "split"));\
    // ----- DEBUG ----> */\
    result.success = false;\
    return result;\
\}\
/* <---- DEBUG ----- //\
status.str("");\
status << "Splitting box with " << items.size() << " items using " \
    << split->getString() << " (level = " << splitLevel << ").";\
log(IFLogMessage(status.str(), VL_DEBUG, this, "split"));\
// ----- DEBUG ----> */\
Range b = bounds.getAxisRange(split->getAxis());\
double sc = b.getValue(split->getS());\
result.boxes.b0 = new BoundingBox();\
if (result.boxes.b0 == 0)\
    throw GeoUtilsError("Could not allocate object.");\
result.boxes.b0->setLevel(splitLevel + 1);\
result.boxes.b1 = new BoundingBox();\
if (result.boxes.b1 == 0)\
    throw GeoUtilsError("Could not allocate object.");\
result.boxes.b1->setLevel(splitLevel + 1);\
for (BoxBoundsItemSet::iterator i = items.begin(); \
    i != items.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    if (ltOrEq(it->getCenter()[split->getAxis()], sc, t))\
        result.boxes.b0->addItem(it);\
    else \
        result.boxes.b1->addItem(it);\
\}\
// <---- DEBUG ----- //\
BoundingBox* bx = 0;\
if (compare(*result.boxes.b0, t) != RANGE_FIRST_CONTAINS)\
    bx = result.boxes.b0;\
if (compare(*result.boxes.b1, t) != RANGE_FIRST_CONTAINS)\
    bx = result.boxes.b1;\
if (bx != 0)\
\{\
    status.str("");\
    status << "Box not contained before splitting (" \
        << rangeCompToString(compare(*bx, t)) << "): " << bx->getString() \
        << " (" << getString() << "), [" \
        << rangeCompToString3S(bounds.compare3(bx->getBounds())) << "].";\
    throw GeoUtilsError(status.str());\
\}\
// ----- DEBUG ----> */\
if (recursive)\
\{\
    // Split recursively.\
    result.boxes.b0->split(splits, recursive, minItems, maxLevel, \
        splitLevel + 1, t, preferLongestAxis, longestAxisTolerance);\
    result.boxes.b1->split(splits, recursive, minItems, maxLevel, \
        splitLevel + 1, t, preferLongestAxis, longestAxisTolerance);\
\}\
// <---- DEBUG ----- //\
bx = 0;\
if (compare(*result.boxes.b0, t) != RANGE_FIRST_CONTAINS)\
    bx = result.boxes.b0;\
if (compare(*result.boxes.b1, t) != RANGE_FIRST_CONTAINS)\
    bx = result.boxes.b1;\
if (bx != 0)\
\{\
    status.str("");\
    status << "Box not contained after splitting (" \
        << compare(*bx, t) << "): " << bx->getString() << " (" \
        << getString() << "), [" \
        << rangeCompToString3S(bounds.compare3(bx->getBounds())) \
        << "].";\
    throw GeoUtilsError(status.str());\
\}\
// ----- DEBUG ----> */\
// Add the new boxes.\
clear();\
/* <---- DEBUG ----- //\
status.str("");\
status << "Adding box with " \
    << result.boxes.b0->getNumItems() << " items.";\
log(IFLogMessage(status.str(), VL_DEBUG, this, "split"));\
// ----- DEBUG ----> */\
addItem(result.boxes.b0);\
/* <---- DEBUG ----- //\
status.str("");\
status << "Adding box with " \
    << result.boxes.b1->getNumItems() << " items.";\
log(IFLogMessage(status.str(), VL_DEBUG, this, "split"));\
// ----- DEBUG ----> */\
addItem(result.boxes.b1);\
result.success = true;
    return = {
        value = result
        desc = Split result
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::BoxBoundsItemSet
	name = getItemsAbovePlane
	shortDesc = Get items above plane.
	longDesc = Get the items which are above the specified plane (in direction of the normal of the plane).
    param[] = {
        type = Ionflux::GeoUtils::Plane3&
        name = plane
        desc = Plane
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = BoxBoundsItemSet result;\
int r = checkPlane(plane, t);\
if (r == 1)\
\{\
    // Everything in this bounding box is above the plane.\
    result.insert(this);\
    return result;\
\} else\
if (r == -1)\
\{\
    // Nothing in this bounding box is above the plane.\
    return result;\
\}\
if (items.size() == 0)\
    throw GeoUtilsError("Bounding box used as a leaf.");\
// There is some intersection, so we need to go into the details.\
for (BoxBoundsItemSet::iterator i = items.begin(); i != items.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    r = it->checkPlane(plane, t);\
    if (r == 1)\
        // The whole item is above the plane.\
        result.insert(it);\
    else\
    if (r == 0)\
    \{\
        // There is some intersection.\
        BoundingBox* b0 = BoundingBox::upcast(it);\
        if (b0 != 0)\
        \{\
            /* If this is a bounding box, check the items contained \
               within recursively. */\
            BoxBoundsItemSet ts = b0->getItemsAbovePlane(plane, t);\
            result.insert(ts.begin(), ts.end());\
        \} else\
        if (it->checkPlaneInner(plane, t) != -1)\
        \{\
            // Leaf item, which is not a bounding box.\
            result.insert(it);\
        \}\
    \}\
\}
    return = {
        value = result
        desc = Set of items which are above the plane
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::BoxBoundsItemSet
	name = getItemsOnLine
	shortDesc = Get items which intersect line.
	longDesc = Get the leaf items from the bounding box hierarchy which may be intersected by the specified line. Returns a set of leaf items. For leaf items which do not have a checkLine method, it is up to the caller to determine if there are actual intersections.
    param[] = {
        type = Ionflux::GeoUtils::Line3&
        name = line
        desc = Line
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = /* <---- DEBUG ----- //\
std::ostringstream status;\
std::cerr << "[BoundingBox::getItemsOnLine] this = " << this \
    << ", level = " << level << ", bounds = " \
    << bounds.getString() << std::endl;\
// ----- DEBUG ----> */\
BoxBoundsItemSet result;\
if (!checkLine(line, t))\
\{\
    // If this bounding box is not intersected, nothing in it will be.\
    /* <---- DEBUG ----- //\
    std::cerr << "[BoundingBox::getItemsOnLine] this = " << this \
        << ", level = " << level << ": no intersection" << std::endl;\
    // ----- DEBUG ----> */\
    return result;\
\}\
if (items.size() == 0)\
    throw GeoUtilsError("Bounding box used as a leaf.");\
// There is some intersection, so we need to go into the details.\
for (BoxBoundsItemSet::iterator i = items.begin(); i != items.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    if (it->checkLine(line, t))\
    \{\
        BoundingBox* b0 = dynamic_cast<BoundingBox*>(it);\
        if (b0 != 0)\
        \{\
            // Bounding box is intersected, check contained items.\
            BoxBoundsItemSet ts = b0->getItemsOnLine(line, t);\
            result.insert(ts.begin(), ts.end());\
        \} else\
        if (it->checkLineInner(line, t))\
        \{\
            // Leaf item which intersects the line.\
            /* <---- DEBUG ----- //\
            std::cerr << "[BoundingBox::getItemsOnLine] this = " << this \
                << ", level = " << level << ": leaf item intersected: " \
                << it->getString() << std::endl;\
            // ----- DEBUG ----> */\
            result.insert(it);\
        \}\
    \}\
\}
    return = {
        value = result
        desc = Set of items which are intersected by the line
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::BoxBoundsItemSet
	name = getItemsOnRay
	shortDesc = Get items which intersect ray.
	longDesc = Get the leaf items from the bounding box hierarchy which may be intersected by the specified ray. Returns a set of leaf items. For leaf items which do not have a checkRay method, it is up to the caller to determine if there are actual intersections. The ray is specified as a line, where the ray is supposed to start at point \c P and have direction \c U.
    param[] = {
        type = Ionflux::GeoUtils::Line3&
        name = ray
        desc = Ray
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = /* <---- DEBUG ----- //\
std::ostringstream status;\
std::cerr << "[BoundingBox::getItemsOnRay] this = " << this \
    << ", level = " << level << ", bounds = " \
    << bounds.getString() << std::endl;\
// ----- DEBUG ----> */\
BoxBoundsItemSet result;\
if (!checkRay(ray, t))\
\{\
    // If this bounding box is not intersected, nothing in it will be.\
    /* <---- DEBUG ----- //\
    std::cerr << "[BoundingBox::getItemsOnRay] this = " << this \
        << ", level = " << level << ": no intersection" << std::endl;\
    // ----- DEBUG ----> */\
    return result;\
\}\
if (items.size() == 0)\
    throw GeoUtilsError("[BoundingBox::checkRay] "\
        "Bounding box used as a leaf.");\
// There is some intersection, so we need to go into the details.\
for (BoxBoundsItemSet::iterator i = items.begin(); i != items.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    if (it->checkRay(ray, t))\
    \{\
        BoundingBox* b0 = dynamic_cast<BoundingBox*>(it);\
        if (b0 != 0)\
        \{\
            // Bounding box is intersected, check contained items.\
            BoxBoundsItemSet ts = b0->getItemsOnRay(ray, t);\
            result.insert(ts.begin(), ts.end());\
        \} else\
        if (it->checkRayInner(ray, t))\
        \{\
            // Leaf item which intersects the ray.\
            /* <---- DEBUG ----- //\
            std::cerr << "[BoundingBox::getItemsOnRay] this = " << this \
                << ", level = " << level << ": leaf item intersected: " \
                << it->getString() << std::endl;\
            // ----- DEBUG ----> */\
            result.insert(it);\
        \}\
    \}\
\}
    return = {
        value = result
        desc = Set of items which are intersected by the ray
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::BoxBoundsItemSet
	name = getItemsInSphere
	shortDesc = Get items in sphere.
	longDesc = Get the items which are inside the specified sphere.
    param[] = {
        type = Ionflux::GeoUtils::Sphere3&
        name = sphere
        desc = Sphere
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = BoxBoundsItemSet result;\
int r = checkSphere(sphere, t);\
if (r == 1)\
\{\
    // Everything in this bounding box is inside the sphere.\
    result.insert(this);\
    return result;\
\} else\
if (r == -1)\
\{\
    // Nothing in this bounding box is inside the sphere.\
    return result;\
\}\
if (items.size() == 0)\
    throw GeoUtilsError("Bounding box used as a leaf.");\
// There is some intersection, so we need to go into the details.\
for (BoxBoundsItemSet::iterator i = items.begin(); i != items.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    r = it->checkSphere(sphere, t);\
    if (r == 1)\
        // The whole item is contained in the sphere.\
        result.insert(it);\
    else\
    if (r == 0)\
    \{\
        // There is some intersection.\
        BoundingBox* b0 = BoundingBox::upcast(it);\
        if (b0 != 0)\
        \{\
            // Bounding box is intersected, check contained items.\
            BoxBoundsItemSet ts = b0->getItemsInSphere(sphere, t);\
            result.insert(ts.begin(), ts.end());\
        \} else\
        if (it->checkSphereInner(sphere, t) != -1)\
        \{\
            // Leaf item which intersects the sphere.\
            result.insert(it);\
        \}\
    \}\
\}
    return = {
        value = result
        desc = Set of items which are inside the sphere
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::BoxBoundsItemSet
	name = getItemsInBox
	shortDesc = Get items in box.
	longDesc = Get the items which are inside the specified bounding box (which can be simply a BoxBoundsItem). If a leaf item intersects the box, it is also added to the result.
    param[] = {
        type = Ionflux::GeoUtils::BoxBoundsItem&
        name = box
        desc = Box
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = BoxBoundsItemSet result;\
int r = checkBox(box, t);\
/* <---- DEBUG ----- //\
std::ostringstream status;\
status << "[" << (*this) << "] checkBox result = " << r << " (box = " \
    << box << ")";\
log(IFLogMessage(status.str(), VL_DEBUG, this, "getItemsInBox"));\
// ----- DEBUG ----> */\
if (r == 1)\
\{\
    // Everything in this bounding box is inside the box.\
    result.insert(this);\
    return result;\
\} else\
if (r == -1)\
\{\
    // Nothing in this bounding box is inside the box.\
    return result;\
\}\
if (items.size() == 0)\
    throw GeoUtilsError("Bounding box used as a leaf.");\
// There is some intersection, so we need to go into the details.\
for (BoxBoundsItemSet::iterator i = items.begin(); i != items.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    r = it->checkBox(box, t);\
    if (r == 1)\
        // The whole item is contained in the box.\
        result.insert(it);\
    else\
    if (r == 0)\
    \{\
        // There is some intersection.\
        BoundingBox* b0 = BoundingBox::upcast(it);\
        if (b0 != 0)\
        \{\
            // Bounding box is intersected, check contained items.\
            BoxBoundsItemSet ts = b0->getItemsInBox(box, t);\
            result.insert(ts.begin(), ts.end());\
        \} else\
        if (it->checkBoxInner(box, t) != -1) \
        \{\
            // Leaf item which intersects the box.\
            result.insert(it);\
        \}\
    \}\
\}
    return = {
        value = result
        desc = Set of items which are inside the box
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::BoxBoundsItem*
	name = getContainingLeaf
	shortDesc = Get containing leaf.
	longDesc = Return the leaf item that contains the specified item, or 0 if none of the leaf items contains that item.
    param[] = {
        type = Ionflux::GeoUtils::BoxBoundsItem*
        name = item
        desc = Item to search for
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = // <---- DEBUG ----- //\
ostringstream status;\
// ----- DEBUG ----> */\
RangeCompResult r = compare(*item, t);\
// <---- DEBUG ----- //\
status << "check: " << rangeCompToString(r);\
log(IFLogMessage(status.str(), VL_DEBUG, this, "getContainingLeaf"));\
// ----- DEBUG ----> */\
if ((r != RANGE_FIRST_CONTAINS)\
    && (r != RANGE_EQUAL))\
\{\
    // This box does not contain the item.\
    return 0;\
\}\
if (items.size() == 0)\
\{\
    // This box contains the item.\
    return this;\
\}\
// Check children.\
for (BoxBoundsItemSet::iterator i = items.begin(); i != items.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    r = it->compare(*item, t);\
    if ((r == RANGE_FIRST_CONTAINS)\
        || (r == RANGE_EQUAL))\
    \{\
        // Child box contains the item.\
        BoxBoundsItem* rb = 0;\
        BoundingBox* b0 = dynamic_cast<BoundingBox*>(it);\
        if (b0 != 0)\
        \{\
            // Check boxes recursively.\
            rb = b0->getContainingLeaf(item, t);\
        \} else\
        \{\
            // We have found the containing leaf item.\
            rb = it;\
        \}\
        if (rb != 0)\
            return rb;\
    \}\
\}
    return = {
        value = this
        desc = Check result
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = initFromSource
	shortDesc = Initialize hierarchy from source.
	longDesc = Initialize the bounding box hierarchy from the specified source. This walks through the hierarchy recursively and replaces BoxBoundsItems with whatever is returned from calling the getItem method on the source with the item ID of the BoxBoundsItem as an argument.
    param[] = {
        type = Ionflux::GeoUtils::ItemSource&
        name = source
        desc = Item source
    }
    impl = BoxBoundsItemSet newItems;\
while (items.size() > 0)\
\{\
    BoxBoundsItemSet::iterator i = items.begin();\
    BoxBoundsItem* it = *i;\
    removeItem(it, false);\
    BoundingBox* b0 = dynamic_cast<BoundingBox*>(it);\
    if (b0 != 0)\
    \{\
        b0->initFromSource(source);\
        newItems.insert(it);\
    \} else\
        newItems.insert(source.getItem(it->getItemID()));\
\}\
for (BoxBoundsItemSet::iterator i = newItems.begin(); \
    i != newItems.end(); i++)\
    addItem(*i);
}
function.public[] = {
	spec = virtual
	type = void
	name = getBoundingBoxes
	shortDesc = Get bounding boxes.
	longDesc = Get the bounding boxes from the hierarchy of which the bounding box is the root.
    param[] = {
        type = Ionflux::GeoUtils::BoundingBoxSet&
        name = target
        desc = Where to store the bounding boxes.
    }
    impl = target.insert(this);\
for (BoxBoundsItemSet::iterator i = items.begin(); \
    i != items.end(); i++)\
\{\
    BoundingBox* b0 = dynamic_cast<BoundingBox*>(*i);\
    if (b0 != 0)\
        b0->getBoundingBoxes(target);\
\}
}
function.public[] = {
	spec = virtual
	type = void
	name = getLeaves
	shortDesc = Get leaves.
	longDesc = Get the leaf items from the hierarchy of which the bounding box is the root.
    param[] = {
        type = Ionflux::GeoUtils::BoxBoundsItemSet&
        name = target
        desc = Where to store the bounding boxes.
    }
    impl = for (BoxBoundsItemSet::iterator i = items.begin(); \
    i != items.end(); i++)\
\{\
    BoundingBox* b0 = dynamic_cast<BoundingBox*>(*i);\
    if (b0 != 0)\
        b0->getLeaves(target);\
    else\
        target.insert(*i);\
\}
}
function.public[] = {
	spec = virtual
	type = bool
	name = getItemPath
	shortDesc = Get item path.
	longDesc = Get the path for a leaf item in the hierarchy. Adds a list of  bounding boxes to the target vector, from bottom to top, which contain the specified item. If the bounding box hierarchy does not contain the item, the function returns \c false and the target vector is not changed.
    param[] = {
        type = Ionflux::GeoUtils::BoxBoundsItem*
        name = item
        desc = Item for which to get the path.
    }
    param[] = {
        type = Ionflux::GeoUtils::BoundingBoxVector&
        name = target
        desc = Where to store the bounding boxes.
    }
    impl = for (BoxBoundsItemSet::iterator i = items.begin(); \
    i != items.end(); i++)\
\{\
    if (*i == item)\
    \{\
        /* We are the bottommost container of the item, no need to \
           check any other boxes. */\
       target.push_back(this);\
       return true;\
    \}\
    BoundingBox* b0 = dynamic_cast<BoundingBox*>(*i);\
    if (b0 != 0)\
    \{\
        if (b0->getItemPath(item, target))\
        \{\
            target.push_back(this);\
            return true;\
        \}\
    \}\
\}
    return = {
        value = false
        desc = \c true if the bounding box hierarchy contains the item, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = compareHierarchy
	shortDesc = Compare bounding box hierarchies.
	longDesc = Check whether the bounding box hierarchies are equal, i.e. they contain equal bounding boxes and the same leaf items in each node.
    param[] = {
        type = Ionflux::GeoUtils::BoundingBox&
        name = other
        desc = Bounding box hierarchy root.
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = // <---- DEBUG ----- //\
std::ostringstream msg;\
// ----- DEBUG ----> */\
if (compare(other, t) != RANGE_EQUAL)\
\{\
    // <---- DEBUG ----- //\
    log(IFLogMessage("Root boxes of the hierarchy are not equal.", \
        VL_DEBUG, this, "compareHierarchy"));\
    // ----- DEBUG ----> */\
    return false;\
\}\
for (BoxBoundsItemSet::iterator i = items.begin(); \
    i != items.end(); i++)\
\{\
    BoxBoundsItem* it = *i;\
    BoxBoundsItem* matching = 0;\
    BoxBoundsItemSet otherItems = other.items;\
    BoundingBox* b0 = dynamic_cast<BoundingBox*>(it);\
    BoundingBox* b1 = 0;\
    while ((matching == 0) \
        && (otherItems.size() > 0))\
    \{\
        BoxBoundsItemSet::iterator k = otherItems.begin();\
        BoxBoundsItem* oi = *k;\
        b1 = dynamic_cast<BoundingBox*>(oi);\
        otherItems.erase(k);\
        if (it->compare(*oi, t) == RANGE_EQUAL)\
        \{\
            /* If the current item is a leaf item, the matching \
               item must be equal. If the current item is a bounding \
               box, the matching item must be a bounding box as well. */\
            if (b0 == 0)\
            \{\
                if (it == oi)\
                    matching = oi;\
            \} else\
            \{\
                if (b1 != 0)\
                    matching = oi;\
            \}\
        \}\
    \}\
    if (matching == 0)\
    \{\
        // <---- DEBUG ----- //\
        msg.str("");\
        msg << "No matching item found for " << *it << " [" \
            << it << "] (comparing " << *this << " to " \
            << other << ").";\
        log(IFLogMessage(msg.str(), VL_DEBUG, this, "compareHierarchy"));\
        log(IFLogMessage("Equality check results:", VL_DEBUG, this, \
            "compareHierarchy"));\
        for (BoxBoundsItemSet::iterator j = other.items.begin(); \
            j != other.items.end(); j++)\
        \{\
            msg.str("");\
            msg << *(*j) << " [" << *j << "]: " << (it == *j);\
            log(IFLogMessage(msg.str(), VL_DEBUG, this, "compareHierarchy"));\
        \}\
        // ----- DEBUG ----> */\
        return false;\
    \}\
    if (b0 != 0)\
    \{\
        // We have a box with matching bounds, now go into the details.\
        if (b1 == 0)\
            throw GeoUtilsError("Matching bounding box is null!");\
        if (!b0->compareHierarchy(*b1, t))\
            return false;\
    \}\
\}\
// This level is equal for all practical purposes.
    return = {
        value = true
        desc = \c true if the bounding box hierarchies are equal, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = validate
	shortDesc = Validate.
	longDesc = Recursively check that all items are contained within the bounds. Raises an excetion if this is not the case.
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = for (BoxBoundsItemSet::iterator i = items.begin(); \
    i != items.end(); i++)\
\{\
    if (compare(*(*i), t) != RANGE_FIRST_CONTAINS)\
    \{\
        std::ostringstream msg;\
        msg << "Item not contained within bounding box: " << *(*i) \
            << "(" << *this << ")";\
        throw GeoUtilsError(msg.str());\
    \}\
    BoundingBox* b0 = dynamic_cast<BoundingBox*>(*i);\
    if (b0 != 0)\
        b0->validate(t);\
\}
    return = {
        value = false
        desc = \c true if the bounding box hierarchy contains the item, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator==
	const = true
	shortDesc = Comparison operator: equality
	longDesc = Compare equality.
	param[] = {
		type = const Ionflux::GeoUtils::BoundingBox&
		name = other
		desc = Bounding box
	}
    impl = 
	return = {
        value = compare(other, DEFAULT_TOLERANCE) == RANGE_EQUAL
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator!=
	const = true
	shortDesc = Comparison operator: inequality
	longDesc = Compare inequality.
	param[] = {
		type = const Ionflux::GeoUtils::BoundingBox&
		name = other
		desc = Bounding box
	}
	return = {
        value = !(*this == other);
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = getNumItems
	const = true
	shortDesc = Get number of items
	longDesc = Get the number of items contained in the bounding box.
	impl = 
    return = {
        value = items.size()
        desc = Number of items
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getItems
	const = true
	shortDesc = Get items
	longDesc = Get the items contained in the bounding box.
	param[] = {
		type = Ionflux::GeoUtils::BoxBoundsItemSet&
		name = target
		desc = Where to store the items
	}
	impl = target = items;
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getString
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	impl = ostringstream state;\
state << getClassName() << "[" << center.getString() \
    << ", " << rVec.getString() << ", '" << itemID << "']";
    return = {
        value = state.str()
        desc = String representation
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setChildIDs
	shortDesc = Set child item IDs
	longDesc = Set item IDs for the child objects of the bounding box. The ID will be constructed out of the prefix, a number, and optionally the level.
	param[] = {
	    type = const std::string&
	    name = prefix
	    desc = Prefix
	}
	param[] = {
	    type = bool
	    name = showLevel
	    desc = Show level
	    default = true
	}
	param[] = {
	    type = bool
	    name = keepExisting
	    desc = Keep existing IDs
	    default = true
	}
	param[] = {
	    type = bool
	    name = recursive
	    desc = Recursively set item IDs
	    default = false
	}
	param[] = {
	    type = unsigned int
	    name = level
	    desc = Level
	    default = 0
	}
	param[] = {
	    type = unsigned int
	    name = fieldWidth
	    desc = Number field width
	    default = 2
	}
	impl = unsigned int k = 0;\
std::ostringstream c0;\
BoxBoundsItemSet::iterator i;\
for (i = items.begin(); i != items.end(); i++)\
\{\
    BoxBoundsItem* it0 = *i;\
    BoundingBox* b0 = BoundingBox::upcast(it0);\
    if (!keepExisting \
        || (it0->getItemID().size() == 0))\
    \{\
        c0.str("");\
        c0 << prefix << "_" << setw(fieldWidth) << setfill('0') << k;\
        std::string prefix0 = c0.str();\
        if (showLevel)\
            c0 << "_" << setw(fieldWidth) << setfill('0') << level;\
        it0->setItemID(c0.str());\
        if (recursive && (b0 != 0))\
            b0->setChildIDs(prefix0, showLevel, keepExisting, \
                true, level + 1, fieldWidth);\
    \}\
    k++;\
\}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getXML
	const = true
	shortDesc = Get XML representation
	longDesc = Get an XML representation of the object.
	impl = ostringstream d0;\
if (itemID.size() == 0)\
    throw GeoUtilsError("Item ID not set.");\
d0 << "<bbox id=\"" << itemID << "\" center=\"" << center[0] << "," \
    << center[1] << "," << center[2] << "\" rvec=\"" << rVec[0] << "," \
    << rVec[1] << "," << rVec[2] << "\"><items>";\
for (BoxBoundsItemSet::const_iterator i = items.begin(); \
    i != items.end(); i++)\
    d0 << (*i)->getXML();\
d0 << "</items></bbox>";
    return = {
        value = d0.str()
        desc = XML representation
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = writeToFile
	const = true
	shortDesc = Write to file
	longDesc = Write mesh data to a (XML) file.
	param[] = {
	    type = const std::string&
	    name = fileName
	    decs = Name of file to write to
	}
	impl = ofstream f0;\
f0.open(fileName.c_str(), ios_base::out);\
f0 << XML_HEADER << getXML();
}

# Pure virtual member functions.

# operations

# Global functions.

