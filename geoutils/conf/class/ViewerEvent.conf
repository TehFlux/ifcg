# ===================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009-2014 Jörn P. Meier
# mail@ionflux.org
# -------------------------------------------------------------------
# ViewerEvent.conf              Class configuration.
# ===================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GeoUtils - Ionflux' Geometry Library; if not, write to the Free 
# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
# MA 02111-1307 USA
# 
# ===================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/gltypes.hpp"'
        '"geoutils/glconstants.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"ifobject/utils.hpp"'
        '"ifobject/objectutils.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/Viewer.hpp"'
    }
}

# forward declarations
forward = {
    'class Viewer'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = ViewerEvent
	shortDesc = Viewer event
	title = Viewer event
	longDesc = An event that is generated by a viewer instance.
	group.name = ifvg
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
		}
	}
    features = {
        'copy'
        'upcast'
        'create'
        'classinfo'
        #'xmlio'
    }
    create = {
        allocationError = GeoUtilsError("Could not allocate object")
        extendedCreate = true
    }
}

# Member variables.

# Public static constants.
constant.public[] = {
    type = Ionflux::GeoUtils::ViewerEventTypeID
    name = TYPE_NONE
    desc = Event ID: none
    value = 0
}
constant.public[] = {
    type = Ionflux::GeoUtils::ViewerEventTypeID
    name = TYPE_KEY
    desc = Event ID: key
    value = 1
}
constant.public[] = {
    type = Ionflux::GeoUtils::ViewerEventTypeID
    name = TYPE_WINDOW_SIZE
    desc = Event ID: window size
    value = 2
}
constant.public[] = {
    type = Ionflux::GeoUtils::ViewerEventTypeID
    name = TYPE_WINDOW_POS
    desc = Event ID: window position
    value = 4
}
constant.public[] = {
    type = Ionflux::GeoUtils::ViewerEventTypeID
    name = TYPE_WINDOW_CLOSE
    desc = Event ID: window close
    value = 8
}
constant.public[] = {
    type = Ionflux::GeoUtils::ViewerEventTypeID
    name = TYPE_CURSOR_POS
    desc = Event ID: cursor position
    value = 16
}
constant.public[] = {
    type = Ionflux::GeoUtils::ViewerEventTypeID
    name = TYPE_MOUSE_BUTTON
    desc = Event ID: mouse button
    value = 32
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    type = Ionflux::GeoUtils::Viewer*
    setFromType = Ionflux::GeoUtils::Viewer*
    name = viewer
    desc = Viewer
}
property.protected[] = {
    type = Ionflux::GeoUtils::ViewerEventTypeID
    setFromType = Ionflux::GeoUtils::ViewerEventTypeID
    name = eventType
    desc = Event type
}
property.protected[] = {
    type = int
    setFromType = int
    name = keyCode
    desc = Key code
}
property.protected[] = {
    type = int
    setFromType = int
    name = scanCode
    desc = Scan code
}
property.protected[] = {
    type = int
    setFromType = int
    name = action
    desc = action
}
property.protected[] = {
    type = int
    setFromType = int
    name = keyMods
    desc = Modifier keys
}
property.protected[] = {
    type = double
    setFromType = double
    name = posX
    desc = Position (x)
}
property.protected[] = {
    type = double
    setFromType = double
    name = posY
    desc = Position (Y)
}
property.protected[] = {
    type = int
    setFromType = int
    name = mouseButton
    desc = Mouse button
}

# Protected static constants.

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = viewer
        value = 0
    }
    initializer[] = {
        name = eventType
        value = TYPE_NONE
    }
    initializer[] = {
        name = keyCode
        value = 0
    }
    initializer[] = {
        name = scanCode
        value = 0
    }
    initializer[] = {
        name = action
        value = 0
    }
    initializer[] = {
        name = keyMods
        value = 0
    }
    initializer[] = {
        name = posX
        value = 0
    }
    initializer[] = {
        name = posY
        value = 0
    }
    initializer[] = {
        name = mouseButton
        value = 0
    }
    impl = 
}
constructor.public[] = {
    initializer[] = {
        name = viewer
        value = initViewer
    }
    initializer[] = {
        name = eventType
        value = initEventType
    }
    initializer[] = {
        name = keyCode
        value = initKeyCode
    }
    initializer[] = {
        name = scanCode
        value = initScanCode
    }
    initializer[] = {
        name = action
        value = initAction
    }
    initializer[] = {
        name = keyMods
        value = initKeyMods
    }
    initializer[] = {
        name = posX
        value = initPosX
    }
    initializer[] = {
        name = posY
        value = initPosY
    }
    initializer[] = {
        name = mouseButton
        value = initMouseButton
    }
    param[] = {
        type = Ionflux::GeoUtils::Viewer*
        name = initViewer
        desc = viewer
    }
    param[] = {
        type = Ionflux::GeoUtils::ViewerEventTypeID
        name = initEventType
        desc = event type
        default = TYPE_NONE
    }
    param[] = {
        type = int
        name = initKeyCode
        desc = key code
        default = 0
    }
    param[] = {
        type = int
        name = initScanCode
        desc = scan code
        default = 0
    }
    param[] = {
        type = int
        name = initAction
        desc = Action
        default = 0
    }
    param[] = {
        type = int
        name = initKeyMods
        desc = modifier keys
        default = 0
    }
    param[] = {
        type = double
        name = initPosX
        desc = position (X)
        default = 0
    }
    param[] = {
        type = double
        name = initPosY
        desc = position (Y)
        default = 0
    }
    param[] = {
        type = int
        name = initMouseButton
        desc = mouse button
        default = 0
    }
    impl = 
}

# Destructor.
destructor.impl = 

# Protected member functions.

# Public member functions.
function.copy.impl = <<<
if (this == &other)
    return *this;
setViewer(other.viewer);
setEventType(other.eventType);
setKeyCode(other.keyCode);
setScanCode(other.scanCode);
setAction(other.action);
setKeyMods(other.keyMods);
setPosX(other.posX);
setPosY(other.posY);
setMouseButton(other.mouseButton);
>>>

# public member functions

# member functions overridden from IFObject
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object.
	impl = <<<
ostringstream status;
status << getTypeString(eventType);
status << "; viewer: ";
if (viewer != 0)
{
    std::string id0 = viewer->getID();
    if (id0.size() == 0)
        status << viewer;
    else
        status << id0;
} else
    status << "<none>";
if (eventType == TYPE_KEY)
{
    status << "; key = " << keyCode 
        << ", scanCode = " << scanCode 
        << ", action = " << action 
        << ", mods = " << keyMods;
} else 
if (eventType == TYPE_CURSOR_POS)
{
    status << "; pos = (" << posX 
        << ", " << posY << ")";
} else 
if (eventType == TYPE_MOUSE_BUTTON)
{
    status << "; mouseButton = " << mouseButton 
        << ", action = " << action 
        << ", mods = " << keyMods 
        << ", pos = (" << posX << ", " << posY << ")";
}
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}

# static member functions
function.public[] = {
	spec = static
	type = std::string
	name = getTypeString
	shortDesc = Get string representation of event type
	longDesc = Get a string representation of the specified event type ID.
    param[] = {
        type = Ionflux::GeoUtils::ViewerEventTypeID
        name = eventType
        desc = event type
    }
	impl = <<<
if (eventType == TYPE_NONE)
    return "none";
if (eventType == TYPE_KEY)
    return "key";
if (eventType == TYPE_WINDOW_SIZE)
    return "window_size";
if (eventType == TYPE_WINDOW_POS)
    return "window_pos";
if (eventType == TYPE_WINDOW_CLOSE)
    return "window_close";
if (eventType == TYPE_CURSOR_POS)
    return "cursor_pos";
if (eventType == TYPE_MOUSE_BUTTON)
    return "mouse_button";
>>>
    return = {
        value = "<unknown>"
        desc = String representation
    }
}


# Pure virtual member functions.

# operations

# Global functions.

