# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009-2012 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Vector3.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/types.hpp"'
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/Vector2.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/Plane3.hpp"'
    }
}

# forward declarations
forward = {
    'class Plane3'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Vector3
	shortDesc = Vector (3 elements)
	title = Vector (3 elements)
	longDesc = A vector in three-dimensional space.
	group.name = geoutils
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
		}
	}
    features = {
        'copy'
        'upcast'
        'create'
    }
    create.allocationError = GeoUtilsError("Could not allocate object.")
}

# Public constructors.
constructor.copy.impl = elements = new double[3];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
*this = other;
constructor.default = {
    initializer[] = {
        name = elements
        value = 0
    }
    impl = elements = new double[3];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
*this = ZERO;
}
constructor.public[] = {
    initializer[] = {
        name = elements
        value = 0
    }
    param[] = {
        name = initX0
        type = double
        desc = Element (X0)
    }
    param[] = {
        name = initX1
        type = double
        desc = Element (X1)
    }
    param[] = {
        name = initX2
        type = double
        desc = Element (X2)
    }
    impl = elements = new double[3];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
elements[0] = initX0;\
elements[1] = initX1;\
elements[2] = initX2;
}
constructor.public[] = {
    initializer[] = {
        name = elements
        value = 0
    }
    param[] = {
        name = initElements
        type = const Ionflux::ObjectBase::DoubleVector&
        desc = Element vector
    }
    impl = elements = new double[3];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
setElements(initElements);
}
constructor.public[] = {
    initializer[] = {
        name = elements
        value = 0
    }
    param[] = {
        name = initElements
        type = const Ionflux::GeoUtils::Vector2&
        desc = Element vector
    }
    param[] = {
        name = initZ
        type = double
        desc = Z coordinate
        default = 1.
    }
    impl = elements = new double[3];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
setV2(initElements, initZ);
}

# Destructor.
destructor.impl = delete[] elements;

# Member variables.
variable.protected[] = {
	type = double*
	name = elements
	desc = Elements
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
	type = double
	setFromType = double
	name = x0
	desc = Element x0
    copy = true
    proxy = true
    impl.set = elements[0] = newX0;
    impl.get = return elements[0];
}
property.protected[] = {
	type = double
	setFromType = double
	name = x1
	desc = Element x1
    copy = true
    proxy = true
    impl.set = elements[1] = newX1;
    impl.get = return elements[1];
}
property.protected[] = {
	type = double
	setFromType = double
	name = x2
	desc = Element x2
    copy = true
    proxy = true
    impl.set = elements[2] = newX2;
    impl.get = return elements[2];
}

# Public static constants.
constant.public[] = {
    desc = Zero vector
    type = Ionflux::GeoUtils::Vector3
    name = ZERO
    value = Ionflux::GeoUtils::Vector3(0., 0., 0.)
}
constant.public[] = {
    desc = Unit vector (X)
    type = Ionflux::GeoUtils::Vector3
    name = E_X
    value = Ionflux::GeoUtils::Vector3(1., 0., 0.)
}
constant.public[] = {
    desc = Unit vector (Y)
    type = Ionflux::GeoUtils::Vector3
    name = E_Y
    value = Ionflux::GeoUtils::Vector3(0., 1., 0.)
}
constant.public[] = {
    desc = Unit vector (Z)
    type = Ionflux::GeoUtils::Vector3
    name = E_Z
    value = Ionflux::GeoUtils::Vector3(0., 0., 1.)
}
constant.public[] = {
    desc = Sum of unit vectors
    type = Ionflux::GeoUtils::Vector3
    name = E_SUM
    value = Ionflux::GeoUtils::Vector3(1., 1., 1.)
}

# Protected static constants.

# Protected member functions.

# Public member functions.
function.copy.impl = if ((elements == 0) || (other.elements == 0))\
    return *this;\
for (unsigned int i = 0; i < 3; i++)\
    elements[i] = other.elements[i];\
return *this;
function.public[] = {
	spec = virtual
	type = void
	name = setElements
	shortDesc = Set elements
	longDesc = Set elements from a vector of doubles. If the vector contains fewer than the required number of elements, the remaining elements will be left alone.
	param[] = {
		type = const Ionflux::ObjectBase::DoubleVector&
		name = newElements
		desc = Element vector
	}
    impl = unsigned int i = 0;\
while ((i < 3) && (i < newElements.size()))\
\{\
    elements[i] = newElements[i];\
    i++;\
\}
}
function.public[] = {
	spec = virtual
	type = void
	name = setElements
	shortDesc = Set elements
	longDesc = Set elements of the vector.
	param[] = {
		type = double
		name = newX0
		desc = Element (x0)
	}
	param[] = {
		type = double
		name = newX1
		desc = Element (x1)
	}
	param[] = {
		type = double
		name = newX2
		desc = Element (x2)
	}
    impl = elements[0] = newX0;\
elements[1] = newX1;\
elements[2] = newX2;
}

function.public[] = {
	spec = virtual
	type = void
	name = setElements
	shortDesc = Set elements
	longDesc = Set elements from a 2-element vector. The Z-coordinate will be left alone.
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = newElements
		desc = Element vector
	}
    impl = elements[0] = newElements.getX0();\
elements[1] = newElements.getX1();
}
function.public[] = {
	spec = virtual
	type = void
	name = setV2
	shortDesc = Set elements
	longDesc = Set elements from a 2-element vector. The Z-coordinate will be set to the optional second parameter (which defaults to 1).
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = newElements
		desc = Element vector
	}
	param[] = {
		type = double
		name = newZ
		desc = Z coordinate
        default = 1.
	}
    impl = setElements(newElements);\
elements[2] = newZ;
}
function.public[] = {
	spec = virtual
	type = void
    const = true
	name = getElements
	shortDesc = Get elements
	longDesc = Store the elements of the vector in a vector of doubles.
	param[] = {
		type = Ionflux::ObjectBase::DoubleVector&
		name = target
		desc = Target vector
	}
    impl = target.clear();\
for (unsigned int i = 0; i < 3; i++)\
    target.push_back(elements[i]);
}
function.public[] = {
	spec = virtual
	type = double
    const = true
	name = getElement
	shortDesc = Get element
	longDesc = Get the element at the specified index.
	param[] = {
		type = int
		name = index
		desc = Index
	}
    impl = 
    return = {
        value = (*this)[index];
        desc = Element at the specified index
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setElement
	shortDesc = Set element
	longDesc = Set the element at the specified index.
	param[] = {
		type = int
		name = index
		desc = Index
	}
	param[] = {
		type = double
		name = value
		desc = Value
	}
    impl = if ((index < 0) || (index > 2))\
\{\
    ostringstream message;\
    message << "Index out of range: " << index;\
    throw GeoUtilsError(message.str());\
\}\
elements[index] = value;
}
function.public[] = {
	spec = virtual
	type = bool
	name = eq
	shortDesc = Comparison (with tolerance): equal
	longDesc = Compare the vector with another vector using the specified tolerance.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = for (unsigned int i = 0; i < 3; i++)\
    if (!Ionflux::GeoUtils::eq(elements[i], other.elements[i], t))\
        return false;
    return = {
        value = true
        desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = flip
	const = true
	shortDesc = Flip vector
	longDesc = Create a new vector which is equal to the original vector multiplied by -1.
    impl = 
	return = {
        value = Vector3(-elements[0], -elements[1], -elements[2])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = double
	name = norm
	const = true
	shortDesc = Norm
	longDesc = Get the norm (length) of the vector.
    impl = 
	return = {
        value = ::sqrt((*this) * (*this))
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = normalize
	const = true
	shortDesc = Normalize vector
	longDesc = Create a new vector which is equal to the normalized original vector.
    impl = 
	return = {
        value = (*this) / norm()
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = cross
	const = true
	shortDesc = Cross product
	longDesc = Calculate the cross product of the vector and another vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = double x0 = elements[0];\
double x1 = elements[1];\
double x2 = elements[2];\
double y0 = other.elements[0];\
double y1 = other.elements[1];\
double y2 = other.elements[2];
	return = {
        value = Vector3(x1 * y2 - x2 * y1, \
    x2 * y0 - x0 * y2, \
    x0 * y1 - x1 * y0)
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = project
	const = true
	shortDesc = Projection
	longDesc = Calculate the projection of another vector on the vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = const Vector3& v0 = *this;
	return = {
        value = ((v0 * other) * v0) / (v0 * v0)
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = ortho
	const = true
	shortDesc = Orthogonalize vector
	longDesc = Rotate the other vector (v1) within the plane defined by the original vector (v0) and v1, so it is orthogonal to v0.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = const Vector3& v0 = *this;
	return = {
        value = other.norm() * (other - v0.project(other)).normalize()
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = ortho
	const = true
	shortDesc = Orthogonalize vector
	longDesc = Create a vector that is orthogonal to this one.
    impl = const int V3_P[] = \{ 0, 1, 2, 1, 0, 2, 2, 1, 0 \};\
int p = 0;\
if (elements[V3_P[p]] == 0)\
\{\
    p += 3;\
    if (elements[V3_P[p]] == 0)\
    \{\
        p += 3;\
        if (elements[V3_P[p]] == 0)\
            return Vector3(0., 0., 0.);\
    \}\
\}\
Vector3 t0(-elements[V3_P[p + 1]], elements[V3_P[p]], 0);
	return = {
        value = Vector3(t0.elements[V3_P[p]], t0.elements[V3_P[p + 1]], t0.elements[V3_P[p + 2]])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = double
	name = angle
	const = true
	shortDesc = Calculate angle
	longDesc = Calculate the geometric angle between the two vectors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = const Vector3& v0 = *this;\
double t = (v0 * other) / (v0.norm() * other.norm());\
if (t < -1.)\
    t = -1.;\
else\
if (t > 1.)\
    t = 1.;
	return = {
        value = ::acos(t)
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = permute
	const = true
	shortDesc = Permute vector
	longDesc = Permute the vector using the specified permutation of indices.
	param[] = {
		type = int
		name = px
		desc = Permutation (x)
	}
	param[] = {
		type = int
		name = py
		desc = Permutation (y)
	}
	param[] = {
		type = int
		name = pz
		desc = Permutation (z)
	}
    impl = const Vector3& v = *this;
	return = {
        value = Vector3(v[px], v[py], v[pz])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = permute
	const = true
	shortDesc = Permute vector
	longDesc = Permute the vector using the specified permutation of indices.
	param[] = {
		type = const Ionflux::ObjectBase::IntVector&
		name = p
		desc = Permutation
	}
    impl = if (p.size() < 3)\
    throw GeoUtilsError("Not enough elements in permutation vector.");\
const Vector3& v = *this;
	return = {
        value = Vector3(v[p[0]], v[p[1]], v[p[2]])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = multElements
	const = true
	shortDesc = Element-wise multiplication
	longDesc = Multiply the vectors element-wise.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = 
	return = {
        value = Vector3(elements[0] * other.elements[0], elements[1] * other.elements[1], elements[2] * other.elements[2])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = interpolate
	const = true
	shortDesc = Linear interpolation
	longDesc = Interpolate the vectors linearly.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
	param[] = {
		type = double
		name = t
		desc = Interpolation parameter
	}
    impl = 
	return = {
        value = t * (*this) + (1. - t) * other
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::AxisTriple
	name = getAxisOrder
    const = true
	shortDesc = Get axis order
	longDesc = Get the order of the coordinate axes of the vector. The axis with the highest absolute coordinate value will be the first in the triple, followed by the other ones in descending order.
    impl = AxisTriple result;\
result.a0 = AXIS_X;\
result.a1 = AXIS_Y;\
result.a2 = AXIS_Z;\
if (elements[AXIS_Y] > elements[AXIS_X])\
\{\
    result.a0 = AXIS_Y;\
    result.a1 = AXIS_X;\
\}\
if (elements[result.a2] > elements[result.a0])\
\{\
    AxisID t0 = result.a2;\
    result.a2 = result.a1;\
    result.a1 = result.a0;\
    result.a0 = t0;\
\}\
if (elements[result.a2] > elements[result.a1])\
\{\
    AxisID t0 = result.a1;\
    result.a1 = result.a2;\
    result.a2 = t0;\
\}
    return = {
        desc = Triple containing the axes ordered from longest to shortest
        value = result
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator==
	const = true
	shortDesc = Comparison operator: equality
	longDesc = Compare equality.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = for (unsigned int i = 0; i < 3; i++)\
    if (elements[i] != other.elements[i])\
        return false;
	return = {
        value = true
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator!=
	const = true
	shortDesc = Comparison operator: inequality
	longDesc = Compare inequality.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
	return.value = !(*this == other);
	return.desc = Result of the comparison
}
function.public[] = {
	spec = virtual
	type = double
	name = operator[]
	const = true
	shortDesc = Subscript operator
	longDesc = Subscript operator.
	param[] = {
		type = int
		name = index
		desc = Index
	}
    impl = if ((index < 0) || (index > 2))\
\{\
    ostringstream message;\
    message << "Index out of range: " << index;\
    throw GeoUtilsError(message.str());\
\}
	return = {
        value = elements[index]
        desc = Element at specified index
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = operator+
	const = true
	shortDesc = Add vectors
	longDesc = Add vectors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = 
	return = {
        value = Vector3(elements[0] + other.elements[0], \
    elements[1] + other.elements[1], \
    elements[2] + other.elements[2])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = operator-
	const = true
	shortDesc = Subtract vectors
	longDesc = Subtract vectors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = 
	return = {
        value = Vector3(elements[0] - other.elements[0], \
    elements[1] - other.elements[1], \
    elements[2] - other.elements[2])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = double
	name = operator*
	const = true
	shortDesc = Multiply vectors
	longDesc = Multiply vectors (dot product).
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = 
	return = {
        value = elements[0] * other.elements[0] + elements[1] * other.elements[1] + elements[2] * other.elements[2]
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = operator*
	const = true
	shortDesc = Multiply vector by scalar
	longDesc = Multiply vector by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
    impl = 
	return = {
        value = Vector3(elements[0] * c, elements[1] * c, elements[2] * c)
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = operator/
	const = true
	shortDesc = Divide vector by scalar
	longDesc = Divide vector by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
    impl = 
	return = {
        value = Vector3(elements[0] / c, elements[1] / c, elements[2] / c)
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3&
	name = operator+=
	shortDesc = Add vectors
	longDesc = Add vectors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = elements[0] += other.elements[0];\
elements[1] += other.elements[1];\
elements[2] += other.elements[2];
	return = {
        value = *this
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3&
	name = operator-=
	shortDesc = Add vectors
	longDesc = Add vectors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = other
		desc = Vector
	}
    impl = elements[0] -= other.elements[0];\
elements[1] -= other.elements[1];\
elements[2] -= other.elements[2];
	return = {
        value = *this
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = getV2
	const = true
	shortDesc = Create 2-element vector
	longDesc = Create a 2-element vector without the Z coordinate
	impl = 
    return = {
        value = Vector2(elements[0], elements[1])
        desc = 2-element vector
    }
}
function.public[] = {
	spec = virtual
	type = double
	name = distanceToPlane
    const = true
	shortDesc = Calculate distance to plane
	longDesc = Returns the distance of the point with coordinates indicated by the vector to the specified plane.
	param[] = {
		type = const Ionflux::GeoUtils::Plane3&
		name = plane
		desc = Plane
	}
    impl = 
    return = {
        value = (*this - plane.getP()) * plane.getNormal()
        desc = Distance to plane
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getString
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	impl = ostringstream state;\
state << getClassName() << "[" << elements[0] << ", " << elements[1] \
    << ", " << elements[2] << "]";
    return = {
        value = state.str()
        desc = String representation
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Vector3
	name = axis
	shortDesc = Get axis direction vector
	longDesc = Get the direction vector for the specified axis.
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = axisID
		desc = Axis
	}
    impl = if (axisID == AXIS_X)\
    return E_X;\
else\
if (axisID == AXIS_Y)\
    return E_Y;\
else\
if (axisID == AXIS_Z)\
    return E_Z;\
else\
\{\
    ostringstream status;\
    status << "Invalid axis: " << axisID;\
    throw GeoUtilsError(status.str());\
\}
	return = {
        value = ZERO
	    desc = Axis direction vector
    }
}

# Pure virtual member functions.

# operations

# Global functions.
function.global[] = {
	type = Ionflux::GeoUtils::Vector3
	name = operator*
	shortDesc = Multiply vector by scalar
	longDesc = Multiply vector by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = v
		desc = Vector
	}
    impl = 
	return = {
        value = v * c
	    desc = Result of the calculation
    }
}

