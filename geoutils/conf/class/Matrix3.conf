# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Matrix3.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/types.hpp"'
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/Vector2.hpp"'
        '"geoutils/Matrix2.hpp"'
        '"geoutils/Vector3.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/gslutils.hpp"'
    }
}

# forward declarations
forward = {
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Matrix3
	shortDesc = Matrix (3x3)
	title = Matrix (3x3)
	longDesc = A 3x3 matrix.
	group.name = geoutils
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
		}
	}
    features = {
        'copy'
    }
}

# Public constructors.
constructor.copy.impl = elements = new double[9];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
*this = other;
constructor.default = {
    initializer[] = {
        name = elements
        value = 0
    }
    impl = elements = new double[9];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
*this = ZERO;
}
constructor.public[] = {
    initializer[] = {
        name = elements
        value = 0
    }
    param[] = {
        name = initX00
        type = double
        desc = Element x00
    }
    param[] = {
        name = initX01
        type = double
        desc = Element x01
    }
    param[] = {
        name = initX02
        type = double
        desc = Element x02
    }
    param[] = {
        name = initX10
        type = double
        desc = Element x10
    }
    param[] = {
        name = initX11
        type = double
        desc = Element x11
    }
    param[] = {
        name = initX12
        type = double
        desc = Element x12
    }
    param[] = {
        name = initX20
        type = double
        desc = Element x20
    }
    param[] = {
        name = initX21
        type = double
        desc = Element x21
    }
    param[] = {
        name = initX22
        type = double
        desc = Element x22
    }
    impl = elements = new double[9];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
elements[0] = initX00;\
elements[1] = initX01;\
elements[2] = initX02;\
elements[3] = initX10;\
elements[4] = initX11;\
elements[5] = initX12;\
elements[6] = initX20;\
elements[7] = initX21;\
elements[8] = initX22;
}
constructor.public[] = {
    initializer[] = {
        name = elements
        value = 0
    }
    param[] = {
        name = initElements
        type = const Ionflux::ObjectBase::DoubleVector&
        desc = Element vector
    }
    impl = elements = new double[9];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
setElements(initElements);
}

# Destructor.
destructor.impl = delete[] elements;

# Member variables.
variable.protected[] = {
	type = double*
	name = elements
	desc = Elements
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3
	setFromType = const Ionflux::GeoUtils::Vector3&
	name = r0
	desc = Row vector (0)
    proxy = true
    impl.get = return Vector3(elements[0], elements[1], elements[2]);
    impl.set = elements[0] = newR0.getX0();\
elements[1] = newR0.getX1();\
elements[2] = newR0.getX2();
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3
	setFromType = const Ionflux::GeoUtils::Vector3&
	name = r1
	desc = Row vector (1)
    proxy = true
    impl.get = return Vector3(elements[3], elements[4], elements[5]);
    impl.set = elements[3] = newR1.getX0();\
elements[4] = newR1.getX1();\
elements[5] = newR1.getX2();
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3
	setFromType = const Ionflux::GeoUtils::Vector3&
	name = r2
	desc = Row vector (2)
    proxy = true
    impl.get = return Vector3(elements[6], elements[7], elements[8]);
    impl.set = elements[6] = newR2.getX0();\
elements[7] = newR2.getX1();\
elements[8] = newR2.getX2();
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3
	setFromType = const Ionflux::GeoUtils::Vector3&
	name = c0
	desc = Column vector (0)
    proxy = true
    impl.get = return Vector3(elements[0], elements[3], elements[6]);
    impl.set = elements[0] = newC0.getX0();\
elements[3] = newC0.getX1();\
elements[6] = newC0.getX2();
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3
	setFromType = const Ionflux::GeoUtils::Vector3&
	name = c1
	desc = Column vector (1)
    proxy = true
    impl.get = return Vector3(elements[1], elements[4], elements[7]);
    impl.set = elements[1] = newC1.getX0();\
elements[4] = newC1.getX1();\
elements[7] = newC1.getX2();
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector3
	setFromType = const Ionflux::GeoUtils::Vector3&
	name = c2
	desc = Column vector (2)
    proxy = true
    impl.get = return Vector3(elements[2], elements[5], elements[8]);
    impl.set = elements[2] = newC2.getX0();\
elements[5] = newC2.getX1();\
elements[8] = newC2.getX2();
}

# Public static constants.
constant.public[] = {
    desc = Zero matrix
    type = Ionflux::GeoUtils::Matrix3
    name = ZERO
    value = Ionflux::GeoUtils::Matrix3(0., 0., 0., 0., 0., 0., 0., 0., 0.)
}
constant.public[] = {
    desc = Unit matrix
    type = Ionflux::GeoUtils::Matrix3
    name = UNIT
    value = Ionflux::GeoUtils::Matrix3(1., 0., 0., 0., 1., 0., 0., 0., 1.)
}

# Protected static constants.

# Protected member functions.

# Public member functions.
function.copy.impl = if ((elements == 0) || (other.elements == 0))\
    return *this;\
for (unsigned int i = 0; i < 9; i++)\
    elements[i] = other.elements[i];\
return *this;
function.public[] = {
	spec = virtual
	type = void
	name = setElements
	shortDesc = Set elements
	longDesc = Set elements from a vector of doubles. If the vector contains fewer than the required number of elements, the remaining elements will be left alone.
	param[] = {
		type = const Ionflux::ObjectBase::DoubleVector&
		name = newElements
		desc = Element vector
	}
    impl = unsigned int i = 0;\
while ((i < 9) && (i < newElements.size()))\
\{\
    elements[i] = newElements[i];\
    i++;\
\}
}
function.public[] = {
	spec = virtual
	type = void
	name = getElements
	const = true
	shortDesc = Get elements
	longDesc = Store the elements of the matrix in a vector of doubles.
	param[] = {
		type = Ionflux::ObjectBase::DoubleVector&
		name = target
		desc = Target vector
	}
    impl = target.clear();\
for (unsigned int i = 0; i < 9; i++)\
    target.push_back(elements[i]);
}
function.public[] = {
	spec = virtual
	type = double
	name = getElement
	const = true
	shortDesc = Get element
	longDesc = Get the element at the specified position.
	param[] = {
		type = int
		name = row
		desc = Row index
	}
	param[] = {
		type = int
		name = column
		desc = Column index
	}
    impl = if ((row < 0) || (row > 2))\
\{\
    ostringstream message;\
    message << "Row index out of range: " << row;\
    throw GeoUtilsError(message.str());\
\}\
if ((column < 0) || (column > 2))\
\{\
    ostringstream message;\
    message << "Column index out of range: " << column;\
    throw GeoUtilsError(message.str());\
\}
    return = {
        value = elements[3 * row + column];
        desc = Element at the specified index
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setElement
	shortDesc = Set element
	longDesc = Set the element at the specified index.
	param[] = {
		type = int
		name = row
		desc = Row index
	}
	param[] = {
		type = int
		name = column
		desc = Column index
	}
	param[] = {
		type = double
		name = value
		desc = Value
	}
    impl = if ((row < 0) || (row > 2))\
\{\
    ostringstream message;\
    message << "Row index out of range: " << row;\
    throw GeoUtilsError(message.str());\
\}\
if ((column < 0) || (column > 2))\
\{\
    ostringstream message;\
    message << "Column index out of range: " << column;\
    throw GeoUtilsError(message.str());\
\}\
elements[3 * row + column] = value;
}
function.public[] = {
	spec = virtual
	type = bool
	name = eq
	shortDesc = Comparison (with tolerance): equal
	longDesc = Compare the matrix with another matrix using the specified tolerance.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = other
		desc = Matrix
	}
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = for (unsigned int i = 0; i < 9; i++)\
    if (!Ionflux::GeoUtils::eq(elements[i], other.elements[i], t))\
        return false;
    return = {
        value = true
        desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix3
	name = transpose
	const = true
	shortDesc = Transpose
	longDesc = Transpose the matrix.
	return = {
        value = Matrix3(elements[0], elements[3], elements[6], \
    elements[1], elements[4], elements[7], \
    elements[2], elements[5], elements[8])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix3
	name = permuteColumns
	const = true
	shortDesc = Permute columns
	longDesc = Permute the columns using the specified permutation of indices.
	param[] = {
		type = int
		name = px
		desc = Permutation (x)
	}
	param[] = {
		type = int
		name = py
		desc = Permutation (y)
	}
	param[] = {
		type = int
		name = pz
		desc = Permutation (z)
	}
    impl = 
	return = {
        value = Matrix3(elements[px], elements[py], elements[pz], \
    elements[3 + px], elements[3 + py], elements[3 + pz], \
    elements[6 + px], elements[6 + py], elements[6 + pz])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix3
	name = permuteColumns
	const = true
	shortDesc = Permute columns
	longDesc = Permute the columns using the specified permutation of indices.
	param[] = {
		type = const Ionflux::ObjectBase::IntVector&
		name = p
		desc = Permutation
	}
    impl = if (p.size() < 3)\
    throw GeoUtilsError("Not enough elements in permutation vector.");
	return = {
        value = permuteColumns(p[0], p[1], p[2])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = solve
	const = true
	shortDesc = Solve matrix equation
	longDesc = Solve the matrix equation Mx = v.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = v
		desc = Vector
	}
    impl = double x11 = elements[0];\
double x12 = elements[1];\
double x13 = elements[2];\
double x21 = elements[3];\
double x22 = elements[4];\
double x23 = elements[5];\
double x31 = elements[6];\
double x32 = elements[7];\
double x33 = elements[8];\
double a = v.getElement(0);\
double b = v.getElement(1);\
double c = v.getElement(2);\
Vector3 result;\
if (x11 != 0.0)\
\{\
    double y11 = (x22 * x11 - x12 * x21) / x11;\
    double y12 = (x23 * x11 - x13 * x21) / x11;\
    double y21 = (x32 * x11 - x12 * x31) / x11;\
    double y22 = (x33 * x11 - x13 * x31) / x11;\
    double d = (b * x11 - a * x21) / x11;\
    double e = (c * x11 - a * x31) / x11;\
    Vector2 r0 = Matrix2(y11, y12, y21, y22).solve(Vector2(d, e));\
    double x = (a - r0[0] * x12 - r0[1] * x13) / x11;\
    result.setElement(0, x);\
    result.setElement(1, r0.getElement(0));\
    result.setElement(2, r0.getElement(1));\
\} else\
if (x12 != 0.0)\
    result = permuteColumns(1, 0, 2).solve(v).permute(1, 0, 2);\
else\
if (x13 != 0.0)\
    result = permuteColumns(2, 1, 0).solve(v).permute(2, 1, 0);\
else\
    throw GeoUtilsError("Cannot solve 3x3 matrix equation.");
	return = {
        value = result
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix3
	name = invert
	const = true
	shortDesc = Invert matrix
	longDesc = Invert the matrix.
    impl = Vector3 x = solve(Vector3::E_X);\
Vector3 y = solve(Vector3::E_Y);\
Vector3 z = solve(Vector3::E_Z);\
Matrix3 result;\
result.setC0(x);\
result.setC1(y);\
result.setC2(z);
	return = {
        value = result
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator==
	const = true
	shortDesc = Comparison operator: equality
	longDesc = Compare equality.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = other
		desc = Matrix
	}
    impl = for (unsigned int i = 0; i < 9; i++)\
    if (elements[i] != other.elements[i])\
        return false;
	return = {
        value = true
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator!=
	const = true
	shortDesc = Comparison operator: inequality
	longDesc = Compare inequality.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = other
		desc = Matrix
	}
	return.value = !(*this == other);
	return.desc = Result of the comparison
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = operator[]
	const = true
	shortDesc = Subscript operator
	longDesc = Subscript operator.
	param[] = {
		type = int
		name = index
		desc = Index
	}
    impl = if ((index < 0) || (index > 2))\
\{\
    ostringstream message;\
    message << "Index out of range: " << index;\
    throw GeoUtilsError(message.str());\
\}
	return = {
        value = Vector3(elements[3 * index], elements[3 * index + 1], \
    elements[3 * index + 2])
        desc = Row vector with specified index
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix3
	name = operator*
	const = true
	shortDesc = Multiply matrices
	longDesc = Multiply matrices.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = other
		desc = Matrix
	}
    impl = Matrix3 result;\
for (unsigned int i = 0; i < 3; i++)\
    for (unsigned int j = 0; j < 3; j++)\
    \{\
        double s = 0.0;\
        for (unsigned int k = 0; k < 3; k++)\
            s += elements[3 * i + k] * other.elements[3 * k + j];\
        result.elements[3 * i + j] = s;\
    \}
	return = {
        value = result
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = operator*
	const = true
	shortDesc = Transform vector
	longDesc = Transform a vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = v
		desc = Vector
	}
    impl = double result[3];\
for (unsigned int i = 0; i < 3; i++)\
\{\
    double s = 0.0;\
    for (unsigned int k = 0; k < 3; k++)\
        s += elements[3 * i + k] * v.getElement(k);\
    result[i] = s;\
\}
	return = {
        value = Vector3(result[0], result[1], result[2])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix3
	name = operator*
	const = true
	shortDesc = Multiply matrix by scalar
	longDesc = Multiply matrix by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
    impl = Matrix3 result;\
for (unsigned int i = 0; i < 9; i++)\
    result.elements[i] = elements[i] * c;
	return = {
        value = result
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix3
	name = operator/
	const = true
	shortDesc = Divide matrix by scalar
	longDesc = Divide matrix by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
    impl = Matrix3 result;\
for (unsigned int i = 0; i < 9; i++)\
    result.elements[i] = elements[i] / c;
	return = {
        value = result
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = svd
	const = true
	shortDesc = Calculate singular value decomposition
	longDesc = Calculate the singular value decomposition M = U S V^T of the matrix.
	param[] = {
		type = Ionflux::GeoUtils::Matrix3&
		name = u
		desc = U
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector3&
		name = s
		desc = singular values
	}
	param[] = {
		type = Ionflux::GeoUtils::Matrix3&
		name = v
		desc = V
	}
    impl = Ionflux::GeoUtils::svd(*this, u, s, v);
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getString
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	impl = ostringstream state;\
state << getClassName() << "[[" << elements[0] << ", " \
    << elements[1] << ", " << elements[2] << "], [" \
    << elements[3] << ", " << elements[4] << ", " \
    << elements[5] << "], [" << elements[6] << ", " \
    << elements[7] << ", " << elements[8] << "]]";
    return = {
        value = state.str()
        desc = String representation
    }
}

# static member functions
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Matrix3
	name = scale
	shortDesc = Create scale matrix
	longDesc = Create a scale matrix.
	param[] = {
		type = double
		name = sx
		desc = Scale factor (x)
        default = 1.
	}
	param[] = {
		type = double
		name = sy
		desc = Scale factor (y)
        default = 1.
	}
	param[] = {
		type = double
		name = sz
		desc = Scale factor (z)
        default = 1.
	}
	impl = 
    return = {
        value = Matrix3(sx, 0., 0., 0., sy, 0., 0., 0., sz)
        desc = Scale matrix
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Matrix3
	name = translate
	shortDesc = Create translation matrix
	longDesc = Create a translation matrix.
	param[] = {
		type = double
		name = tx
		desc = Translation distance (x)
        default = 0.
	}
	param[] = {
		type = double
		name = ty
		desc = Translation distance (y)
        default = 0.
	}
	impl = 
    return = {
        value = Matrix3(1., 0., tx, 0., 1., ty, 0., 0., 1.)
        desc = Translation matrix
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Matrix3
	name = rotate
	shortDesc = Create rotation matrix
	longDesc = Create a rotation matrix.
	param[] = {
		type = double
		name = phi
		desc = Angle
        default = 0.
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = axis
		desc = Axis
        default = Ionflux::GeoUtils::AXIS_Z
	}
	impl = if (axis == AXIS_X)\
    return Matrix3(1., 0., 0., \
        0., ::cos(phi), -::sin(phi), \
        0., ::sin(phi), ::cos(phi));\
else\
if (axis == AXIS_Y)\
    return Matrix3(::cos(phi), 0., ::sin(phi), \
        0., 1., 0., \
        -::sin(phi), 0., ::cos(phi));\
else\
if (axis == AXIS_Z)\
    return Matrix3(::cos(phi), -::sin(phi), 0., \
        ::sin(phi), ::cos(phi), 0., \
        0., 0., 1.);\
else\
\{\
    ostringstream status;\
    status << "Invalid axis: " << axis;\
    throw GeoUtilsError(status.str());\
\}
    return = {
        value = ZERO
        desc = Rotation matrix
    }
}

# Pure virtual member functions.

# operations

# Global functions.
function.global[] = {
	type = Ionflux::GeoUtils::Matrix3
	name = operator*
	shortDesc = Multiply matrix by scalar
	longDesc = Multiply matrix by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = m
		desc = Matrix
	}
    impl = 
	return = {
        value = m * c
	    desc = Result of the calculation
    }
}

