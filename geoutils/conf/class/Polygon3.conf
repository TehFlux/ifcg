# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009-2013 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Polygon3.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
        '"ifmapping/BezierSpline.hpp"'
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/Vertex3.hpp"'
        '"geoutils/Vertex3Set.hpp"'
        '"geoutils/Edge.hpp"'
        '"geoutils/Vector3.hpp"'
        '"geoutils/Matrix3.hpp"'
        '"geoutils/Plane3.hpp"'
        '"geoutils/Polygon2.hpp"'
        '"geoutils/Matrix4.hpp"'
        '"geoutils/Range3.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"ifobject/objectutils.hpp"'
        '"ifmapping/BezierCurve.hpp"'
#        '"geoutils/Clock.hpp"'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/Line3.hpp"'
    }
}

# forward declarations
forward = {
    'class Polygon3'
}

# undefine macros

## typedefs
#typedef = {
#}

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Polygon3
	shortDesc = Polygon (3D)
	title = Polygon (3D)
	longDesc = A polygon in three-dimensional space.
	group.name = geoutils
	base = {
		## base classes from the IFObject hierarchy
		#ifobject[] = {
		#	name = IFObject
		#}
        # other base classes
        other[] = {
			name = Ionflux::GeoUtils::TransformableObject
            include = geoutils/TransformableObject.hpp
		}
	}
    features = {
        'copy'
        'logmessage'
        'classinfo'
        'upcast'
        'create'
        'xmlio'
    }
    create = {
        allocationError = GeoUtilsError("Could not allocate object.")
        extendedCreate = true
    }
    xml.elementName = polygon3
}

# Member variables.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    type = Ionflux::GeoUtils::Vertex3Set*
    setFromType = Ionflux::GeoUtils::Vertex3Set*
    name = vertexSource
    desc = Vertex source
    managed = true
    valueType = object
    xml = {
        child = {
            name = vertex_source
            #elementName = vertex3set
        }
        createFunc = createVertex3Set
    }
}
property.protected[] = {
    style = vector
    name = vertices
    desc = Vertex vector
    element = {
        type = Ionflux::GeoUtils::Vertex3*
        name = Vertex
        plural = Vertices
        #managed = true
    }
    proxy = true
    proxy.target = vertexSource
    proxy.nullError = GeoUtilsError("Vertex source not set.")
    extendedAddFuncs = true
}
property.protected[] = {
    style = vector
    name = edges
    desc = Edge vector
    element = {
        type = Ionflux::GeoUtils::Edge*
        name = Edge
        managed = true
        valueType = object
        createExpr = Edge::create()
    }
    xml.child = {
        name = edges
    }
    extendedAddFuncs = true
}

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = vertexSource
        value = 0
    }
    impl = setVertexSource(Vertex3Set::create());
}
constructor.public[] = {
    initializer[] = {
        name = vertexSource
        value = 0
    }
    param[] = {
        name = initVertices
        type = Ionflux::GeoUtils::Vertex3Vector*
        desc = Vertices
    }
    param[] = {
        name = initEdges
        type = Ionflux::GeoUtils::EdgeVector*
        desc = Edges
        default = 0
    }
    impl = <<<
setVertexSource(Vertex3Set::create());
if (initVertices != 0)
    addVertices(*initVertices);
if (initEdges != 0)
    addEdges(*initEdges);
>>>
}
constructor.public[] = {
    initializer[] = {
        name = vertexSource
        value = 0
    }
    param[] = {
        name = initVertexSource
        type = Ionflux::GeoUtils::Vertex3Set*
        desc = Vertex source
    }
    param[] = {
        name = initEdges
        type = Ionflux::GeoUtils::EdgeVector*
        desc = Edges
        default = 0
    }
    impl = <<<
if (initVertexSource)
    setVertexSource(initVertexSource);
else
    setVertexSource(Vertex3Set::create());
if (initEdges != 0)
    addEdges(*initEdges);
>>>
}
constructor.public[] = {
    initializer[] = {
        name = vertexSource
        value = 0
    }
    param[] = {
        name = v0
        type = const Ionflux::GeoUtils::Vertex3*
        desc = Vertex (0)
    }
    param[] = {
        name = v1
        type = const Ionflux::GeoUtils::Vertex3*
        desc = Vertex (1)
    }
    param[] = {
        name = v2
        type = const Ionflux::GeoUtils::Vertex3*
        desc = Vertex (2)
    }
    param[] = {
        name = v3
        type = const Ionflux::GeoUtils::Vertex3*
        desc = Vertex (3)
        default = 0
    }
    impl = <<<
setVertexSource(Vertex3Set::create());
Vertex3* vt0 = 0;
if (v0 != 0)
{
    vt0 = Vertex3::create();
    *vt0 = *v0;
    addVertex(vt0);
}
if (v1 != 0)
{
    vt0 = Vertex3::create();
    *vt0 = *v1;
    addVertex(vt0);
}
if (v2 != 0)
{
    vt0 = Vertex3::create();
    *vt0 = *v2;
    addVertex(vt0);
}
if (v3 != 0)
{
    vt0 = Vertex3::create();
    *vt0 = *v3;
    addVertex(vt0);
}
createEdges();
>>>
}

# Destructor.
#destructor.impl = 

# Public static constants.
constant.public[] = {
    type = Ionflux::GeoUtils::Range
    name = UV_RANGE
    desc = Point UV coordinate range
    value = Ionflux::GeoUtils::Range(0., 1.)
}

# Protected static constants.

# Protected member functions.
function.protected[] = {
	spec = virtual
	type = void
	name = recalculateBounds
	shortDesc = Recalculate bounds
	longDesc = Recalculate the bounds for the polygon.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "recalculateBounds", "Vertex source");
TransformableObject::recalculateBounds();
if (!useTransform() && !useVI())
{
    *boundsCache = vertexSource->getBounds();
    return;
}
// Adjust for transformation.
Polygon3* p0 = copy();
addLocalRef(p0);
p0->applyTransform();
if (p0->useTransform())
    throw GeoUtilsError(getErrorString(
        "Transform matrix still in use after "
        "applying transformations.", "recalculateBounds"));
*boundsCache = p0->getBounds();
removeLocalRef(p0);
>>>
}

# Public member functions.
function.copy.impl = <<<
if (this == &other)
    return *this;
TransformableObject::operator=(other);
setVertexSource(other.vertexSource);
EdgeVector e0;
for (EdgeVector::const_iterator i = other.edges.begin(); 
    i != other.edges.end(); i++)
{
    Edge* et0 = Ionflux::ObjectBase::nullPointerCheck(*i, this, 
        "operator=", "Edge");
    e0.push_back(et0->copy());
}
clearEdges();
addEdges(e0);
>>>
function.public[] = {
	spec = virtual
	type = void
	name = clearData
	shortDesc = Clear data
	longDesc = Clears the polygon data but keeps the vertex source.
    impl = <<<
if (vertexSource != 0)
    vertexSource->clearVertices();
clearEdges();
TransformableObject::clear();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = copyVertices
	shortDesc = Copy vertices
	longDesc = Create a new vertex set with copies of the current vertices. This makes the polygon the (current) single owner of its vertices.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "copyVertices", "Vertex source");
setVertexSource(vertexSource->copy());
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Edge*
	name = addEdge
	shortDesc = Add edge
	longDesc = Add a new edge that connects the vertices with indices \c i0 and \c i1.
	param[] = {
		type = int
		name = i0
		desc = Vertex Index (0)
	}
	param[] = {
		type = int
		name = i1
		desc = Vertex Index (1)
	}
    impl = <<<
unsigned int numVerts = getNumVertices();
if ((static_cast<unsigned int>(i0) < 0) 
    || (static_cast<unsigned int>(i0) > numVerts))
{
    std::ostringstream status;
    status << "Vertex index i0 out of range (i0 = " << i0 << ").";
    throw GeoUtilsError(getErrorString(status.str(), "addEdge"));
}
if ((static_cast<unsigned int>(i1) < 0) 
    || (static_cast<unsigned int>(i1) > numVerts))
{
    std::ostringstream status;
    status << "Vertex index i1 out of range (i1 = " << i1 << ").";
    throw GeoUtilsError(getErrorString(status.str(), "addEdge"));
}
Edge* e0 = addEdge();
e0->setVertices(i0, i1);
>>>
    return = {
        value = e0
        desc = New edge
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = createEdges
	shortDesc = Create edges
	longDesc = Takes two subsequent vertices from the list to create edges.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "createEdges", "Vertex source");
clearEdges();
unsigned int numVerts = getNumVertices();
if (numVerts < 2)
    return 0;
Edge* e0 = 0;
for (unsigned int i = 1; i < numVerts; i++)
{
    e0 = Edge::create();
    e0->setV0(i - 1);
    e0->setV1(i);
    addEdge(e0);
}
if (numVerts >= 3)
{
    e0 = Edge::create();
    e0->setV0(numVerts - 1);
    e0->setV1(0);
    addEdge(e0);
}
>>>
    return = {
        value = edges.size()
        desc = The number of edges created
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Plane3
	name = getPlane
    const = true
	shortDesc = Get plane spanned by vertices
	longDesc = Get the plane spanned by the specified three vertex indices. If the vertices parameter is not specified, the first two and the last vertices are used.
	param[] = {
		type = int
		name = v0
		desc = First vertex index
        default = 0
	}
	param[] = {
		type = int
		name = v1
		desc = Second vertex index
        default = 1
	}
	param[] = {
		type = int
		name = v2
		desc = Third vertex index
        default = -1
	}
    impl = <<<
unsigned int numVerts = getNumVertices();
if (v0 < 0)
    v0 = numVerts + v0;
if (v1 < 0)
    v1 = numVerts + v1;
if (v2 < 0)
    v2 = numVerts + v2;
if ((v0 < 0) || (static_cast<unsigned int>(v0) >= numVerts))
{
    std::ostringstream status;
    status << "Vertex index v0 out of range (numVerts = " 
        << numVerts << ", v0 = " << v0 << ").";
    throw GeoUtilsError(getErrorString(status.str(), "getPlane"));
}
if ((v1 < 0) || (static_cast<unsigned int>(v1) >= numVerts))
{
    std::ostringstream status;
    status << "Vertex index v1 out of range (numVerts = " 
        << numVerts << ", v1 = " << v1 << ").";
    throw GeoUtilsError(getErrorString(status.str(), "getPlane"));
}
if ((v2 < 0) || (static_cast<unsigned int>(v2) >= numVerts))
{
    std::ostringstream status;
    status << "Vertex index v2 out of range (numVerts = " 
        << numVerts << ", v2 = " << v2 << ").";
    throw GeoUtilsError(getErrorString(status.str(), "getPlane"));
}
Vector3 a = getVertex(v0)->getVector();
Vector3 b = getVertex(v1)->getVector();
Vector3 c = getVertex(v2)->getVector();
>>>
    return = {
        value = Plane3(a, b - a, c - a);
        desc = Plane spanned by the vertices
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object.
	impl = <<<
ostringstream status;
status << "verts: [";
bool e0 = true;
for (unsigned int i = 0; i < getNumVertices(); i++)
{
    Vertex3* v0 = getVertex(i);
    if (!e0)
        status << ", ";
    else
        e0 = false;
    status << "(" << v0->getValueString() << ")";
}
status << "]";
if (edges.size() > 0)
{
    status << " edges: [";
    e0 = true;
    for (EdgeVector::const_iterator j = edges.begin(); 
        j != edges.end(); j++)
    {
        if (!e0)
            status << ", ";
        else
            e0 = false;
        status << "(" << (*j)->getValueString() << ")";
    }
    status << "]";
}
// transformable object data
std::string ts0(TransformableObject::getValueString());
if (ts0.size() > 0)
    status << "; " << ts0;
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getSVG
	shortDesc = Get SVG representation
	longDesc = Get a Scalable Vector Graphics (XML) representation of the polygon. The polygon will be projected orthogonally to the appropriate coordinate plane along the specified axis. The type of SVG element that is created to represent the polygon depends on the \c shapeType parameter. If the shape type is \c SHAPE_TYPE_PATH and \c closePath is \c true (the default), the path will be closed.
    param[] = {
        type = const std::string&
        name = attrs
        desc = Element attributes
        default = SVG_DEFAULT_POLY_STYLE
    }
    param[] = {
        type = const std::string&
        name = elementID
        desc = Element ID
        default = "polygon"
    }
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = axis
        desc = Projection axis
        default = Ionflux::GeoUtils::AXIS_Y
    }
    param[] = {
        type = Ionflux::GeoUtils::SVGShapeType
        name = shapeType
        desc = Shape type
        default = Ionflux::GeoUtils::DEFAULT_SHAPE_TYPE
    }
    param[] = {
        type = bool
        name = closePath
        desc = Close path
        default = true
    }
	impl = <<<
std::ostringstream svg;
AxisID oa[2];
if (axis == AXIS_Y)
{
    oa[0] = AXIS_X;
    oa[1] = AXIS_Z;
} else
if (axis == AXIS_X)
{
    oa[0] = AXIS_Y;
    oa[1] = AXIS_Z;
} else
if (axis == AXIS_Z)
{
    oa[0] = AXIS_X;
    oa[1] = AXIS_Y;
} else
{
    svg << "Invalid axis: " << axis;
    throw GeoUtilsError(svg.str());
}
if (shapeType == SHAPE_TYPE_POLYGON)
    svg << "<polygon";
else
if (shapeType == SHAPE_TYPE_PATH)
    svg << "<path";
else
{
    std::ostringstream message;
    message << "Unknown shape type: " << shapeType;
    throw GeoUtilsError(message.str());
}
if (elementID.size() > 0)
    svg << " id=\"" << elementID << "\"";
if (attrs.size() > 0)
    svg << " " << attrs;
if (shapeType == SHAPE_TYPE_POLYGON)
    svg << " points=\"";
else
    svg << " d=\"";
bool s0 = true;
/* <---- DEBUG ----- //
ostringstream message;
message << "Before applyTransform(): numVertices = " << getNumVertices();
log(IFLogMessage(message.str(), VL_DEBUG, this, "getSVG"));
// <---- DEBUG ----- */
applyTransform();
/* <---- DEBUG ----- //
message.str("");
message << "After applyTransform(): numVertices = " << getNumVertices();
log(IFLogMessage(message.str(), VL_DEBUG, this, "getSVG"));
// <---- DEBUG ----- */
for (unsigned int i = 0; i < getNumVertices(); i++)
{
    Vertex3* v0 = getVertex(i);
    if (!s0)
    {
        svg << " ";
        if (shapeType == SHAPE_TYPE_PATH)
            svg << "L ";
    } else
    {
        if (shapeType == SHAPE_TYPE_PATH)
            svg << "M ";
        s0 = false;
    }
    svg << (*v0)[oa[0]] << "," << (*v0)[oa[1]];
}
if (closePath 
    && (shapeType == SHAPE_TYPE_PATH))
    svg << " z";
svg << "\" />";
>>>
    return = {
        value = svg.str()
        desc = SVG representation
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getSVG
	shortDesc = Get SVG representation
	longDesc = Get a Scalable Vector Graphics (XML) representation of the polygon. The polygon will be projected orthogonally to the appropriate coordinate plane along the specified axis. The type of SVG element that is created to represent the polygon depends on the \c shapeType parameter. If the shape type is \c SHAPE_TYPE_PATH and \c closePath is \c true (the default), the path will be closed.
    param[] = {
        type = const Ionflux::GeoUtils::SVGShapeStyle&
        name = style
        desc = Shape style
    }
    param[] = {
        type = const std::string&
        name = elementID
        desc = Element ID
        default = "polygon"
    }
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = axis
        desc = Projection axis
        default = Ionflux::GeoUtils::AXIS_Y
    }
    param[] = {
        type = Ionflux::GeoUtils::SVGShapeType
        name = shapeType
        desc = Shape type
        default = Ionflux::GeoUtils::DEFAULT_SHAPE_TYPE
    }
    param[] = {
        type = bool
        name = closePath
        desc = Close path
        default = true
    }
	impl = std::string a0 = getSVGPolygonStyle(style);
    return = {
        value = getSVG(a0, elementID, axis, shapeType, closePath)
        desc = SVG representation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getBarycenter
	shortDesc = Get barycenter
	longDesc = Get the barycenter vector for the polygon.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "getBarycenter", "Vertex source");
if (!useTransform() && !useVI())
    return vertexSource->getBarycenter();
// Adjust for transformation.
Vertex3 v0(vertexSource->getBarycenter());
if (useTransform())
    v0.transform(*getTransformMatrix());
if (useVI())
    v0.transformVI(*getViewMatrix(), getImageMatrix());
>>>
    return = {
        value = v0.getVector()
        desc = Barycenter vector
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = applyTransform
	shortDesc = Apply transformations
	longDesc = Apply transformations that have been accumulated in the transformation matrices.
	param[] = {
	    type = bool
	    name = recursive
	    desc = Apply transformations recursively
	    default = false
	}
    impl = <<<
if (vertexSource == 0)
{
    clearTransformations();
    return;
}
if (!useTransform() && !useVI())
{
    if (recursive)
        vertexSource->applyTransform(recursive);
    clearTransformations();
    return;
}
copyVertices();
if (useTransform())
    vertexSource->transform(*getTransformMatrix());
if (useVI())
    vertexSource->transformVI(*getViewMatrix(), getImageMatrix());
if (useTransform() || useVI())
    vertexSource->applyTransform(recursive);
clearTransformations();
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = scale
	shortDesc = Scale
	longDesc = Scale the object by the specified scale factors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = s
		desc = Vector of scale factors
	}
    impl = TransformableObject::scale(s);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = translate
	shortDesc = Translate
	longDesc = Translate the object by the specified vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = t
		desc = Translation vector
	}
    impl = TransformableObject::translate(t);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = rotate
	shortDesc = Rotate
	longDesc = Rotate the object by the specified angle around the specified axis.
	param[] = {
		type = double
		name = phi
		desc = Angle
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = axis
		desc = Axis
        default = Ionflux::GeoUtils::AXIS_Z
	}
    impl = TransformableObject::rotate(phi, axis);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = normalize
	shortDesc = Normalize
	longDesc = Normalize the object, i.e. scale to unit size.
    impl = TransformableObject::normalize();
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = center
	shortDesc = Center
	longDesc = Center the object using the specified method and origin vector.
	param[] = {
		type = Ionflux::GeoUtils::CenteringMethod
		name = method
		desc = Centering method
        default = Ionflux::GeoUtils::CENTER_BARYCENTER
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector3*
		name = origin
		desc = Origin or offset vector
        default = 0
	}
    impl = TransformableObject::center(method, origin);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix4&
		name = matrix
		desc = Transformation matrix
	}
    impl = TransformableObject::transform(matrix);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = matrix
		desc = Transformation matrix
	}
    impl = TransformableObject::transform(matrix);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = duplicate
	shortDesc = Duplicate
	longDesc = Create an exact duplicate of the object. The duplicate is a new object which must be managed by the caller.
    impl = 
    return = {
        value = *copy()
        desc = The duplicated object
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isPlanar
	shortDesc = Planarity check
	longDesc = Check whether the polygon is planar.
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
Plane3 pl0 = getPlane();
for (unsigned int i = 0; i < getNumVertices(); i++)
{
    double d0 = getVertex(i)->distanceToPlane(pl0);
    if (!eq(d0, 0., t))
        return false;
}
>>>
    return = {
        value = true
        desc = Check result
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getPolygon2
	shortDesc = Get polygon (2D)
	longDesc = Create a 2D polygon from the 3D polygon. The vertex coordinates are projected along the Z axis.
	param[] = {
	    type = Ionflux::GeoUtils::Polygon2&
	    name = target
	    desc = target polygon
	}
    impl = <<<
for (unsigned int i = 0; i < getNumVertices(); i++)
{
    Vertex3* vt0 = Ionflux::ObjectBase::nullPointerCheck(
        getVertex(i), this, "getPolygon2", "Vertex");
    target.addVertex(Vertex2::create(vt0->getX(), vt0->getY()));
}
for (unsigned int i = 0; i < getNumEdges(); i++)
{
    Edge* et0 = Ionflux::ObjectBase::nullPointerCheck(
        getEdge(i), this, "getPolygon2", "Edge");
    target.addEdge(et0->copy());
}
>>>
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Polygon3*
	name = square
	shortDesc = Create polygon: square
	longDesc = Create a square polygon.
    impl = <<<
Polygon3* p0 = Polygon3::create();
double s = 0.5;
Vertex3Vector verts0;
verts0.push_back(Vertex3::create(-s, 0., -s));
verts0.push_back(Vertex3::create(s, 0., -s));
verts0.push_back(Vertex3::create(s, 0., s));
verts0.push_back(Vertex3::create(-s, 0., s));
p0->addVertices(verts0);
p0->createEdges();
>>>
    return = {
        value = p0
        desc = Square polygon
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isTri
	shortDesc = Triangle check
	longDesc = Check whether the polygon is a triangle.
    impl = 
    return = {
        value = (getNumVertices() == 3)
        desc = Check result
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isQuad
	shortDesc = Quadrilateral check
	longDesc = Check whether the polygon is a quadrilateral.
    impl = 
    return = {
        value = (getNumVertices() == 4)
        desc = Check result
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = calculateUVCoefficients
	shortDesc = Calculate UV coefficients
	longDesc = <<<
Calculate the coefficients for the system of cubic equations needed to obtain the UV coordinates for the specified point. The result of the calculation is a 4x4 matrix, where each row contains the coefficients for one of the cubic equations used to calculate the point UV coordinates. The coefficients can be used to calculate either the U or V coordinate of the point, depending on the ordering of vertices. To calculate both the U and V coordinates, the function needs to be called twice with the appropriate permutation of vertex indices.

\sa getUV()
>>>
	param[] = {
	    type = const Ionflux::GeoUtils::Vertex3&
	    name = p
	    desc = point
	}
	param[] = {
	    type = Ionflux::GeoUtils::Matrix4&
	    name = target
	    desc = where to store the coefficients
	}
	param[] = {
	    type = Ionflux::ObjectBase::IntVector*
	    name = indices
	    desc = Vertex indices
	    default = 0
	}
	param[] = {
	    type = double
	    name = s
	    desc = scale factor for the coefficients
	    default = 1.
	}
    impl = <<<
if (!isQuad())
    throw GeoUtilsError(getErrorString(
        "Polygon is not a quadrilateral", "calculateUVCoefficients"));
Vertex3Vector vs;
if (indices != 0)
{
    if (indices->size() < 4)
        throw GeoUtilsError(getErrorString(
            "Not enough elements in index vector.", 
                "calculateUVCoefficients"));
    for (unsigned int i = 0; i < 4; i++)
    {
        Vertex3* v0 = Ionflux::ObjectBase::nullPointerCheck(
            getVertex((*indices)[i]), this, "calculateUVCoefficients", 
                "Vertex");
        vs.push_back(v0);
    }
} else 
{
    for (unsigned int i = 0; i < 4; i++)
    {
        Vertex3* v0 = Ionflux::ObjectBase::nullPointerCheck(
            getVertex(i), this, "calculateUVCoefficients", 
                "Vertex");
        vs.push_back(v0);
    }
}
Vector3 v1(vs[0]->getVector());
Vector3 v2(vs[3]->getVector());
Vector3 v3(vs[2]->getVector());
Vector3 v4(vs[1]->getVector());
/* Here the magic happens.
   (These equations come from parameterizing the lines through the 
   points on two opposite sides of the quadrilateral with u (or v, 
   respectively) and solving for the distance vector of p to that 
   line.)
 */
Vector3 a(v2 - v1);
Vector3 b(v3 - v2 - v4 + v1);
Vector3 d(v1 - v4);
Vector3 e(p.getVector() - v1);
Vector4 eta1((b * b) * d - (b * d) * b, 0.);
Vector4 eta2(2. * (a * b) * d + (b * b) * e - (b * d) * a 
    - (a * d) * b - (b * e) * b, 0.);
Vector4 eta3(2. * (a * b) * e + (a * a) * d - (a * d) * a 
    - (b * e) * a - (a * e) * b, 0.);
Vector4 eta4((a * a) * e - (a * e) * a, 0.);
target.setC0(eta1 * s);
target.setC1(eta2 * s);
target.setC2(eta3 * s);
target.setC3(eta4 * s);
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = getUV
	shortDesc = Get UV coordinates for vertex
	longDesc = <<<
Calculate the UV coordinates of the specified vertex relative to the (quadrilateral) polygon. The vertex order can be specified by the optional \c indices parameter.
>>>
	param[] = {
	    type = const Ionflux::GeoUtils::Vertex3&
	    name = p
	    desc = point
	}
	param[] = {
	    type = Ionflux::ObjectBase::IntVector*
	    name = indices
	    desc = Vertex indices
	    default = 0
	}
	param[] = {
	    type = Ionflux::GeoUtils::QuadInterpolationTypeID
	    name = interpolationType
	    desc = interpolation type
	    default = QUAD_INTERPOLATION_BILINEAR
	}
	param[] = {
	    type = double
	    name = s
	    desc = scale factor for the coefficients
	    default = 1.
	}
	param[] = {
	    type = double
	    name = t
	    desc = tolerance for comparisons
	    default = DEFAULT_TOLERANCE
	}
    impl = <<<
if (!isQuad())
    throw GeoUtilsError(getErrorString(
        "Polygon is not a quadrilateral", "getUV"));
Ionflux::ObjectBase::IntVector i0;
if (indices == 0)
{
    for (unsigned int i = 0; i < 4; i++)
        i0.push_back(i);
} else
    i0 = *indices;
if (i0.size() < 4)
    throw GeoUtilsError(getErrorString(
        "Not enough elements in index vector.", "getUV"));
// Calculate UV coefficients.
Matrix4 m0;
calculateUVCoefficients(p, m0, &i0, s);
// Solve equation systems.
double u = 0.;
double v = 0.;
Vector3 s11;
solveCubicEquation(m0.getElement(0, 0), m0.getElement(0, 1), 
    m0.getElement(0, 2), m0.getElement(0, 3), s11);
Vector3 s12;
solveCubicEquation(m0.getElement(1, 0), m0.getElement(1, 1), 
    m0.getElement(1, 2), m0.getElement(1, 3), s12);
Ionflux::ObjectBase::DoubleVector r0;
s11.findMatchingElements(s12, r0, &UV_RANGE, t);
if (r0.size() == 0)
{
    std::ostringstream status;
    status << "No solution found for U coordinates (p = (" 
        << p.getValueString() << "), quad = " << getValueString() 
        << ", s11 = (" << s11.getValueString() 
        << "), s12 = (" << s12.getValueString()
        << ")).";
    throw GeoUtilsError(getErrorString(status.str(), "getUV"));
}
u = r0[0];
if (interpolationType == QUAD_INTERPOLATION_SYMMETRIC)
{
    shift(i0, -1);
    Matrix4 m1;
    calculateUVCoefficients(p, m1, &i0, s);
    Vector3 s21;
    solveCubicEquation(m1.getElement(0, 0), m1.getElement(0, 1), 
        m1.getElement(0, 2), m1.getElement(0, 3), s21);
    Vector3 s22;
    solveCubicEquation(m1.getElement(1, 0), m1.getElement(1, 1), 
        m1.getElement(1, 2), m1.getElement(1, 3), s22);
    Ionflux::ObjectBase::DoubleVector r1;
    s21.findMatchingElements(s22, r1, &UV_RANGE, t);
    if (r0.size() == 0)
    {
        std::ostringstream status;
        status << "No solution found for V coordinates (p = (" 
            << p.getValueString() << "), quad = " << getValueString() 
            << "), s21 = (" << s21.getValueString() 
            << "), s22 = (" << s22.getValueString()
            << ")).";
        throw GeoUtilsError(getErrorString(status.str(), "getUV"));
    }
    v = r1[0];
} else
if (interpolationType == QUAD_INTERPOLATION_BILINEAR)
{
    Vertex3Vector vs;
    for (unsigned int i = 0; i < 4; i++)
    {
        Vertex3* v0 = Ionflux::ObjectBase::nullPointerCheck(
            getVertex(i0[i]), this, "getUV", "Vertex");
        vs.push_back(v0);
    }
    Vector3 v1(vs[0]->getVector());
    Vector3 v2(vs[1]->getVector());
    Vector3 v3(vs[2]->getVector());
    Vector3 v4(vs[3]->getVector());
    Vector3 w1(v1 + u * (v2 - v1));
    Vector3 w2(v4 + u * (v3 - v4));
    /* <---- DEBUG ----- //
    std::cerr << "[Polygon3::getUV] DEBUG: "
        "w1 = (" << w1.getValueString() << "), w2 = (" 
        << w2.getValueString() << ")" << std::endl;
    // ----- DEBUG ----> */
    Vector3 vp(p.getVector());
    v = (vp - w1).norm() / (w2 - w1).norm();
} else
{
    std::ostringstream status;
    status << "Unknown interpolation type: " << interpolationType;
    throw GeoUtilsError(getErrorString(status.str(), "getUV"));
}
>>>
    return = {
        value = Vector2(u, v)
        desc = UV coordinates of point
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vertex3
	name = getUVVertex
	shortDesc = Get a vertex from UV coordinates
	longDesc = <<<
Get a vertex from the (quadrilateral) polygon by evaluating the specified UV coordinates. The vertex order can be specified by the optional \c indices parameter.
>>>
	param[] = {
	    type = const Ionflux::GeoUtils::Vector2&
	    name = uv
	    desc = UV coordinates
	}
	param[] = {
	    type = Ionflux::ObjectBase::IntVector*
	    name = indices
	    desc = Vertex indices
	    default = 0
	}
	param[] = {
	    type = Ionflux::GeoUtils::QuadInterpolationTypeID
	    name = interpolationType
	    desc = interpolation type
	    default = QUAD_INTERPOLATION_BILINEAR
	}
    impl = <<<
if (!isQuad())
    throw GeoUtilsError(getErrorString(
        "Polygon is not a quadrilateral", "getUVVertex"));
Ionflux::ObjectBase::IntVector i0;
if (indices == 0)
{
    for (unsigned int i = 0; i < 4; i++)
        i0.push_back(i);
} else
    i0 = *indices;
if (i0.size() < 4)
    throw GeoUtilsError(getErrorString(
        "Not enough elements in index vector.", "getUVVertex"));
Vertex3Vector vs;
for (unsigned int i = 0; i < 4; i++)
{
    Vertex3* v0 = Ionflux::ObjectBase::nullPointerCheck(
        getVertex(i0[i]), this, "getUVVertex", "Vertex");
    vs.push_back(v0);
}
double u = uv[0];
double v = uv[1];
Vector3 p;
Vector3 v1(vs[0]->getVector());
Vector3 v2(vs[1]->getVector());
Vector3 v3(vs[2]->getVector());
Vector3 v4(vs[3]->getVector());
Vector3 w1(v1 + u * (v2 - v1));
Vector3 w2(v4 + u * (v3 - v4));
if (interpolationType == QUAD_INTERPOLATION_BILINEAR)
{
    p = w1 + v * (w2 - w1);
} else
if (interpolationType == QUAD_INTERPOLATION_SYMMETRIC)
{
    Vector3 w3(v1 + v * (v4 - v1));
    Vector3 w4(v2 + v * (v3 - v2));
    Line3 l0(w1, (w2 - w1).normalize());
    Line3 l1(w3, (w4 - w3).normalize());
    if (!l0.intersect(l1, p))
    {
        std::ostringstream status;
        status << "Interpolation lines do not intersect (uv = (" 
            << uv.getValueString() << "), quad = " << getValueString() 
            << ").";
        throw GeoUtilsError(getErrorString(status.str(), "getUVVertex"));
    }
} else
{
    std::ostringstream status;
    status << "Unknown interpolation type: " << interpolationType;
    throw GeoUtilsError(getErrorString(status.str(), "getUVVertex"));
}
>>>
    return = {
        value = Vertex3(p)
        desc = UV vertex
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = createSpline
	shortDesc = Create Bezier spline
	longDesc = Create a Bezier spline that interpolates the vertices of the polygon. The \c smoothness parameter can be used to determine how closely the curve will follow the original polygon lines. For each vertex of the polygon, \c smoothness specifies the distance of the inner control points of the Bezier curve segments originating at that vertex as a fraction of the average edge length at that vertex.
	param[] = {
	    type = Ionflux::Mapping::BezierSpline&
	    name = target
	    desc = Where to store the Bezier spline data
	}
	param[] = {
	    type = double
	    name = smoothness
	    desc = Smoothness parameter
	    default = 0.2
	}
    impl = <<<
unsigned int numVerts0 = getNumVertices();
if (numVerts0 < 2)
    return;
unsigned int numEdges0 = numVerts0 - 1;
target.clearSegments();
// Create Bezier curve segments for the polygon lines.
for (unsigned int i = 0; i < numEdges0; i++)
{
    Vertex3* v0 = Ionflux::ObjectBase::nullPointerCheck(
        getVertex(i), this, "createSpline", "Vertex (0)");
    Vertex3* v1 = Ionflux::ObjectBase::nullPointerCheck(
        getVertex(i + 1), this, "createSpline", "Vertex (1)");
    Ionflux::Mapping::Point p0;
    Ionflux::Mapping::Point p1;
    Ionflux::Mapping::Point p2;
    Ionflux::Mapping::Point p3;
    calculateLineBezierControlPoints(*v0, *v1, p0, p1, p2, p3, 
        smoothness);
    Ionflux::Mapping::BezierCurve* c0 = 
        Ionflux::Mapping::BezierCurve::create(p0, p1, p2, p3);
    target.addSegment(c0);
}
if ((numEdges0 == 1) 
    || (smoothness == 0.))
    return;
// Displace the control points to create a smooth curve.
Ionflux::Mapping::BezierCurve* c0 = 0;
Ionflux::Mapping::BezierCurve* c1 = 0;
Ionflux::Mapping::Point* p0 = 0;
Ionflux::Mapping::Point* p1 = 0;
Ionflux::Mapping::Point* p2 = 0;
Ionflux::Mapping::Point* p3 = 0;
Ionflux::Mapping::Point* p4 = 0;
Vertex3 v0;
Vertex3 v1;
Vertex3 v2;
for (unsigned int i = 0; i < numEdges0 - 1; i++)
{
    /* For each inner vertex, the control points are placed on the 
       tangent through that vertex in the direction of the line 
       connecting the neighbouring vertices. */
    c0 = target.getSegment(i);
    c1 = target.getSegment(i + 1);
    p0 = c0->getPoint(0);
    p1 = c0->getPoint(2);
    p2 = c0->getPoint(3);
    p3 = c1->getPoint(1);
    p4 = c1->getPoint(3);
    v0.setCoords(*p0);
    v1.setCoords(*p2);
    v2.setCoords(*p4);
    calculateInnerBezierControlPoints(v0, v1, v2, *p1, *p2, *p3, 
        smoothness);
}
// Displace the outer control points.
c0 = target.getSegment(0);
p0 = c0->getPoint(0);
p1 = c0->getPoint(1);
p2 = c0->getPoint(2);
p3 = c0->getPoint(3);
calculateOuterBezierControlPoint(p0, p1, p2, p3, smoothness);
c0 = target.getSegment(numEdges0 - 1);
p0 = c0->getPoint(0);
p1 = c0->getPoint(1);
p2 = c0->getPoint(2);
p3 = c0->getPoint(3);
calculateOuterBezierControlPoint(p3, p2, p1, p0, smoothness);
>>>
}

# static member functions
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Polygon3*
	name = circle
	shortDesc = Create polygon: circle
	longDesc = Create a circle polygon in the XZ plane.
	param[] = {
	    type = unsigned int
	    name = resolution
	    desc = Resolution
	    default = 20
	}
    impl = <<<
Polygon3* p0 = Polygon3::create();
double s = 0.5;
Vertex3Vector verts0;
for (unsigned int i = 0; i <= resolution; i++)
{
    Vertex3* v0 = Vertex3::create(s, 0., 0.);
    v0->rotate(2. * M_PI / resolution * i, AXIS_Y);
    verts0.push_back(v0);
}
p0->addVertices(verts0);
p0->createEdges();
>>>
    return = {
        value = p0
        desc = Square polygon
    }
}

# Pure virtual member functions.

# operations

# Global functions.

