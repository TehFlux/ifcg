# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009-2013 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Polygon3.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/Vertex3.hpp"'
        '"geoutils/Vertex3Set.hpp"'
        '"geoutils/Edge.hpp"'
        '"geoutils/Vector3.hpp"'
        '"geoutils/Matrix3.hpp"'
        '"geoutils/Plane3.hpp"'
        '"geoutils/Polygon2.hpp"'
        '"geoutils/Matrix4.hpp"'
        '"geoutils/Range3.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"ifobject/objectutils.hpp"'
#        '"geoutils/Clock.hpp"'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/utils.hpp"'
    }
}

# forward declarations
forward = {
    'class Polygon3'
}

# undefine macros

## typedefs
#typedef = {
#}

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Polygon3
	shortDesc = Polygon (3D)
	title = Polygon (3D)
	longDesc = A polygon in three-dimensional space.
	group.name = geoutils
	base = {
		## base classes from the IFObject hierarchy
		#ifobject[] = {
		#	name = IFObject
		#}
        # other base classes
        other[] = {
			name = Ionflux::GeoUtils::TransformableObject
            include = geoutils/TransformableObject.hpp
		}
	}
    features = {
        'copy'
        'logmessage'
        'classinfo'
        'upcast'
        'create'
    }
    create.allocationError = GeoUtilsError("Could not allocate object.")
}

# Member variables.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    type = Ionflux::GeoUtils::Vertex3Set*
    setFromType = Ionflux::GeoUtils::Vertex3Set*
    name = vertexSource
    desc = Vertex source
    managed = true
}
property.protected[] = {
    style = vector
    name = vertices
    desc = Vertex vector
    element = {
        type = Ionflux::GeoUtils::Vertex3*
        name = Vertex
        plural = Vertices
        #managed = true
    }
    proxy = true
    proxy.target = vertexSource
    proxy.nullError = GeoUtilsError("Vertex source not set.")
}
property.protected[] = {
    style = vector
    name = edges
    desc = Edge vector
    element = {
        type = Ionflux::GeoUtils::Edge*
        name = Edge
        managed = true
    }
}

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = vertexSource
        value = 0
    }
    impl = setVertexSource(Vertex3Set::create());
}
constructor.public[] = {
    initializer[] = {
        name = vertexSource
        value = 0
    }
    param[] = {
        name = initVertices
        type = Ionflux::GeoUtils::Vertex3Vector*
        desc = Vertices
    }
    param[] = {
        name = initEdges
        type = Ionflux::GeoUtils::EdgeVector*
        desc = Edges
        default = 0
    }
    impl = setVertexSource(Vertex3Set::create());\
if (initVertices != 0)\
    addVertices(*initVertices);\
if (initEdges != 0)\
    addEdges(*initEdges);
}
constructor.public[] = {
    initializer[] = {
        name = vertexSource
        value = 0
    }
    param[] = {
        name = initVertexSource
        type = Ionflux::GeoUtils::Vertex3Set*
        desc = Vertex source
    }
    param[] = {
        name = initEdges
        type = Ionflux::GeoUtils::EdgeVector*
        desc = Edges
        default = 0
    }
    impl = if (initVertexSource)\
    setVertexSource(initVertexSource);\
else\
    setVertexSource(Vertex3Set::create());\
if (initEdges != 0)\
    addEdges(*initEdges);
}
constructor.public[] = {
    initializer[] = {
        name = vertexSource
        value = 0
    }
    param[] = {
        name = v0
        type = const Ionflux::GeoUtils::Vertex3*
        desc = Vertex (0)
    }
    param[] = {
        name = v1
        type = const Ionflux::GeoUtils::Vertex3*
        desc = Vertex (1)
    }
    param[] = {
        name = v2
        type = const Ionflux::GeoUtils::Vertex3*
        desc = Vertex (2)
    }
    param[] = {
        name = v3
        type = const Ionflux::GeoUtils::Vertex3*
        desc = Vertex (3)
        default = 0
    }
    impl = setVertexSource(Vertex3Set::create());\
Vertex3* vt0 = 0;\
if (v0 != 0)\
\{\
    vt0 = Vertex3::create();\
    *vt0 = *v0;\
    addVertex(vt0);\
\}\
if (v1 != 0)\
\{\
    vt0 = Vertex3::create();\
    *vt0 = *v1;\
    addVertex(vt0);\
\}\
if (v2 != 0)\
\{\
    vt0 = Vertex3::create();\
    *vt0 = *v2;\
    addVertex(vt0);\
\}\
if (v3 != 0)\
\{\
    vt0 = Vertex3::create();\
    *vt0 = *v3;\
    addVertex(vt0);\
\}\
createEdges();
}

# Destructor.
#destructor.impl = 

# Public static constants.
constant.public[] = {
    type = Ionflux::GeoUtils::Range
    name = UV_RANGE
    desc = Point UV coordinate range
    value = Ionflux::GeoUtils::Range(0., 1.)
}

# Protected static constants.

# Protected member functions.
function.protected[] = {
	spec = virtual
	type = void
	name = recalculateBounds
	shortDesc = Recalculate bounds
	longDesc = Recalculate the bounds for the polygon.
	impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source not set.");\
TransformableObject::recalculateBounds();\
if (!useTransform && !useVI)\
\{\
    *boundsCache = vertexSource->getBounds();\
    return;\
\}\
// Adjust for transformation.\
Polygon3* p0 = copy();\
p0->applyTransform();\
if (p0->useTransform)\
    throw GeoUtilsError("Transform matrix still in use after "\
        "applying transformations.");\
*boundsCache = p0->getBounds();\
delete p0;
}

# Public member functions.
function.copy.impl = TransformableObject::operator=(other);\
setVertexSource(other.vertexSource);\
EdgeVector e0;\
for (EdgeVector::const_iterator i = other.edges.begin(); \
    i != other.edges.end(); i++)\
\{\
    Edge* et0 = Edge::create();\
    *et0 = *(*i);\
    e0.push_back(et0);\
\}\
clearEdges();\
addEdges(e0);
function.public[] = {
	spec = virtual
	type = void
	name = copyVertices
	shortDesc = Copy vertices
	longDesc = Create a new vertex set with copies of the current vertices. This makes the polygon the (current) single owner of its vertices.
    impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source not set.");\
setVertexSource(&(vertexSource->duplicate()));
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vertex3*
	name = addVertex
	shortDesc = Create vertex
	longDesc = Create a new vertex which is managed by the vertex source.
    impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source not set.");
    return = {
        value = vertexSource->addVertex()
        desc = New vertex
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = addVertices
	shortDesc = Add vertices
	longDesc = Add vertices from a vertex vector.
	param[] = {
		type = Ionflux::GeoUtils::Vertex3Vector&
		name = newVerts
		desc = Vertices
	}
    impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source not set.");\
for (Vertex3Vector::iterator i = newVerts.begin(); \
    i != newVerts.end(); i++)\
    vertexSource->addVertex(*i);
}
function.public[] = {
	spec = virtual
	type = void
	name = addVertices
	shortDesc = Add vertices
	longDesc = Add vertices from a vertex set.
	param[] = {
		type = Ionflux::GeoUtils::Vertex3Set&
		name = newVerts
		desc = Vertices
	}
    impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source not set.");\
for (unsigned int i = 0; i < newVerts.getNumVertices(); i++)\
    vertexSource->addVertex(newVerts.getVertex(i));
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Edge*
	name = addEdge
	shortDesc = Add edge
	longDesc = Add a new edges which will be managed by this polygon.
    impl = Edge* e0 = new Edge();\
if (e0 == 0)\
    throw GeoUtilsError("Could not allocate object.");\
addEdge(e0);
    return = {
        value = e0
        desc = New edge
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = addEdges
	shortDesc = Add edges
	longDesc = Add edges from a vector of edges.
	param[] = {
		type = Ionflux::GeoUtils::EdgeVector&
		name = newEdges
		desc = Edge vector
	}
    impl = if (newEdges.size() == 0)\
    return;\
for (Ionflux::GeoUtils::EdgeVector::iterator i = newEdges.begin(); \
    i != newEdges.end(); i++)\
    addEdge(*i);
}
function.public[] = {
	spec = virtual
	type = int
	name = createEdges
	shortDesc = Create edges
	longDesc = Takes two subsequent vertices from the list to create edges.
    impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source not set.");\
clearEdges();\
unsigned int numVerts = getNumVertices();\
if (numVerts < 2)\
    return 0;\
Edge* e0 = 0;\
for (unsigned int i = 1; i < numVerts; i++)\
\{\
    e0 = Edge::create();\
    e0->setV0(i - 1);\
    e0->setV1(i);\
    addEdge(e0);\
\}\
if (numVerts >= 3)\
\{\
    e0 = Edge::create();\
    e0->setV0(numVerts - 1);\
    e0->setV1(0);\
    addEdge(e0);\
\}
    return = {
        value = edges.size()
        desc = The number of edges created
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Plane3
	name = getPlane
    const = true
	shortDesc = Get plane spanned by vertices
	longDesc = Get the plane spanned by the specified three vertex indices. If the vertices parameter is not specified, the first two and the last vertices are used.
	param[] = {
		type = int
		name = v0
		desc = First vertex index
        default = 0
	}
	param[] = {
		type = int
		name = v1
		desc = Second vertex index
        default = 1
	}
	param[] = {
		type = int
		name = v2
		desc = Third vertex index
        default = -1
	}
    impl = unsigned int numVerts = getNumVertices();\
if (v0 < 0)\
    v0 = numVerts + v0;\
if (v1 < 0)\
    v1 = numVerts + v1;\
if (v2 < 0)\
    v2 = numVerts + v2;\
if ((v0 < 0) || (static_cast<unsigned int>(v0) >= numVerts))\
\{\
    std::ostringstream status;\
    status << "[Polygon3::getPlane] "\
        "Vertex index v0 out of range (numVerts = " << numVerts \
        << ", v0 = " << v0 << ").";\
    throw GeoUtilsError(status.str());\
\}\
if ((v1 < 0) || (static_cast<unsigned int>(v1) >= numVerts))\
\{\
    std::ostringstream status;\
    status << "[Polygon3::getPlane] "\
        "Vertex index v1 out of range (numVerts = " << numVerts \
        << ", v1 = " << v1 << ").";\
    throw GeoUtilsError(status.str());\
\}\
if ((v2 < 0) || (static_cast<unsigned int>(v2) >= numVerts))\
\{\
    std::ostringstream status;\
    status << "[Polygon3::getPlane] "\
        "Vertex index v2 out of range (numVerts = " << numVerts \
        << ", v2 = " << v2 << ").";\
    throw GeoUtilsError(status.str());\
\}\
Vector3 a = getVertex(v0)->getVector();\
Vector3 b = getVertex(v1)->getVector();\
Vector3 c = getVertex(v2)->getVector();
    return = {
        value = Plane3(a, b - a, c - a);
        desc = Plane spanned by the vertices
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object.
	impl = <<<
ostringstream status;
status << "verts: [";
bool e0 = true;
for (unsigned int i = 0; i < getNumVertices(); i++)
{
    Vertex3* v0 = getVertex(i);
    if (!e0)
        status << ", ";
    else
        e0 = false;
    status << "(" << v0->getValueString() << ")";
}
status << "]";
if (edges.size() > 0)
{
    status << " edges: [";
    e0 = true;
    for (EdgeVector::const_iterator j = edges.begin(); 
        j != edges.end(); j++)
    {
        if (!e0)
            status << ", ";
        else
            e0 = false;
        status << "(" << (*j)->getValueString() << ")";
    }
    status << "]";
}
if (!useTransform && !useVI)
    return status.str();
status << "; " << TransformableObject::getValueString();
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getSVG
	shortDesc = Get SVG representation
	longDesc = Get a Scalable Vector Graphics (XML) representation of the polygon. The polygon will be projected orthogonally to the appropriate coordinate plane along the specified axis. The type of SVG element that is created to represent the polygon depends on the \c shapeType parameter. If the shape type is \c SHAPE_TYPE_PATH and \c closePath is \c true (the default), the path will be closed.
    param[] = {
        type = const std::string&
        name = attrs
        desc = Element attributes
        default = SVG_DEFAULT_POLY_STYLE
    }
    param[] = {
        type = const std::string&
        name = elementID
        desc = Element ID
        default = "polygon"
    }
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = axis
        desc = Projection axis
        default = Ionflux::GeoUtils::AXIS_Y
    }
    param[] = {
        type = Ionflux::GeoUtils::SVGShapeType
        name = shapeType
        desc = Shape type
        default = Ionflux::GeoUtils::DEFAULT_SHAPE_TYPE
    }
    param[] = {
        type = bool
        name = closePath
        desc = Close path
        default = true
    }
	impl = ostringstream svg;\
AxisID oa[2];\
if (axis == AXIS_Y)\
\{\
    oa[0] = AXIS_X;\
    oa[1] = AXIS_Z;\
\} else\
if (axis == AXIS_X)\
\{\
    oa[0] = AXIS_Y;\
    oa[1] = AXIS_Z;\
\} else\
if (axis == AXIS_Z)\
\{\
    oa[0] = AXIS_X;\
    oa[1] = AXIS_Y;\
\} else\
\{\
    svg << "Invalid axis: " << axis;\
    throw GeoUtilsError(svg.str());\
\}\
if (shapeType == SHAPE_TYPE_POLYGON)\
    svg << "<polygon";\
else\
if (shapeType == SHAPE_TYPE_PATH)\
    svg << "<path";\
else\
\{\
    std::ostringstream message;\
    message << "Unknown shape type: " << shapeType;\
    throw GeoUtilsError(message.str());\
\}\
if (elementID.size() > 0)\
    svg << " id=\"" << elementID << "\"";\
if (attrs.size() > 0)\
    svg << " " << attrs;\
if (shapeType == SHAPE_TYPE_POLYGON)\
    svg << " points=\"";\
else\
    svg << " d=\"";\
bool s0 = true;\
/* <---- DEBUG ----- //\
ostringstream message;\
message << "Before applyTransform(): numVertices = " << getNumVertices();\
log(IFLogMessage(message.str(), VL_DEBUG, this, "getSVG"));\
// <---- DEBUG ----- */\
applyTransform();\
/* <---- DEBUG ----- //\
message.str("");\
message << "After applyTransform(): numVertices = " << getNumVertices();\
log(IFLogMessage(message.str(), VL_DEBUG, this, "getSVG"));\
// <---- DEBUG ----- */\
for (unsigned int i = 0; i < getNumVertices(); i++)\
\{\
    Vertex3* v0 = getVertex(i);\
    if (!s0)\
    \{\
        svg << " ";\
        if (shapeType == SHAPE_TYPE_PATH)\
            svg << "L ";\
    \} else\
    \{\
        if (shapeType == SHAPE_TYPE_PATH)\
            svg << "M ";\
        s0 = false;\
    \}\
    svg << (*v0)[oa[0]] << "," << (*v0)[oa[1]];\
\}\
if (closePath \
    && (shapeType == SHAPE_TYPE_PATH))\
    svg << " z";\
svg << "\" />";
    return = {
        value = svg.str()
        desc = SVG representation
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getSVG
	shortDesc = Get SVG representation
	longDesc = Get a Scalable Vector Graphics (XML) representation of the polygon. The polygon will be projected orthogonally to the appropriate coordinate plane along the specified axis. The type of SVG element that is created to represent the polygon depends on the \c shapeType parameter. If the shape type is \c SHAPE_TYPE_PATH and \c closePath is \c true (the default), the path will be closed.
    param[] = {
        type = const Ionflux::GeoUtils::SVGShapeStyle&
        name = style
        desc = Shape style
    }
    param[] = {
        type = const std::string&
        name = elementID
        desc = Element ID
        default = "polygon"
    }
    param[] = {
        type = Ionflux::GeoUtils::AxisID
        name = axis
        desc = Projection axis
        default = Ionflux::GeoUtils::AXIS_Y
    }
    param[] = {
        type = Ionflux::GeoUtils::SVGShapeType
        name = shapeType
        desc = Shape type
        default = Ionflux::GeoUtils::DEFAULT_SHAPE_TYPE
    }
    param[] = {
        type = bool
        name = closePath
        desc = Close path
        default = true
    }
	impl = std::string a0 = getSVGPolygonStyle(style);
    return = {
        value = getSVG(a0, elementID, axis, shapeType, closePath)
        desc = SVG representation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getBarycenter
	shortDesc = Get barycenter
	longDesc = Get the barycenter vector for the polygon.
	impl = if (vertexSource == 0)\
    throw GeoUtilsError("Vertex source not set.");\
if (!useTransform && !useVI)\
    return vertexSource->getBarycenter();\
// Adjust for transformation.\
Vertex3 v0(vertexSource->getBarycenter());\
if (useTransform)\
    v0.transform(transformMatrix);\
if (useVI)\
    v0.transformVI(viewMatrix, &imageMatrix);
    return = {
        value = v0.getVector()
        desc = Barycenter vector
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = applyTransform
	shortDesc = Apply transformations
	longDesc = Apply transformations that have been accumulated in the transformation matrices.
	param[] = {
	    type = bool
	    name = recursive
	    desc = Apply transformations recursively
	    default = false
	}
    impl = <<<
if (!useTransform && !useVI)
{
    if (recursive)
        vertexSource->applyTransform(recursive);
    return;
}
copyVertices();
if (useTransform)
{
    vertexSource->transform(transformMatrix);
    vertexSource->applyTransform(recursive);
    transformMatrix = Matrix4::UNIT;
    useTransform = false;
}
if (useVI)
{
    vertexSource->transformVI(viewMatrix, &imageMatrix);
    vertexSource->applyTransform(recursive);
    viewMatrix = Matrix4::UNIT;
    imageMatrix = Matrix4::UNIT;
    useVI = false;
}
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = scale
	shortDesc = Scale
	longDesc = Scale the object by the specified scale factors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = s
		desc = Vector of scale factors
	}
    impl = TransformableObject::scale(s);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = translate
	shortDesc = Translate
	longDesc = Translate the object by the specified vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = t
		desc = Translation vector
	}
    impl = TransformableObject::translate(t);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = rotate
	shortDesc = Rotate
	longDesc = Rotate the object by the specified angle around the specified axis.
	param[] = {
		type = double
		name = phi
		desc = Angle
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = axis
		desc = Axis
        default = Ionflux::GeoUtils::AXIS_Z
	}
    impl = TransformableObject::rotate(phi, axis);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = normalize
	shortDesc = Normalize
	longDesc = Normalize the object, i.e. scale to unit size.
    impl = TransformableObject::normalize();
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = center
	shortDesc = Center
	longDesc = Center the object using the specified method and origin vector.
	param[] = {
		type = Ionflux::GeoUtils::CenteringMethod
		name = method
		desc = Centering method
        default = Ionflux::GeoUtils::CENTER_BARYCENTER
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector3*
		name = origin
		desc = Origin or offset vector
        default = 0
	}
    impl = TransformableObject::center(method, origin);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix4&
		name = matrix
		desc = Transformation matrix
	}
    impl = TransformableObject::transform(matrix);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = matrix
		desc = Transformation matrix
	}
    impl = TransformableObject::transform(matrix);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3&
	name = duplicate
	shortDesc = Duplicate
	longDesc = Create an exact duplicate of the object. The duplicate is a new object which must be managed by the caller.
    impl = 
    return = {
        value = *copy()
        desc = The duplicated object
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isPlanar
	shortDesc = Planarity check
	longDesc = Check whether the polygon is planar.
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = Plane3 pl0 = getPlane();\
for (unsigned int i = 0; i < getNumVertices(); i++)\
\{\
    double d0 = getVertex(i)->distanceToPlane(pl0);\
    if (!eq(d0, 0., t))\
        return false;\
\}
    return = {
        value = true
        desc = Check result
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getPolygon2
	shortDesc = Get polygon (2D)
	longDesc = Create a 2D polygon from the 3D polygon. The vertex coordinates are projected along the Z axis.
	param[] = {
	    type = Ionflux::GeoUtils::Polygon2&
	    name = target
	    desc = target polygon
	}
    impl = for (unsigned int i = 0; i < getNumVertices(); i++)\
\{\
    Vertex3* v0 = getVertex(i);\
    target.addVertex(new Vertex2(v0->getX(), v0->getY()));\
\}\
for (unsigned int i = 0; i < getNumEdges(); i++)\
    target.addEdge(new Edge(*getEdge(i)));\
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Polygon3*
	name = square
	shortDesc = Create polygon: square
	longDesc = Create a square polygon.
    impl = Polygon3* p0 = Polygon3::create();\
double s = 0.5;\
Vertex3Vector verts0;\
verts0.push_back(Vertex3::create(-s, 0., -s));\
verts0.push_back(Vertex3::create(s, 0., -s));\
verts0.push_back(Vertex3::create(s, 0., s));\
verts0.push_back(Vertex3::create(-s, 0., s));\
p0->addVertices(verts0);\
p0->createEdges();
    return = {
        value = p0
        desc = Square polygon
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isTri
	shortDesc = Triangle check
	longDesc = Check whether the polygon is a triangle.
    impl = 
    return = {
        value = (getNumVertices() == 3)
        desc = Check result
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isQuad
	shortDesc = Quadrilateral check
	longDesc = Check whether the polygon is a quadrilateral.
    impl = 
    return = {
        value = (getNumVertices() == 4)
        desc = Check result
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = calculateUVCoefficients
	shortDesc = Calculate UV coefficients
	longDesc = <<<
Calculate the coefficients for the system of cubic equations needed to obtain the UV coordinates for the specified point. The result of the calculation is a 4x4 matrix, where each row contains the coefficients for one of the cubic equations used to calculate the point UV coordinates. The coefficients can be used to calculate either the U or V coordinate of the point, depending on the ordering of vertices. To calculate both the U and V coordinates, the function needs to be called twice with the appropriate permutation of vertex indices.

\sa getUV()
>>>
	param[] = {
	    type = const Ionflux::GeoUtils::Vertex3&
	    name = p
	    desc = point
	}
	param[] = {
	    type = Ionflux::GeoUtils::Matrix4&
	    name = target
	    desc = where to store the coefficients
	}
	param[] = {
	    type = Ionflux::ObjectBase::IntVector*
	    name = indices
	    desc = Vertex indices
	    default = 0
	}
	param[] = {
	    type = double
	    name = s
	    desc = scale factor for the coefficients
	    default = 1.
	}
    impl = <<<
if (!isQuad())
    throw GeoUtilsError(getErrorString(
        "Polygon is not a quadrilateral", "calculateUVCoefficients"));
Vertex3Vector vs;
if (indices != 0)
{
    if (indices->size() < 4)
        throw GeoUtilsError(getErrorString(
            "Not enough elements in index vector.", 
                "calculateUVCoefficients"));
    for (unsigned int i = 0; i < 4; i++)
    {
        Vertex3* v0 = Ionflux::ObjectBase::nullPointerCheck(
            getVertex((*indices)[i]), this, "calculateUVCoefficients", 
                "Vertex (0)");
        vs.push_back(v0);
    }
} else 
{
    for (unsigned int i = 0; i < 4; i++)
    {
        Vertex3* v0 = Ionflux::ObjectBase::nullPointerCheck(
            getVertex(i), this, "calculateUVCoefficients", 
                "Vertex (0)");
        vs.push_back(v0);
    }
}
Vector3 v1(vs[0]->getVector());
Vector3 v2(vs[1]->getVector());
Vector3 v3(vs[2]->getVector());
Vector3 v4(vs[3]->getVector());
/* Here the magic happens.
   (These equations come from parameterizing the lines through the 
   points on two opposite sides of the quadrilateral with u (or v, 
   respectively) and solving for the distance vector of p to that 
   line.)
 */
Vector3 a(v2 - v1);
Vector3 b(v3 - v2 - v4 + v1);
Vector3 d(v1 - v4);
Vector3 e(p.getVector() - v1);
Vector4 eta1((b * b) * d - (b * d) * b, 0.);
Vector4 eta2(2. * (a * b) * d + (b * b) * e - (b * d) * a 
    - (a * d) * b - (b * e) * b, 0.);
Vector4 eta3(2. * (a * b) * e + (a * a) * d - (a * d) * a 
    - (b * e) * a - (a * e) * b, 0.);
Vector4 eta4((a * a) * e - (a * e) * a, 0.);
target.setC0(eta1 * s);
target.setC1(eta2 * s);
target.setC2(eta3 * s);
target.setC3(eta4 * s);
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = getUV
	shortDesc = getUV
	longDesc = <<<
Calculate the UV coordinates of the specified point relative to the (quadrilateral) polygon. The vertex order can be specified by the optional \c indices parameter.
>>>
	param[] = {
	    type = const Ionflux::GeoUtils::Vertex3&
	    name = p
	    desc = point
	}
	param[] = {
	    type = Ionflux::ObjectBase::IntVector*
	    name = indices
	    desc = Vertex indices
	    default = 0
	}
	param[] = {
	    type = double
	    name = s
	    desc = scale factor for the coefficients
	    default = 1.
	}
	param[] = {
	    type = double
	    name = t
	    desc = tolerance for comparisons
	    default = DEFAULT_TOLERANCE
	}
    impl = <<<
if (!isQuad())
    throw GeoUtilsError(getErrorString(
        "Polygon is not a quadrilateral", "getUV"));
Ionflux::ObjectBase::IntVector i0;
if (indices == 0)
{
    for (unsigned int i = 0; i < 4; i++)
        i0.push_back(i);
} else
    i0 = *indices;
if (i0.size() < 4)
    throw GeoUtilsError(getErrorString(
        "Not enough elements in index vector.", "getUV"));
// Calculate UV coefficients.
Matrix4 m0;
calculateUVCoefficients(p, m0, &i0, s);
shift(i0, -1);
Matrix4 m1;
calculateUVCoefficients(p, m1, &i0, s);
// Solve equations.
Vector3 s11;
solveCubicEquation(m0.getElement(0, 0), m0.getElement(0, 1), 
    m0.getElement(0, 2), m0.getElement(0, 3), s11);
Vector3 s12;
solveCubicEquation(m0.getElement(1, 0), m0.getElement(1, 1), 
    m0.getElement(1, 2), m0.getElement(1, 3), s12);
Vector3 s21;
solveCubicEquation(m1.getElement(0, 0), m1.getElement(0, 1), 
    m1.getElement(0, 2), m1.getElement(0, 3), s21);
Vector3 s22;
solveCubicEquation(m1.getElement(1, 0), m1.getElement(1, 1), 
    m1.getElement(1, 2), m1.getElement(1, 3), s22);
// Determine solutions of the equation systems.
Ionflux::ObjectBase::DoubleVector r0;
s11.findMatchingElements(s12, r0, &UV_RANGE, t);
Ionflux::ObjectBase::DoubleVector r1;
s21.findMatchingElements(s22, r1, &UV_RANGE, t);
if ((r0.size() == 0) 
    || (r1.size() == 0))
{
    std::ostringstream status;
    status << "No solution found for UV coordinates (p = (" 
        << p.getValueString() << "), quad = " << getValueString() 
        << ", s11 = (" << s11.getValueString() 
        << "), s12 = (" << s12.getValueString()
        << "), s21 = (" << s21.getValueString() 
        << "), s22 = (" << s22.getValueString()
        << ")).";
    throw GeoUtilsError(getErrorString(status.str(), "getUV"));
}
Vector2 result(r0[0], r1[0]);
>>>
    return = {
        value = result
        desc = UV coordinates of point
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Polygon3*
	name = circle
	shortDesc = Create polygon: circle
	longDesc = Create a circle polygon.
	param[] = {
	    type = unsigned int
	    name = resolution
	    desc = Resolution
	    default = 20
	}
    impl = Polygon3* p0 = Polygon3::create();\
double s = 0.5;\
Vertex3Vector verts0;\
for (unsigned int i = 0; i <= resolution; i++)\
\{\
    Vertex3* v0 = Vertex3::create(s, 0., 0.);\
    v0->rotate(2. * M_PI / resolution * i, AXIS_Y);\
    verts0.push_back(v0);\
\}\
p0->addVertices(verts0);\
p0->createEdges();
    return = {
        value = p0
        desc = Square polygon
    }
}

# Pure virtual member functions.

# operations

# Global functions.

