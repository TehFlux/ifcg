# ===================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009-2014 Jörn P. Meier
# mail@ionflux.org
# -------------------------------------------------------------------
# FBXNode.conf              Class configuration.
# ===================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# 
# ===================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/constants.hpp"'
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/fbxtypes.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '<fbxsdk.h>'
        '"ifobject/utils.hpp"'
        '"ifobject/objectutils.hpp"'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/Matrix4.hpp"'
        '"geoutils/Mesh.hpp"'
        '"geoutils/Face.hpp"'
        '"geoutils/Vertex3.hpp"'
        '"geoutils/fbxutils.hpp"'
        '"geoutils/fbxutils_private.hpp"'
    }
}

# forward declarations
forward = {
    'class Matrix4'
    'class Mesh'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = FBXNode
	shortDesc = FBX Node
	title = FBX Node
	longDesc = A wrapper for the FBX node.
	group.name = geoutils
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
		}
        ## other base classes
        #other[] = {
		#}
	}
    features = {
        'copy'
        'create'
        'upcast'
        'classinfo'
    }
    create = {
        allocationError = GeoUtilsError("Could not allocate object.")
        extendedCreate = true
    }
}

# Member variables.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    bindings.disable = true
    type = FBXSDK_NAMESPACE::FbxNode*
    setFromType = FBXSDK_NAMESPACE::FbxNode*
    name = impl
    desc = FBX node implementation
    impl.set = <<<
if (newImpl == impl)
    return;
impl = newImpl;
update();
>>>
}
property.protected[] = {
    type = Ionflux::GeoUtils::Matrix4*
    setFromType = Ionflux::GeoUtils::Matrix4*
    name = transformMatrix
    desc = Transform matrix
    managed = true
}

# Public static constants.
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_UNKNOWN
    desc = Node attribute type: unknown
    value = 0
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_NULL
    desc = Node attribute type: null
    value = 1
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_MARKER
    desc = Node attribute type: marker
    value = 2
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_SKELETON
    desc = Node attribute type: skeleton
    value = 3
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_MESH
    desc = Node attribute type: mesh
    value = 4
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_NURBS
    desc = Node attribute type: nurbs
    value = 5
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_PATCH
    desc = Node attribute type: patch
    value = 6
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_CAMERA
    desc = Node attribute type: camera
    value = 7
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_CAMERASTEREO
    desc = Node attribute type: camerastereo
    value = 8
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_CAMERASWITCHER
    desc = Node attribute type: cameraswitcher
    value = 9
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_LIGHT
    desc = Node attribute type: light
    value = 10
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_OPTICALREFERENCE
    desc = Node attribute type: opticalreference
    value = 11
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_OPTICALMARKER
    desc = Node attribute type: opticalmarker
    value = 12
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_NURBSCURVE
    desc = Node attribute type: nurbscurve
    value = 13
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_TRIMNURBSSURFACE
    desc = Node attribute type: trimnurbssurface
    value = 14
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_BOUNDARY
    desc = Node attribute type: boundary
    value = 15
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_NURBSSURFACE
    desc = Node attribute type: nurbssurface
    value = 16
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_SHAPE
    desc = Node attribute type: shape
    value = 17
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_LODGROUP
    desc = Node attribute type: lodgroup
    value = 18
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_SUBDIV
    desc = Node attribute type: subdiv
    value = 19
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_CACHEDEFFECT
    desc = Node attribute type: cachedeffect
    value = 20
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_LINE
    desc = Node attribute type: line
    value = 21
}

# Protected static constants.

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = impl
        value = 0
    }
    initializer[] = {
        name = transformMatrix
        value = 0
    }
    impl = 
}
constructor.public[] = {
    bindings.disable = true
    initializer[] = {
        name = impl
        value = 0
    }
    initializer[] = {
        name = transformMatrix
        value = 0
    }
    param[] = {
        type = FBXSDK_NAMESPACE::FbxNode*
        name = initImpl
        desc = FBX node
    }
    impl = <<<
if (initImpl != 0)
    setImpl(initImpl);
>>>
}

# Destructor.
destructor.impl = <<<
impl = 0;
>>>

# Protected member functions.

# Public member functions.
function.copy.impl = <<<
if (this == &other)
    return *this;
setImpl(other.impl);
>>>
function.public[] = {
	spec = virtual
	type = void
	name = update
	shortDesc = Update
	longDesc = Update the state of the node from the implementation object.
	impl = <<<
if (impl == 0)
    return;
Matrix4 M0(getMatrix(impl->EvaluateLocalTransform()));
if (M0.eq(Matrix4::UNIT))
{
    if (transformMatrix != 0)
        setTransformMatrix(0);
    return;
}
Matrix4* m1 = transformMatrix;
if (m1 == 0)
{
    m1 = Matrix4::create();
    setTransformMatrix(m1);
}
m1->setElements(M0);
/*
Vector3 t0 = getVector(impl->LclTranslation.Get());
Vector3 r0 = getVector(impl->LclRotation.Get());
Vector3 s0 = getVector(impl->LclScaling.Get());
if (t0.eq(Vector3::ZERO) 
    && r0.eq(Vector3::ZERO) 
    && s0.eq(Vector3::E_SUM))
{
    if (transformMatrix != 0)
        setTransformMatrix(0);
    return;
}
Matrix4* m0 = transformMatrix;
if (m0 == 0)
{
    m0 = Matrix4::create();
    setTransformMatrix(m0);
}
m0->setIdentity();
if (!s0.eq(Vector3::E_SUM))
{
    Matrix4 S0(Matrix4::scale(s0));
    m0->multiplyLeft(S0);
}
if (!r0.eq(Vector3::ZERO))
{
    Matrix4 R0(Matrix3::rotate(r0.norm(), r0.normalize()));
    m0->multiplyLeft(R0);
}
if (!t0.eq(Vector3::ZERO))
{
    Matrix4 T0(Matrix4::translate(t0));
    m0->multiplyLeft(T0);
}
*/
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FBXNodeAttributeType
	name = getAttributeType
	const = true
	shortDesc = Get the node attribute type
	longDesc = Get the node attribute type.
	impl = <<<
if (impl == 0)
    return TYPE_UNKNOWN;
FbxNodeAttribute* attr0 = impl->GetNodeAttribute();
if (attr0 == 0)
    return TYPE_NULL;
>>>
    return = {
        value = getFBXNodeAttributeType(attr0->GetAttributeType())
        desc = String representation
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getName
	const = true
	shortDesc = Get the node name
	longDesc = Get the node name.
	impl = <<<
if (impl == 0)
    return "";
std::string result(impl->GetName());
>>>
    return = {
        value = result
        desc = Name
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = getNumChildNodes
	const = true
	shortDesc = Get the number of child nodes
	longDesc = Get the number of child nodes.
	impl = <<<
if (impl == 0)
    return 0;
>>>
    return = {
        value = impl->GetChildCount()
        desc = Number of child nodes
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FBXNode*
	name = getChildNode
	const = true
	shortDesc = Get child node
	longDesc = Get the child node with the specified index. The returned node will not be referenced and must be managed by the caller.
	param[] = {
	    type = int
	    name = index
	    desc = child node index
	}
	impl = <<<
if (impl == 0)
    return 0;
FbxNode* c0 = impl->GetChild(index);
if (c0 == 0)
    return 0;
FBXNode* result = FBXNode::create(c0);
>>>
    return = {
        value = result
        desc = Child node, or 0 if the child node ith the specified index does not exist
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = listChildNodes
	const = true
	shortDesc = List child nodes
	longDesc = List the child nodes of the node
	param[] = {
	    type = bool
	    name = recursive
	    desc = List child nodes recursively
	    default = false
	}
	param[] = {
	    type = unsigned int
	    name = indentWidth
	    desc = Indentation width
	    default = Ionflux::ObjectBase::DEFAULT_INDENT_WIDTH
	}
	param[] = {
	    type = char
	    name = indentChar
	    desc = Indentation character
	    default = ' '
	}
	param[] = {
	    type = unsigned int
	    name = depth
	    desc = Depth
	    default = 0
	}
	impl = <<<
std::string indent = Ionflux::ObjectBase::getIndent(depth, 
    indentWidth, indentChar);
int numChildNodes = getNumChildNodes();
for (int i = 0; i < numChildNodes; i++)
{
    FBXNode* n0 = getChildNode(i);
    if (n0 != 0)
    {
        addLocalRef(n0);
        std::cout << indent << "[" << n0->getValueString() << "]" 
            << std::endl;
        if (recursive)
        {
            n0->listChildNodes(true, indentWidth, indentChar, 
                depth + 1);
        }
        removeLocalRef(n0);
    }
}
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FBXNode*
	name = findChildNodeByName
	shortDesc = Find child node by name
	longDesc = Find a child node by name. The returned node will not be referenced and must be managed by the caller.
	param[] = {
	    type = const std::string&
	    name = needle
	    desc = name of node to be found
	}
	param[] = {
	    type = bool
	    name = recursive
	    desc = look for child node
	    default = true
	}
	impl = <<<
if ((getName() == needle) 
    || !recursive)
    return this;
int numChildNodes = getNumChildNodes();
int i = 0;
FBXNode* result = 0;
while ((result == 0) 
    && (i < numChildNodes))
{
    FBXNode* n0 = getChildNode(i);
    if (n0 != 0)
    {
        if (n0->getName() == needle)
        {
            result = n0;
        } else
            delete n0;
    }
    i++;
}
>>>
    return = {
        value = result
        desc = Node with the specified name, or 0 if the node does not exist
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = getMesh
	const = true
	shortDesc = Get mesh
	longDesc = Get the mesh attached to a node.
	param[] = {
	    type = Ionflux::GeoUtils::Mesh&
	    name = target
	    desc = where to store the mesh data
	}
	param[] = {
	    type = bool
	    name = recursive
	    desc = recursively merge meshes
	    default = false
	}
	param[] = {
	    type = Ionflux::GeoUtils::Matrix4*
	    name = localTransform
	    desc = local transformation to be applied to the mesh
	    default = 0
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, "getMesh", 
    "Node implementation");
FBXNodeAttributeType t0 = getAttributeType();
if ((t0 != TYPE_MESH) 
    && !recursive)
    return 0;
unsigned int numMeshes = 0;
if (t0 == TYPE_MESH)
{
    // extract the mesh
    FbxMesh* fbm0 = impl->GetMesh();
    Ionflux::ObjectBase::nullPointerCheck(fbm0, this, "getMesh", 
        "Mesh data");
    int numVerts0 = fbm0->GetControlPointsCount();
    int numFaces0 = fbm0->GetPolygonCount();
    // <---- DEBUG ----- //
    std::cerr << "[FBXNode::getMesh] DEBUG: "
        "merging mesh '" << getName() << "': " << "numVerts = " 
        << numVerts0 << ", numFaces = " << numFaces0 
        << std::endl;
    /* ----- DEBUG ----> */
    Ionflux::GeoUtils::Mesh m0;
    // vertices
    for (int i = 0; i < numVerts0; i++)
    {
        FbxVector4 v0 = fbm0->GetControlPointAt(i);
        Vertex3* cv = m0.addVertex();
        cv->setCoords(v0[0], v0[1], v0[2]);
    }
    // faces
    for (int i = 0; i < numFaces0; i++)
    {
        int n0 = fbm0->GetPolygonSize(i);
        if (n0 < 0)
        {
            std::ostringstream status;
            status << "Invalid polygon index (" << i << ").";
            throw GeoUtilsError(getErrorString(status.str(), 
                "getMesh"));
        }
        // <---- DEBUG ----- //
        if (n0 > 4)
        {
            std::cerr << "[FBXNode::getMesh] DEBUG: "
                "number of face vertices for face #" << i << ": " 
                << n0 << std::endl;
        }
        /* ----- DEBUG ----> */
        Face* cf = m0.addFace();
        for (int j = 0; j < n0; j++)
        {
            int v0 = fbm0->GetPolygonVertex(i, j);
            cf->addVertex(v0);
        }
    }
    if (transformMatrix != 0)
    {
        // apply transform of this node
        m0.transform(*transformMatrix);
    }
    if ((localTransform != 0) 
        && !localTransform->eq(Matrix4::UNIT))
    {
        // apply local transform
        m0.transform(*localTransform);
    }
    m0.applyTransform();
    target.merge(m0);
    numMeshes++;
}
if (!recursive)
    return numMeshes;
// determine local transformation for child meshes
Matrix4 T0(Matrix4::UNIT);
bool useLT = false;
if (transformMatrix != 0)
    T0.multiplyLeft(*transformMatrix);
if ((localTransform != 0) 
    && !localTransform->eq(Matrix4::UNIT))
    T0.multiplyLeft(*localTransform);
if (!T0.eq(Matrix4::UNIT))
    useLT = true;
// <---- DEBUG ----- //
if (useLT)
{
    std::cerr << "[FBXNode::getMesh] DEBUG: "
        "node '" << getName() << "': local transformation: [" 
        << T0.getValueString() << "]" << std::endl;
}
/* ----- DEBUG ----> */
// recursively merge meshes
int numChildNodes = getNumChildNodes();
for (int i = 0; i < numChildNodes; i++)
{
    FBXNode* n0 = getChildNode(i);
    if (n0 != 0)
    {
        addLocalRef(n0);
        if (useLT)
            numMeshes += n0->getMesh(target, true, &T0);
        else
            numMeshes += n0->getMesh(target, true);
        removeLocalRef(n0);
    }
}
>>>
    return = {
        value = numMeshes
        desc = number of meshes that were merged
    }
}

# public member functions overridden from IFObject
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object
	impl = <<<
std::ostringstream status;
status << getFBXNodeAttributeTypeString(getAttributeType());
std::string n0(getName());
if (n0.size() > 0)
    status << "; '" << n0 << "'";
if (transformMatrix != 0)
    status << "; [" << transformMatrix->getValueString() << "]";
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}

# Pure virtual member functions.

# operations

# Global functions.

