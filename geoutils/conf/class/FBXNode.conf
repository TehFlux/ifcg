# ===================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009-2014 Jörn P. Meier
# mail@ionflux.org
# -------------------------------------------------------------------
# FBXNode.conf              Class configuration.
# ===================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# 
# ===================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/constants.hpp"'
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/fbxtypes.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '<fbxsdk.h>'
        '"ifobject/utils.hpp"'
        '"ifobject/objectutils.hpp"'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/Matrix4.hpp"'
        '"geoutils/Mesh.hpp"'
        '"geoutils/Face.hpp"'
        '"geoutils/Vertex3.hpp"'
        '"geoutils/fbxutils.hpp"'
        '"geoutils/fbxutils_private.hpp"'
    }
}

# forward declarations
forward = {
    'class Matrix4'
    'class Mesh'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = FBXNode
	shortDesc = FBX Node
	title = FBX Node
	longDesc = A wrapper for the FBX node.
	group.name = geoutils
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
		}
        ## other base classes
        #other[] = {
		#}
	}
    features = {
        'copy'
        'create'
        'upcast'
        'classinfo'
        'xmlio'
    }
    create = {
        allocationError = GeoUtilsError("Could not allocate object.")
        extendedCreate = true
    }
    xml.elementName = fbxnode
}

# Member variables.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    bindings.disable = true
    type = FBXSDK_NAMESPACE::FbxNode*
    setFromType = FBXSDK_NAMESPACE::FbxNode*
    name = impl
    desc = FBX node implementation
    impl.set = <<<
if (newImpl == impl)
    return;
impl = newImpl;
update();
>>>
}
property.protected[] = {
    type = Ionflux::GeoUtils::Matrix4*
    setFromType = Ionflux::GeoUtils::Matrix4*
    name = transformMatrix
    desc = Transform matrix
    valueType = object
    managed = true
    xml = {
        child.name = transform_matrix
    }
}
property.protected[] = {
    style = vector
    name = childNodes
    desc = Child node vector
    element = {
        type = Ionflux::GeoUtils::FBXNode*
        name = ChildNode
        #plural = ChildNodes
        managed = true
        createExpr = FBXNode::create()
        valueType = object
    }
    xml.child = {
        name = child_nodes
        elementName = fbxnodevec
    }
    extendedAddFuncs = true
}
property.protected[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    setFromType = Ionflux::GeoUtils::FBXNodeAttributeType
    name = attributeType
    desc = Attribute type
    valueType = integer
    xml.attribute.name = attr_type
}
property.protected[] = {
    type = std::string
    setFromType = const std::string&
    name = name
    desc = Name
    valueType = string
    xml.attribute.name = fbx_name
}

# Public static constants.
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_UNKNOWN
    desc = Node attribute type: unknown
    value = 0
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_NULL
    desc = Node attribute type: null
    value = 1
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_MARKER
    desc = Node attribute type: marker
    value = 2
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_SKELETON
    desc = Node attribute type: skeleton
    value = 3
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_MESH
    desc = Node attribute type: mesh
    value = 4
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_NURBS
    desc = Node attribute type: nurbs
    value = 5
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_PATCH
    desc = Node attribute type: patch
    value = 6
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_CAMERA
    desc = Node attribute type: camera
    value = 7
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_CAMERASTEREO
    desc = Node attribute type: camerastereo
    value = 8
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_CAMERASWITCHER
    desc = Node attribute type: cameraswitcher
    value = 9
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_LIGHT
    desc = Node attribute type: light
    value = 10
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_OPTICALREFERENCE
    desc = Node attribute type: opticalreference
    value = 11
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_OPTICALMARKER
    desc = Node attribute type: opticalmarker
    value = 12
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_NURBSCURVE
    desc = Node attribute type: nurbscurve
    value = 13
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_TRIMNURBSSURFACE
    desc = Node attribute type: trimnurbssurface
    value = 14
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_BOUNDARY
    desc = Node attribute type: boundary
    value = 15
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_NURBSSURFACE
    desc = Node attribute type: nurbssurface
    value = 16
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_SHAPE
    desc = Node attribute type: shape
    value = 17
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_LODGROUP
    desc = Node attribute type: lodgroup
    value = 18
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_SUBDIV
    desc = Node attribute type: subdiv
    value = 19
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_CACHEDEFFECT
    desc = Node attribute type: cachedeffect
    value = 20
}
constant.public[] = {
    type = Ionflux::GeoUtils::FBXNodeAttributeType
    name = TYPE_LINE
    desc = Node attribute type: line
    value = 21
}

# Protected static constants.

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = impl
        value = 0
    }
    initializer[] = {
        name = transformMatrix
        value = 0
    }
    initializer[] = {
        name = attributeType
        value = TYPE_UNKNOWN
    }
    initializer[] = {
        name = name
        value = ""
    }
    impl = 
}
constructor.public[] = {
    bindings.disable = true
    initializer[] = {
        name = impl
        value = 0
    }
    initializer[] = {
        name = transformMatrix
        value = 0
    }
    initializer[] = {
        name = attributeType
        value = TYPE_UNKNOWN
    }
    initializer[] = {
        name = name
        value = ""
    }
    param[] = {
        type = FBXSDK_NAMESPACE::FbxNode*
        name = initImpl
        desc = FBX node
    }
    impl = <<<
if (initImpl != 0)
    setImpl(initImpl);
>>>
}

# Destructor.
destructor.impl = <<<
impl = 0;
>>>

# Protected member functions.

# Public member functions.
function.copy.impl = <<<
if (this == &other)
    return *this;
setImpl(other.impl);
>>>
function.public[] = {
	spec = virtual
	type = void
	name = update
	shortDesc = Update
	longDesc = Update the state of the node from the implementation object.
	impl = <<<
if (impl == 0)
{
    setAttributeType(TYPE_UNKNOWN);
    setName("");
    return;
}
setName(impl->GetName());
FbxNodeAttribute* attr0 = impl->GetNodeAttribute();
if (attr0 == 0)
    setAttributeType(TYPE_NULL);
else
{
    setAttributeType(getFBXNodeAttributeType(
        attr0->GetAttributeType()));
}
Matrix4 M0(getMatrix(impl->EvaluateLocalTransform(FBXSDK_TIME_ZERO)));
if (M0.eq(Matrix4::UNIT))
{
    if (transformMatrix != 0)
        setTransformMatrix(0);
    return;
}
Matrix4* m1 = transformMatrix;
if (m1 == 0)
{
    m1 = Matrix4::create();
    setTransformMatrix(m1);
}
m1->setElements(M0);
>>>
}
function.public[] = {
	spec = virtual
	type = int
	name = getNumChildNodesFBX
	const = true
	shortDesc = Get the number of child nodes (FBX)
	longDesc = Get the number of child nodes from the FBX hierarchy.
	impl = <<<
if (impl == 0)
    return 0;
>>>
    return = {
        value = impl->GetChildCount()
        desc = Number of child nodes
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FBXNode*
	name = getChildNodeFBX
	const = true
	shortDesc = Get child node (FBX)
	longDesc = Get the child node with the specified index from the FBX hierarchy. The returned node will not be referenced and must be managed by the caller.
	param[] = {
	    type = int
	    name = index
	    desc = child node index
	}
	impl = <<<
if (impl == 0)
    return 0;
FbxNode* c0 = impl->GetChild(index);
if (c0 == 0)
    return 0;
FBXNode* result = FBXNode::create(c0);
>>>
    return = {
        value = result
        desc = Child node, or 0 if the child node ith the specified index does not exist
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = addChildNodesFBX
	shortDesc = Add child nodes (FBX)
	longDesc = Add the child nodes from the FBX hierarchy.
	param[] = {
	    type = bool
	    name = recursive
	    desc = Add child nodes recursively
	    default = false
	}
	impl = <<<
int n0 = getNumChildNodesFBX();
for (int i = 0; i < n0; i++)
{
    Ionflux::GeoUtils::FBXNode* cn = getChildNodeFBX(i);
    if (cn != 0)
    {
        /* <---- DEBUG ----- //
        std::cerr << "[FBXNode::addChildNodesFBX] DEBUG: "
            "adding child node: [" << cn->getValueString() << "]." 
            << std::endl;
        // ----- DEBUG ----> */
        addChildNode(cn);
        if (recursive)
            cn->addChildNodesFBX(true);
    }
}
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = listChildNodesFBX
	const = true
	shortDesc = List child nodes (FBX)
	longDesc = List the child nodes of the node from the FBX hierarchy.
	param[] = {
	    type = bool
	    name = recursive
	    desc = List child nodes recursively
	    default = false
	}
	param[] = {
	    type = unsigned int
	    name = indentWidth
	    desc = Indentation width
	    default = Ionflux::ObjectBase::DEFAULT_INDENT_WIDTH
	}
	param[] = {
	    type = char
	    name = indentChar
	    desc = Indentation character
	    default = ' '
	}
	param[] = {
	    type = unsigned int
	    name = depth
	    desc = Depth
	    default = 0
	}
	impl = <<<
std::string indent = Ionflux::ObjectBase::getIndent(depth, 
    indentWidth, indentChar);
int numChildNodes = getNumChildNodesFBX();
for (int i = 0; i < numChildNodes; i++)
{
    FBXNode* n0 = getChildNode(i);
    if (n0 != 0)
    {
        addLocalRef(n0);
        std::cout << indent << "[" << n0->getValueString() << "]" 
            << std::endl;
        if (recursive)
        {
            n0->listChildNodesFBX(true, indentWidth, indentChar, 
                depth + 1);
        }
        removeLocalRef(n0);
    }
}
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FBXNode*
	name = findChildNodeByNameFBX
	shortDesc = Find child node by name (FBX)
	longDesc = Find a child node by name from the FBX hierarchy. The returned node will not be referenced and must be managed by the caller.
	param[] = {
	    type = const std::string&
	    name = needle
	    desc = name of node to be found
	}
	param[] = {
	    type = bool
	    name = recursive
	    desc = look for child node recursively
	    default = true
	}
	impl = <<<
if ((getName() == needle) 
    || !recursive)
    return this;
int numChildNodes = getNumChildNodesFBX();
int i = 0;
FBXNode* result = 0;
while ((result == 0) 
    && (i < numChildNodes))
{
    FBXNode* n0 = getChildNodeFBX(i);
    if (n0 != 0)
    {
        result = n0->findChildNodeByNameFBX(needle, true);
        if (n0 != result)
            delete n0;
    }
    i++;
}
>>>
    return = {
        value = result
        desc = Node with the specified name, or 0 if the node does not exist
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = getMesh
	const = true
	shortDesc = Get mesh
	longDesc = Get the mesh attached to a node.
	param[] = {
	    type = Ionflux::GeoUtils::Mesh&
	    name = target
	    desc = where to store the mesh data
	}
	param[] = {
	    type = bool
	    name = recursive
	    desc = recursively merge meshes
	    default = false
	}
	param[] = {
	    type = Ionflux::GeoUtils::Matrix4*
	    name = localTransform
	    desc = local transformation to be applied to the mesh
	    default = 0
	}
	param[] = {
	    type = bool
	    name = applyNodeTransform0
	    desc = apply node transformations
	    default = true
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, "getMesh", 
    "Node implementation");
FBXNodeAttributeType t0 = getAttributeType();
if ((t0 != TYPE_MESH) 
    && !recursive)
    return 0;
unsigned int numMeshes = 0;
if (t0 == TYPE_MESH)
{
    // extract the mesh
    FbxMesh* fbm0 = impl->GetMesh();
    Ionflux::ObjectBase::nullPointerCheck(fbm0, this, "getMesh", 
        "Mesh data");
    int numVerts0 = fbm0->GetControlPointsCount();
    int numFaces0 = fbm0->GetPolygonCount();
    /* <---- DEBUG ----- //
    std::cerr << "[FBXNode::getMesh] DEBUG: "
        "merging mesh '" << getName() << "': " << "numVerts = " 
        << numVerts0 << ", numFaces = " << numFaces0 
        << std::endl;
    // ----- DEBUG ----> */
    Ionflux::GeoUtils::Mesh m0;
    // vertices
    for (int i = 0; i < numVerts0; i++)
    {
        FbxVector4 v0 = fbm0->GetControlPointAt(i);
        Vertex3* cv = m0.addVertex();
        cv->setCoords(v0[0], v0[1], v0[2]);
    }
    // faces
    for (int i = 0; i < numFaces0; i++)
    {
        int n0 = fbm0->GetPolygonSize(i);
        if (n0 < 0)
        {
            std::ostringstream status;
            status << "Invalid polygon index (" << i << ").";
            throw GeoUtilsError(getErrorString(status.str(), 
                "getMesh"));
        }
        /* <---- DEBUG ----- //
        if (n0 > 4)
        {
            std::cerr << "[FBXNode::getMesh] DEBUG: "
                "number of face vertices for face #" << i << ": " 
                << n0 << std::endl;
        }
        // ----- DEBUG ----> */
        Face* cf = m0.addFace();
        for (int j = 0; j < n0; j++)
        {
            int v0 = fbm0->GetPolygonVertex(i, j);
            cf->addVertex(v0);
        }
    }
    if (applyNodeTransform0)
    {
        /* <---- DEBUG ----- //
        m0.update();
        Range3 bb0 = m0.getBounds();
        Vector3 c0 = bb0.getCenter();
        Vector3 e0 = bb0.getExtent();
        std::cerr << "[FBXNode::getMesh] DEBUG: "
            "mesh '" << getName() << "': transformMatrix = ";
        if (transformMatrix != 0)
        {
            std::cerr << "[" << transformMatrix->getValueString() 
                << "]";
        } else
            std::cerr << "<none>";
        std::cerr << ", localTransform = ";
        if ((localTransform != 0) 
            && !localTransform->eq(Matrix4::UNIT))
        {
            std::cerr << "[" << localTransform->getValueString() 
                << "]";
        } else
        if ((localTransform != 0) 
            && localTransform->eq(Matrix4::UNIT))
        {
            std::cerr << "UNIT [" 
                << localTransform->getValueString() << "]";
        } else
            std::cerr << "<none>";
        std::cerr << ", bBox = [" << bb0.getValueString() 
            << "], center = (" << c0.getValueString() 
            << "), extent = (" << e0.getValueString() << ")";
        std::cerr << std::endl;
        // ----- DEBUG ----> */
        if (transformMatrix != 0)
        {
            // apply transform of this node
            m0.transform(*transformMatrix);
        }
        if ((localTransform != 0) 
            && !localTransform->eq(Matrix4::UNIT))
        {
            // apply local transform
            m0.transform(*localTransform);
        }
        m0.applyTransform(true);
        /* <---- DEBUG ----- //
        m0.update();
        bb0 = m0.getBounds();
        c0 = bb0.getCenter();
        e0 = bb0.getExtent();
        std::cerr << "[FBXNode::getMesh] DEBUG: "
            "mesh '" << getName() << "' after transform: "
            << ", bBox = [" << bb0.getValueString() 
            << "], center = (" << c0.getValueString() 
            << "), extent = (" << e0.getValueString() << ")" 
            << std::endl;
        // ----- DEBUG ----> */
    }
    target.merge(m0);
    numMeshes++;
}
if (!recursive)
    return numMeshes;
// determine local transformation for child meshes
Matrix4 T0(Matrix4::UNIT);
bool useLT = false;
if (applyNodeTransform0)
{
    if (transformMatrix != 0)
        T0.multiplyLeft(*transformMatrix);
    if ((localTransform != 0) 
        && !localTransform->eq(Matrix4::UNIT))
        T0.multiplyLeft(*localTransform);
    if (!T0.eq(Matrix4::UNIT))
        useLT = true;
}
/* <---- DEBUG ----- //
if (useLT)
{
    std::cerr << "[FBXNode::getMesh] DEBUG: "
        "node '" << getName() << "': local transformation: [" 
        << T0.getValueString() << "]";
    if (transformMatrix != 0)
    {
        std::cerr << ", transformMatrix = [" 
            << transformMatrix->getValueString() << "]";
    }
    if (localTransform != 0)
    {
        std::cerr << ", localTransform = [" 
            << localTransform->getValueString() << "]";
    }
    std::cerr << std::endl;
}
// ----- DEBUG ----> */
// recursively merge meshes
int numChildNodes = getNumChildNodesFBX();
for (int i = 0; i < numChildNodes; i++)
{
    FBXNode* n0 = getChildNodeFBX(i);
    if (n0 != 0)
    {
        addLocalRef(n0);
        if (useLT)
            numMeshes += n0->getMesh(target, true, &T0, 
                applyNodeTransform0);
        else
            numMeshes += n0->getMesh(target, true, 0, 
                applyNodeTransform0);
        removeLocalRef(n0);
    }
}
>>>
    return = {
        value = numMeshes
        desc = number of meshes that were merged
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = dumpMesh
	const = true
	shortDesc = Dump mesh
	longDesc = Dump mesh data from a node to a directory. Each mesh will be saved to an individual file.
	param[] = {
	    type = const std::string&
	    name = targetPath
	    desc = where to store the mesh data
	}
	param[] = {
	    type = bool
	    name = recursive
	    desc = recursively dump meshes
	    default = false
	}
	param[] = {
	    type = Ionflux::GeoUtils::Matrix4*
	    name = localTransform
	    desc = local transformation to be applied to the mesh
	    default = 0
	}
	param[] = {
	    type = unsigned int
	    name = startIndex
	    desc = start index for extracted meshes
	    default = 0
	}
	param[] = {
	    type = double
	    name = scale0
	    desc = mesh scale factor
	    default = 1.
	}
	param[] = {
	    type = bool
	    name = applyNodeTransform0
	    desc = apply node transformations
	    default = true
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(impl, this, "dumpMesh", 
    "Node implementation");
FBXNodeAttributeType t0 = getAttributeType();
if ((t0 != TYPE_MESH) 
    && !recursive)
    return 0;
unsigned int numMeshes = 0;
if (t0 == TYPE_MESH)
{
    // extract the mesh
    Mesh m0;
    getMesh(m0, false, localTransform, applyNodeTransform0);
    m0.update();
    std::string nn0(getName());
    std::ostringstream mn0;
    if (nn0.size() == 0)
        mn0 << "UnnamedNode_" << startIndex;
    else
        mn0 << nn0;
    m0.setID(mn0.str());
    if (scale0 != 1.)
    {
        Vector3 sv0(scale0, scale0, scale0);
        m0.scale(sv0);
    }
    /* <---- DEBUG ----- //
    unsigned int nv0 = m0.getNumVertices();
    unsigned int nf0 = m0.getNumFaces();
    std::cerr << "[FBXNode::dumpMesh] DEBUG: "
        "extracted mesh '" << mn0.str() << "': " << "numVerts = " 
        << nv0 << ", numFaces = " << nf0 << std::endl;
    // ----- DEBUG ----> */
    std::ostringstream fn0;
    if (targetPath.size() > 0)
        fn0 << targetPath << Ionflux::ObjectBase::DIR_SEPARATOR;
    fn0 << std::setw(6) << std::setfill('0') << startIndex << "_" 
        << mn0.str() << ".xml";
    /* <---- DEBUG ----- //
    std::cerr << "[FBXNode::dumpMesh] DEBUG: "
        "writing mesh to file '" << fn0.str() << "'..." << std::endl;
    // ----- DEBUG ----> */
    m0.applyTransform(true);
    m0.writeToXMLFile(fn0.str());
    numMeshes++;
}
if (!recursive)
    return numMeshes;
// determine local transformation for child meshes
Matrix4 T0(Matrix4::UNIT);
bool useLT = false;
if (applyNodeTransform0)
{
    if (transformMatrix != 0)
        T0.multiplyLeft(*transformMatrix);
    if ((localTransform != 0) 
        && !localTransform->eq(Matrix4::UNIT))
        T0.multiplyLeft(*localTransform);
    if (!T0.eq(Matrix4::UNIT))
        useLT = true;
}
/* <---- DEBUG ----- //
if (useLT)
{
    std::cerr << "[FBXNode::dumpMesh] DEBUG: "
        "node '" << getName() << "': local transformation: [" 
        << T0.getValueString() << "]";
    if (transformMatrix != 0)
    {
        std::cerr << ", transformMatrix = [" 
            << transformMatrix->getValueString() << "]";
    }
    if (localTransform != 0)
    {
        std::cerr << ", localTransform = [" 
            << localTransform->getValueString() << "]";
    }
    std::cerr << std::endl;
}
// ----- DEBUG ----> */
// recursively dump meshes
int numChildNodes = getNumChildNodesFBX();
for (int i = 0; i < numChildNodes; i++)
{
    FBXNode* n0 = getChildNodeFBX(i);
    if (n0 != 0)
    {
        addLocalRef(n0);
        unsigned int nm0 = 0;
        if (useLT)
            nm0 += n0->dumpMesh(targetPath, true, &T0, 
                startIndex, scale0, applyNodeTransform0);
        else
            nm0 += n0->dumpMesh(targetPath, true, 0, 
                startIndex, scale0, applyNodeTransform0);
        startIndex += nm0;
        numMeshes += nm0;
        removeLocalRef(n0);
    }
}
>>>
    return = {
        value = numMeshes
        desc = number of meshes that were merged
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = assignNodeIDs
	shortDesc = Assign node IDs
	longDesc = Recursively assign node IDs to the nodes contained in the hierarchy of which this node is the root. Each node is assigned an ID consisting of the prefix and a number (starting from \c offset) that is formatted according to the specified parameters.
	param[] = {
	    type = const std::string&
	    name = prefix
	    desc = ID prefix
	    default = ""
	}
	param[] = {
	    type = unsigned int
	    name = width
	    desc = field width
	    default = 8
	}
	param[] = {
	    type = char
	    name = fillChar
	    desc = Fill character
	    default = '0'
	}
	param[] = {
	    type = unsigned int
	    name = offset
	    desc = offset
	    default = 0
	}
	impl = <<<
std::ostringstream id0;
id0 << prefix << std::setw(width) << std::setfill(fillChar) 
    << std::right << offset;
setID(id0.str());
offset += 1;
int n0 = getNumChildNodes();
for (int i = 0; i < n0; i++)
{
    Ionflux::GeoUtils::FBXNode* cn = getChildNode(i);
    if (cn != 0)
        offset = cn->assignNodeIDs(prefix, width, fillChar, offset);
}
>>>
    return = {
        value = offset
        desc = new offset
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FBXNode*
	name = findChildNodeByName
	shortDesc = Find child node by name
	longDesc = Find a child node by name.
	param[] = {
	    type = const std::string&
	    name = needle
	    desc = name of node to be found
	}
	param[] = {
	    type = bool
	    name = recursive
	    desc = look for child node recursively
	    default = true
	}
	impl = <<<
if ((getName() == needle) 
    || !recursive)
    return this;
int numChildNodes = getNumChildNodes();
int i = 0;
FBXNode* result = 0;
while ((result == 0) 
    && (i < numChildNodes))
{
    FBXNode* n0 = getChildNode(i);
    if (n0 != 0)
        result = n0->findChildNodeByName(needle, true);
    i++;
}
>>>
    return = {
        value = result
        desc = Node with the specified name, or 0 if the node does not exist
    }
}

# public member functions overridden from IFObject
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object
	impl = <<<
std::ostringstream status;
status << getFBXNodeAttributeTypeString(getAttributeType());
std::string n0(getName());
if (n0.size() > 0)
    status << "; '" << n0 << "'";
if (transformMatrix != 0)
    status << "; [" << transformMatrix->getValueString() << "]";
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}

# Pure virtual member functions.

# operations

# Global functions.

