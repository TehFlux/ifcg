# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2010-2014 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# NFace.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GeoUtils - Ionflux' Geometry Library; if not, write to the 
# Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
# 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/types.hpp"'
        '"geoutils/Matrix3.hpp"'
        '"geoutils/Edge.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"ifobject/objectutils.hpp"'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/Vertex3Set.hpp"'
        '"geoutils/VectorSetSet.hpp"'
        '"geoutils/FaceData.hpp"'
        '"geoutils/NFaceSet.hpp"'
    }
}

# forward declarations
forward = {
    'class VectorSetSet'
    'class FaceData'
    'class NFaceSet'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = NFace
	shortDesc = N-face
	title = N-face
	longDesc = A collection of a number of vertices, specified by index, optionally with associated face vertex data.
	group.name = geoutils
	base = {
		## base classes from the IFObject hierarchy
		#ifobject[] = {
		#	name = IFObject
		#}
        # other base classes
        other[] = {
			name = Ionflux::GeoUtils::BoxBoundsItem
            include = geoutils/BoxBoundsItem.hpp
            inheritanceType = virtual public
		}
        other[] = {
			name = Ionflux::GeoUtils::TransformableObject
            include = geoutils/TransformableObject.hpp
            inheritanceType = virtual public
            xml = {
                enabled = true
                #getFunc = getTransformableObject
                include = geoutils/TransformableObject
            }
		}
	}
    features = {
        'logmessage'
        'classinfo'
        'copy'
        'upcast'
        'create'
        'xmlio'
        'serialize'
    }
    create = {
        allocationError = GeoUtilsError("Could not allocate object.")
        extendedCreate = true
    }
    xml.elementName = nface
    serialize = {
        errorClass = GeoUtilsError
        magicSyllable = {
            value = 0x4e46
            desc = NF
        }
    }
}

# Member variables.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    style = vector
    name = vertices
    desc = Vertex index vector
    element = {
        type = unsigned int
        name = Vertex
        plural = Vertices
        #managed = true
        valueType = integer
        createExpr = 0
    }
    xml = {
        child.name = vertices
    }
    extendedAddFuncs = true
}
property.protected[] = {
    # NOTE: There should be no need for the vertex source to be managed by 
    #       the faces, since usually the faces are managed by a higher level 
    #       object that also manages the vertex source.
	type = Ionflux::GeoUtils::Vertex3Set*
	setFromType = Ionflux::GeoUtils::Vertex3Set*
	name = vertexSource
	desc = Vertex source
#   managed = true
#   copy = true
#   proxy = true
}
property.protected[] = {
    type = Ionflux::GeoUtils::VectorSetSet*
    setFromType = Ionflux::GeoUtils::VectorSetSet*
    name = faceData
    desc = face data
    xml = {
        child = {
            name = fds
            elementName = data
        }
        #createFunc = createVectorSetSet
    }
    valueType = object
}

# Protected variables.
variable.protected[] = {
       type = Ionflux::GeoUtils::Polygon3*
       name = polygon
       desc = Polygon
}

# Public static constants.
constant.public[] = {
       type = unsigned int
       name = VERTEX_INDEX_NONE
       desc = Vertex index not pointing at any vertex
       value = UINT_MAX
}

# Public static constants.
constant.public[] = {
    type = Ionflux::GeoUtils::NFaceTypeID
    name = TYPE_FACE
    desc = N-face type: face
    value = 0
}
constant.public[] = {
    type = Ionflux::GeoUtils::NFaceTypeID
    name = TYPE_EDGE
    desc = N-face type: edge
    value = 1
}

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = polygon
        value = 0
    }
    initializer[] = {
        name = vertexSource
        value = 0
    }
    initializer[] = {
        name = faceData
        value = 0
    }
    impl = 
}
constructor.public[] = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = polygon
        value = 0
    }
    initializer[] = {
        name = vertexSource
        value = initVertexSource
    }
    initializer[] = {
        name = faceData
        value = 0
    }
    param[] = {
        name = initVerts
        type = const Ionflux::ObjectBase::UIntVector*
        desc = Vertex index vector
    }
    param[] = {
        name = initVertexSource
        type = Ionflux::GeoUtils::Vertex3Set*
        desc = Vertex source
        default = 0
    }
    param[] = {
        name = initUV
        type = Ionflux::GeoUtils::FaceData*
        desc = Texture coordinates
        default = 0
    }
    param[] = {
        name = initVertexColors
        type = Ionflux::GeoUtils::FaceData*
        desc = Vertex colors
        default = 0
    }
    impl = <<<
if (initVerts != 0)
    addVertices(*initVerts);
if (initVertexSource != 0)
    setVertexSource(initVertexSource);
if (initUV != 0)
    addFaceData(initUV);
if (initVertexColors != 0)
    addFaceData(initVertexColors);
update();
>>>
}
constructor.public[] = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = polygon
        value = 0
    }
    initializer[] = {
        name = vertexSource
        value = initVertexSource
    }
    initializer[] = {
        name = faceData
        value = 0
    }
	param[] = {
		type = unsigned int
		name = v0
		desc = Vertex index (0)
	}
	param[] = {
		type = unsigned int
		name = v1
		desc = Vertex index (1)
	}
	param[] = {
		type = unsigned int
		name = v2
		desc = Vertex index (2)
		default = Ionflux::GeoUtils::NFace::VERTEX_INDEX_NONE
	}
	param[] = {
		type = unsigned int
		name = v3
		desc = Vertex index (3)
		default = Ionflux::GeoUtils::NFace::VERTEX_INDEX_NONE
	}
    param[] = {
        name = initVertexSource
        type = Ionflux::GeoUtils::Vertex3Set*
        desc = Vertex source
        default = 0
    }
    param[] = {
        name = initUV
        type = Ionflux::GeoUtils::FaceData*
        desc = Texture coordinates
        default = 0
    }
    param[] = {
        name = initVertexColors
        type = Ionflux::GeoUtils::FaceData*
        desc = Vertex colors
        default = 0
    }
    impl = <<<
addVertices(v0, v1, v2, v3);
if (initVertexSource != 0)
    setVertexSource(initVertexSource);
if (initUV != 0)
    addFaceData(initUV);
if (initVertexColors != 0)
    addFaceData(initVertexColors);
update();
>>>
}

# Destructor.
destructor.impl = clear();

# Protected member functions.

# copy assignment function
function.copy.impl = <<<
if (this == &other)
    return *this;
TransformableObject::operator=(other);
UIntVector v0;
for (UIntVector::const_iterator i = other.vertices.begin(); 
    i != other.vertices.end(); i++)
    v0.push_back(*i);
clear();
addVertices(v0);
if (other.faceData != 0)
    setFaceData(other.faceData->copy());
update();
>>>

# serialization functions
function.serialize.stream.impl = <<<
if (addMagicWord)
    Ionflux::ObjectBase::pack(getMagicSyllableBase(), 
        getMagicSyllable(), target);
Ionflux::ObjectBase::packVec<unsigned int, 
    Ionflux::ObjectBase::UInt64>(vertices, target);
// TODO: Pack face data.
Ionflux::ObjectBase::pack(
    static_cast<Ionflux::ObjectBase::UInt8>(0), target);
>>>
function.deserialize.stream.impl = <<<
if (checkMagicWord)
    Ionflux::ObjectBase::unpackAndCheckMagicWord(source, 
        getMagicSyllableBase(), getMagicSyllable(), 
        Ionflux::ObjectBase::DATA_SIZE_INVALID, 
        this, "deserialize");
Ionflux::ObjectBase::unpackVec<unsigned int, 
    Ionflux::ObjectBase::UInt64>(source, vertices);
if (Ionflux::ObjectBase::unpackNonNullCheck(source))
{
    // TODO: Unpack face data.
}
>>>

# Public member functions.
function.public[] = {
	spec = virtual
	type = void
	name = copyVertices
	shortDesc = Copy vertices
	longDesc = Create a new vertex set with copies of the current vertices. This makes the face the (current) single owner of its vertices.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "copyVertices", "Vertex source");
setVertexSource(&(vertexSource->duplicate()));
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = update
	shortDesc = Update
	longDesc = Update all state according to the vertices of the face.
    impl = <<<
if ((vertexSource == 0) 
    || (vertices.size() == 0))
    return;
clearPolygon();
recalculateBounds();
updateRadiusAndCenter();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = clearPolygon
	shortDesc = Clear polygon
	longDesc = Clear the face polygon.
    impl = <<<
if (polygon != 0)
    removeLocalRef(polygon);
polygon = 0;
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = clear
	shortDesc = Clear
	longDesc = Removes all items and resets state.
    impl = <<<
vertices.clear();
setVertexSource(0);
setFaceData(0);
clearPolygon();
BoxBoundsItem::clear();
TransformableObject::clear();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = addVertices
	shortDesc = Add vertex indices
	longDesc = Add vertex indices for a triangle or quad.
	param[] = {
		type = unsigned int
		name = v0
		desc = Vertex index (0)
	}
	param[] = {
		type = unsigned int
		name = v1
		desc = Vertex index (1)
		default = Ionflux::GeoUtils::NFace::VERTEX_INDEX_NONE
	}
	param[] = {
		type = unsigned int
		name = v2
		desc = Vertex index (2)
		default = Ionflux::GeoUtils::NFace::VERTEX_INDEX_NONE
	}
	param[] = {
		type = unsigned int
		name = v3
		desc = Vertex index (3)
		default = Ionflux::GeoUtils::NFace::VERTEX_INDEX_NONE
	}
    impl = <<<
addVertex(v0);
if (v1 != VERTEX_INDEX_NONE)
    addVertex(v1);
if (v2 != VERTEX_INDEX_NONE)
    addVertex(v2);
if (v3 != VERTEX_INDEX_NONE)
    addVertex(v3);
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addFaceData
	shortDesc = Add face data
	longDesc = Add a face data entry.
	param[] = {
		type = Ionflux::GeoUtils::FaceData*
		name = newFaceData
		desc = Face data
	}
    impl = <<<
if (faceData == 0)
    faceData = VectorSetSet::create();
faceData->addVectorSet(newFaceData);
>>>
    return = {
        value = newFaceData
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addFaceData
	shortDesc = Add face data
	longDesc = Add a face data entry of a certain type.
	param[] = {
		type = Ionflux::GeoUtils::FaceDataTypeID
		name = dataType
		desc = Face data type ID
	}
    impl = <<<
FaceData* newData = FaceData::create(dataType);
addFaceData(newData);
>>>
    return = {
        value = newData
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addFaceData
	shortDesc = Add face data
	longDesc = Add a face data entry of a certain type. The face data entry will be composed of the specified input vectors.
	param[] = {
		type = Ionflux::GeoUtils::FaceDataTypeID
		name = dataType
		desc = Face data type ID
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v0
		desc = Face data vector (0)
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v1
		desc = Face data vector (1)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v2
		desc = Face data vector (2)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v3
		desc = Face data vector (3)
		default = 0
	}
    impl = <<<
FaceData* newData = FaceData::create(dataType);
unsigned int numNonNull = 0;
if (v0 != 0)
{
    newData->addVector(v0);
    numNonNull++;
}
if (v1 != 0)
{
    newData->addVector(v1);
    numNonNull++;
}
if (v2 != 0)
{
    newData->addVector(v2);
    numNonNull++;
}
if (v3 != 0)
{
    newData->addVector(v3);
    numNonNull++;
}
unsigned int expected = getNumVertices();
if (numNonNull < expected)
{
    std::ostringstream status;
    status << "Not enough input vectors for face data (" 
        << FaceData::getTypeIDString(dataType) << ", expected " 
        << expected << ", have " << numNonNull << ")";
    throw GeoUtilsError(getErrorString(status.str(), "addFaceData"));
}
addFaceData(newData);
>>>
    return = {
        value = newData
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addTexCoords
	shortDesc = Add texture coordinates
	longDesc = Add texture coordinates. The face data entry will be composed of the specified input vectors.
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v0
		desc = Face data vector (0)
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v1
		desc = Face data vector (1)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v2
		desc = Face data vector (2)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v3
		desc = Face data vector (3)
		default = 0
	}
    impl = 
    return = {
        value = addFaceData(FaceData::TYPE_TEX_COORD, v0, v1, v2, v3)
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addVertexColors
	shortDesc = Add vertex colors
	longDesc = Add vertex colors. The face data entry will be composed of the specified input vectors.
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v0
		desc = Face data vector (0)
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v1
		desc = Face data vector (1)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v2
		desc = Face data vector (2)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v3
		desc = Face data vector (3)
		default = 0
	}
    impl = 
    return = {
        value = addFaceData(FaceData::TYPE_VERTEX_COLOR, v0, v1, v2, v3)
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::VectorSet*
	name = addVertexNormals
	shortDesc = Add vertex normals
	longDesc = Add vertex normals. The face data entry will be composed of the specified input vectors.
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v0
		desc = Face data vector (0)
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v1
		desc = Face data vector (1)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v2
		desc = Face data vector (2)
		default = 0
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector*
		name = v3
		desc = Face data vector (3)
		default = 0
	}
    impl = 
    return = {
        value = addFaceData(FaceData::TYPE_VERTEX_NORMAL, v0, v1, v2, v3)
        desc = New face data
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getFaceDataByType
	shortDesc = Get face data by type
	longDesc = Get face data entries of a certain type.
	param[] = {
		type = Ionflux::GeoUtils::FaceDataTypeID
		name = dataType
		desc = Face data type ID
	}
	param[] = {
		type = Ionflux::GeoUtils::VectorSetSet&
		name = target
		desc = Where to store the face data
	}
    impl = <<<
if (faceData == 0)
    return;
for (unsigned int i = 0; i < faceData->getNumVectorSets(); i++)
{
    FaceData* cfd = FaceData::upcast(faceData->getVectorSet(i));
    if ((cfd != 0) 
        && cfd->hasType(dataType))
        target.addVectorSet(cfd);
}
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FaceData*
	name = getFaceDataByType0
	shortDesc = Get face data by type and index
	longDesc = Get face data by type and index. This gets the face data record that represents the \c index-th occurence of face data of the specified type.
	param[] = {
		type = Ionflux::GeoUtils::FaceDataTypeID
		name = dataType
		desc = Face data type ID
	}
	param[] = {
		type = unsigned int
		name = index
		desc = face data index
		default = 0
	}
    impl = <<<
if (faceData == 0)
    return 0;
FaceData* result = 0;
unsigned int i = 0;
unsigned int k = 0;
while ((i < faceData->getNumVectorSets()) 
    && (result == 0))
{
    FaceData* cfd = FaceData::upcast(faceData->getVectorSet(i));
    if ((cfd != 0) 
        && cfd->hasType(dataType))
    {
        if (k == index)
            result = cfd;
        else
            k++;
    }
    i++;
}
>>>
    return = {
        value = result
        desc = Face data entry, or 0 if no matching face data exists
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getTexCoords
	shortDesc = Get texture coordinates
	longDesc = Get texture coordinates.
	param[] = {
		type = Ionflux::GeoUtils::VectorSetSet&
		name = target
		desc = Where to store the face data
	}
    impl = getFaceDataByType(FaceData::TYPE_TEX_COORD, target);
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FaceData*
	name = getTexCoords0
	shortDesc = Get texture coordinates
	longDesc = Get texture coordinates by index.
	param[] = {
		type = unsigned int
		name = index
		desc = face data index
		default = 0
	}
    impl = 
    return = {
        value = getFaceDataByType0(FaceData::TYPE_TEX_COORD, index);
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getVertexColors
	shortDesc = Get vertex colors
	longDesc = Get vertex colors.
	param[] = {
		type = Ionflux::GeoUtils::VectorSetSet&
		name = target
		desc = Where to store the face data
	}
    impl = getFaceDataByType(FaceData::TYPE_VERTEX_COLOR, target);
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FaceData*
	name = getVertexColors0
	shortDesc = Get vertex colors
	longDesc = Get vertex colors by index.
	param[] = {
		type = unsigned int
		name = index
		desc = face data index
		default = 0
	}
    impl = 
    return = {
        value = getFaceDataByType0(FaceData::TYPE_VERTEX_COLOR, index);
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getVertexNormals
	shortDesc = Get vertex normals
	longDesc = Get vertex normals.
	param[] = {
		type = Ionflux::GeoUtils::VectorSetSet&
		name = target
		desc = Where to store the face data
	}
    impl = getFaceDataByType(FaceData::TYPE_VERTEX_NORMAL, target);
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::FaceData*
	name = getVertexNormals0
	shortDesc = Get vertex normals
	longDesc = Get vertex normals by index.
	param[] = {
		type = unsigned int
		name = index
		desc = face data index
		default = 0
	}
    impl = 
    return = {
        value = getFaceDataByType0(FaceData::TYPE_VERTEX_NORMAL, index);
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getFaceDataByVertex
	shortDesc = Get face data by vertex
	longDesc = Get face data for the vertices specified by the indices in \c faceVertexIndices, where each index refers to one vertex of the face (not the underlying vertex set).
	param[] = {
		type = Ionflux::ObjectBase::UIntVector&
		name = faceVertexIndices
		desc = Vertex indices
	}
	param[] = {
		type = Ionflux::GeoUtils::VectorSetSet&
		name = target
		desc = Where to store the face data
	}
    impl = <<<
if (faceData == 0)
    return;
unsigned int n0 = faceData->getNumVectorSets();
unsigned int n2 = faceVertexIndices.size();
if (n2 == 0)
{
    throw GeoUtilsError(getErrorString(
        "Face vertex index vector is empty.", "getFaceDataByVertex"));
}
for (unsigned int i = 0; i < n0; i++)
{
    FaceData* cfd = FaceData::upcast(faceData->getVectorSet(i));
    if (cfd != 0)
    {
        unsigned int n1 = cfd->getNumVectors();
        /* <---- DEBUG ----- //
        std::cerr << "[Face::getFaceDataByVertex] DEBUG: "
            "number of source face data vectors = " << n1 << std::endl;
        // ----- DEBUG ----> */
        VectorVector v0;
        for (unsigned int k = 0; k < n2; k++)
        {
            unsigned int i0 = faceVertexIndices[k];
            if (i0 < n1)
            {
                Vector* cv0 = Ionflux::ObjectBase::nullPointerCheck(
                    cfd->getVector(i0), this, "getFaceDataByVertex", 
                        "Face data vector");
                v0.push_back(cv0->copy());
            } else
            {
                std::ostringstream status;
                status << "Invalid face vertex index: " << i0;
                throw GeoUtilsError(getErrorString(status.str(), 
                    "getFaceDataByVertex"));
            }
        }
        /* <---- DEBUG ----- //
        std::cerr << "[Face::getFaceDataByVertex] DEBUG: "
            "number of target face data vectors = " 
            << v0.size() << std::endl;
        // ----- DEBUG ----> */
        FaceData* nfd = FaceData::create(v0, cfd->getDataType());
        target.addVectorSet(nfd);
    }
}
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Polygon3*
	name = getPolygon
    shortDesc = Get polygon
	longDesc = Get a polygon corresponding to the (transformed) face. The polygon uses copies of the face vertices since polygons may be transformed individually.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "getPolygon", "Vertex source");
if (polygon != 0)
    return polygon;
polygon = Polygon3::create();
addLocalRef(polygon);
polygon->copyTransform(*vertexSource);
for (UIntVector::iterator i = vertices.begin(); i != vertices.end(); i++)
    polygon->addVertex(vertexSource->getVertex(*i)->copy());
polygon->createEdges();
if (useTransform())
    polygon->transform(*getTransformMatrix());
if (useVI())
    polygon->transformVI(*getViewMatrix(), getImageMatrix());
>>>
    return = {
        value = polygon
        desc = Polygon corresponding to the face
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkLineInner
	shortDesc = Check line intersection
	longDesc = Check whether the specified line intersects the object. Returns \c true if the line intersects the object, \c false otherwise.
    param[] = {
        type = const Ionflux::GeoUtils::Line3&
        name = line
        desc = Line
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
Polygon3* p = getPolygon();
bool result = line.intersectionInPoly(*p, t);
>>>
    return = {
        desc = Result of the test
        value = result
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkPlaneInner
	shortDesc = Check position relative to plane
	longDesc = Check the object position relative to a plane. Unlike checkPlane(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is above the plane (in direction of the normal of the plane), 0 if the object intersects the plane, and -1 if the object is below the plane.
    param[] = {
        type = const Ionflux::GeoUtils::Plane3&
        name = plane
        desc = Plane
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
Polygon3* p = getPolygon();
bool e0 = true;
int c0 = 0;
int c1 = 1;
for (unsigned int i = 0; i < p->getNumVertices(); i++)
{
    double d = p->getVertex(i)->distanceToPlane(plane);
    if (lt(d, 0., t))
        c1 = -1;
    else
    if (gt(d, 0., t))
        c1 = 1;
    else
        c1 = 0;
    if (e0)
    {
        // Initialize comparison value on first iteration.
        c0 = c1;
        e0 = false;
    }
    else 
    {
        /* If there are two vertices on opposite sides of the plane, 
           there is some intersection for this face. */
        if (c0 != c1)
            return 0;
    }
}
>>>
    return = {
        desc = Result of the test
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkSphereInner
	shortDesc = Check position relative to sphere
	longDesc = Check the object position relative to a sphere. Unlike checkSphere(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is inside the sphere, 0 if the object intersects the sphere, and -1 if the object is outside the sphere.
    param[] = {
        type = const Ionflux::GeoUtils::Sphere3&
        name = sphere
        desc = Sphere
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
Polygon3* p = getPolygon();
Plane3 pl0 = p->getPlane();
// Check planarity of the face.
double d0 = 0.;
for (unsigned int i = 0; i < p->getNumVertices(); i++)
{
    double d0 = p->getVertex(i)->distanceToPlane(pl0);
    if (!eq(d0, 0., t))
    {
        // Face is not planar, we have to stick with the bounding box.
        return checkSphere(sphere, t);
    }
}
// Polygon is planar.
Vertex3 sp = Vertex3(sphere.getP());
d0 = sp.distanceToPlane(pl0);
double sr = sphere.getR();
if (gt(d0, sr, t))
{
    /* Face is outside the sphere, since the minimum distance 
       between the face and the sphere center is greater than the 
       sphere radius. */
    return 1;
}
// There may be some intersection, check all vertices.
int c0 = 0;
int c1 = 0;
bool e0 = true;
for (unsigned int i = 0; i < p->getNumVertices(); i++)
{
    double d = (p->getVertex(i)->getVector() - sphere.getP()).norm();
    if (lt(d, sr, t))
        c1 = -1;
    else
    if (gt(d, sr, t))
        c1 = 1;
    else
        c1 = 0;
    if (e0)
    {
        // Initialize comparison value on first iteration.
        c0 = c1;
        e0 = false;
    }
    else 
    {
        /* If there are two vertices on opposite sides of the sphere, 
           there is some intersection for this face. */
        if (c0 != c1)
            return 0;
    }
}
>>>
    return = {
        desc = Result of the test
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkBoxInner
	shortDesc = Check box intersection
	longDesc = Check whether the specified box intersects the object. Unlike checkBox(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is inside the other box, 0 if the object intersects the other box, and -1 if the object is outside the other box.
    param[] = {
        type = const Ionflux::GeoUtils::BoxBoundsItem&
        name = other
        desc = Box bounds item
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
Polygon3* p = getPolygon();
if (!p->isPlanar())
    // Face is not planar, we have to stick with the bounding box.
    return checkBox(other, t);
// Polygon is planar.
Plane3 pl0 = p->getPlane();
Vertex3 bc = Vertex3(other.getCenter());
double d0 = bc.distanceToPlane(pl0);
double br = other.getRadius();
if (gt(d0, br, t))
{
    /* Face is outside the box, since the minimum distance 
       between the face and the box center is greater than the 
       radius of the bounding sphere of the box. */
    return 1;
}
// There may be some intersection, check all vertices.
int c0 = 0;
int c1 = 0;
bool e0 = true;
Range3 r0 = other.getBounds();
for (unsigned int i = 0; i < p->getNumVertices(); i++)
{
    Range3 r1(p->getVertex(i)->getVector());
    RangeCompResult rcs0 = r0.compare(r1, t);
    if (rcs0 == RANGE_FIRST_CONTAINS)
        c1 = -1;
    else
    if (rcs0 == RANGE_DISJOINT)
        c1 = 1;
    else
        c1 = 0;
    if (e0)
    {
        // Initialize comparison value on first iteration.
        c0 = c1;
        e0 = false;
    }
    else 
    {
        /* If there are two vertices on opposite sides of the box, 
           there is some intersection for this face. */
        if (c0 != c1)
            return 0;
    }
}
>>>
    return = {
        desc = Result of the comparison
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vertex3*
	const = true
	name = getVertexData
	shortDesc = Get vertex data
	longDesc = Get the vertex data for the face vertex with the specified index.
    impl = 
	param[] = {
		type = unsigned int
		name = index
		desc = Vertex index
	}
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "getVertexData", "Vertex source");
>>>
    return = {
        value = vertexSource->getVertex(getVertex(index));
        desc = Vertex data
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isPlanar
	shortDesc = Planar face check
	longDesc = Check whether the face is planar.
    impl = Polygon3* p = getPolygon();
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    return = {
        value = p->isPlanar(t)
        desc = \c true if the face is planar, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	const = true
	name = isEdge
	shortDesc = Edge check
	longDesc = Check whether the face is an edge.
    impl = <<<
if (vertices.size() == 2)
    return true;
>>>
    return = {
        value = false
        desc = \c true if the face is an edge, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	const = true
	name = isTri
	shortDesc = Triangle check
	longDesc = Check whether the face is a triangle.
    impl = <<<
if (vertices.size() == 3)
    return true;
>>>
    return = {
        value = false
        desc = \c true if the face is a triangle, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = isQuad
	const = true
	shortDesc = Quad check
	longDesc = Check whether the face is a quad.
    impl = <<<
if (vertices.size() == 4)
    return true;
>>>
    return = {
        value = false
        desc = \c true if the face is a quad, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getEdge
	const = true
	shortDesc = Get edge
	longDesc = Get the edge corresponding to the N-face. If the N-face is not an edge, an exception will be thrown.
	param[] = {
	    type = Ionflux::GeoUtils::Edge&
	    name = target
	    desc = where to store the edge
	}
    impl = <<<
if (!isEdge())
{
    throw GeoUtilsError(getErrorString(
        "N-face is not an edge.", "getEdge"));
}
target.setV0(getVertex(0));
target.setV1(getVertex(1));
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Edge
	name = getEdge0
	const = true
	shortDesc = Get edge
	longDesc = Get the edge corresponding to the N-face. If the N-face is not an edge, an exception will be thrown.
    impl = <<<
Edge e0;
getEdge(e0);
>>>
    return = {
        value = e0
        desc = Edge
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = applyVertexIndexOffset
	shortDesc = Apply vertex index offset
	longDesc = Apply an offset to all vertex indices.
	param[] = {
	    type = int
	    name = offset
	    desc = offset
	}
    impl = <<<
for (unsigned int i = 0; i < vertices.size(); i++)
{
    unsigned int cv = vertices[i];
    if ((offset < 0) 
        && (static_cast<unsigned int>(-offset) > cv))
        cv = 0;
    else
        cv += offset;
    vertices[i] = cv;
}
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getTris
	shortDesc = Get triangle faces
	longDesc = Create triangles for a triangle or quad N-face. The new faces are not referenced and must be managed by the caller.
	param[] = {
	    type = Ionflux::GeoUtils::NFaceVector&
	    name = target
	    desc = where to store the triangles
	}
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "getTris", "Vertex source");
if (isTri())
{
    target.push_back(copy());
    return;
}
if (!isQuad())
{
    throw GeoUtilsError(getErrorString(
        "N-face is not a quad.", "getTris"));
}
NFaceVector result;
UIntVector v0;
v0.push_back(vertices[0]);
v0.push_back(vertices[1]);
v0.push_back(vertices[2]);
UIntVector v1;
v1.push_back(vertices[0]);
v1.push_back(vertices[2]);
v1.push_back(vertices[3]);
UIntVector iv0;
iv0.push_back(0);
iv0.push_back(1);
iv0.push_back(2);
UIntVector iv1;
iv1.push_back(0);
iv1.push_back(2);
iv1.push_back(3);
NFace* f0 = NFace::create(&v0, vertexSource);
NFace* f1 = NFace::create(&v1, vertexSource);
if (faceData != 0)
{
    // copy face data
    VectorSetSet* nfd0 = VectorSetSet::create();
    VectorSetSet* nfd1 = VectorSetSet::create();
    getFaceDataByVertex(iv0, *nfd0);
    getFaceDataByVertex(iv1, *nfd1);
    f0->setFaceData(nfd0);
    f1->setFaceData(nfd1);
}
target.push_back(f0);
target.push_back(f1);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getTris
	shortDesc = Get triangle faces
	longDesc = Create triangles for a triangle or quad N-face. The new faces are not referenced and must be managed by the caller.
	param[] = {
	    type = Ionflux::GeoUtils::NFaceSet&
	    name = target
	    desc = where to store the triangles
	}
    impl = <<<
NFaceVector fv0;
getTris(fv0);
for (NFaceVector::iterator i = fv0.begin(); i!= fv0.end(); i++)
    target.addNFace(*i);
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::NFaceVector
	name = getTris0
	shortDesc = Get triangle faces
	longDesc = Create triangles for a triangle or quad N-face. The new faces are not referenced and must be managed by the caller.
    impl = <<<
NFaceVector result;
getTris(result);
>>>
    return = {
        desc = Vector containing triangle faces
        value = result
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getEdges
	shortDesc = Get edges
	longDesc = Create edges for a N-face. The new edges are not referenced and must be managed by the caller.
	param[] = {
	    type = Ionflux::GeoUtils::NFaceVector&
	    name = target
	    desc = where to store the edges
	}
	param[] = {
	    type = bool
	    name = copyFaceData
	    desc = copy corresponding face data to the new edges
	    default = true
	}
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "getEdges", "Vertex source");
unsigned int numVerts = getNumVertices();
UIntVector vv0;
for (unsigned int i = 0; i < numVerts; i++)
{
    unsigned int i1 = (i + 1) % numVerts;
    int vi0 = getVertex(i);
    int vi1 = getVertex(i1);
    NFace* e0 = NFace::create();
    e0->setVertexSource(vertexSource);
    e0->addVertices(vi0, vi1);
    if (copyFaceData && (faceData != 0))
    {
        // copy face data
        vv0.clear();
        Ionflux::ObjectBase::addValues(vv0, 2, i, i1);
        VectorSetSet* fd0 = VectorSetSet::create();
        getFaceDataByVertex(vv0, *fd0);
        e0->setFaceData(fd0);
    }
    target.push_back(e0);
}
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getEdges
	shortDesc = Get edges
	longDesc = Create edges for a N-Face.
	param[] = {
	    type = Ionflux::GeoUtils::NFaceSet&
	    name = target
	    desc = where to store the edges
	}
	param[] = {
	    type = bool
	    name = copyFaceData
	    desc = copy corresponding face data to the new edges
	    default = true
	}
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "getEdges", "Vertex source");
NFaceVector ev0;
getEdges(ev0, copyFaceData);
target.addNFaces(ev0);
>>>
}
function.public[] = {
	spec = virtual
	type = double
	name = getArea
	shortDesc = get area
	longDesc = Get the area of the N-face.
    impl = <<<
if (isEdge())
    return 0.;
if (isTri())
{
    Vector3 v0(getVertexData(0)->getVector());
    Vector3 v1(getVertexData(1)->getVector());
    Vector3 v2(getVertexData(2)->getVector());
    Vector3 e0(v1 - v0);
    Vector3 e1(v2 - v0);
    return 0.5 * e0.cross(e1).length();
}
double result = 0.;
NFaceVector tris0;
getTris(tris0);
for (NFaceVector::iterator i = tris0.begin(); i != tris0.end(); i++)
{
    NFace* nf0 = *i;
    result += nf0->getArea();
    delete nf0;
}
>>>
    return = {
        value = result
        desc = Area of the face
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator==
	const = true
	shortDesc = Comparison operator: equality
	longDesc = Compare equality.
	param[] = {
		type = const Ionflux::GeoUtils::NFace&
		name = other
		desc = Face
	}
    impl = <<<
if (vertices.size() != other.vertices.size()) 
    return false;
if (vertexSource != other.vertexSource)
    return false;
bool result = true;
unsigned int i = 0;
while (result 
    && (i < vertices.size()))
{
    if (vertices[i] != other.vertices[i])
        result = false;
    i++;
}
if ((faceData == 0) 
    && (other.faceData == 0))
    return result;
if ((faceData == 0) 
    && (other.faceData != 0))
    return false;
if ((faceData != 0) 
    && (other.faceData == 0))
    return false;
if (*faceData != *other.faceData)
    return false;
>>>
	return = {
        value = result
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator!=
	const = true
	shortDesc = Comparison operator: inequality
	longDesc = Compare inequality.
	param[] = {
		type = const Ionflux::GeoUtils::NFace&
		name = other
		desc = Face
	}
	return = {
        value = !(*this == other);
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getBarycenter
	shortDesc = Get barycenter
	longDesc = Get the barycenter vector for the face.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "getBarycenter", "Vertex source");
Polygon3* p0 = getPolygon();
Vector3 b0 = p0->getBarycenter();
>>>
    return = {
        value = b0
        desc = Barycenter vector
    }
}
function.protected[] = {
	spec = virtual
	type = void
	name = recalculateBounds
	shortDesc = Recalculate bounds
	longDesc = Recalculate the bounds for the face.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "recalculateBounds", "Vertex source");
TransformableObject::recalculateBounds();
Polygon3* p0 = getPolygon();
*boundsCache = p0->getBounds();
bounds = *boundsCache;
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Range3
	name = getBounds
	shortDesc = Get bounds
	longDesc = Get the bounds for the transformable object.
	impl = bounds = TransformableObject::getBounds();
    return = {
        value = bounds
        desc = Bounds
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = applyTransform
	shortDesc = Apply transformations
	longDesc = Apply transformations that have been accumulated in the transformation matrices.
	param[] = {
	    type = bool
	    name = recursive
	    desc = Apply transformations recursively
	    default = false
	}
    impl = <<<
log(IFLogMessage("Cannot apply transform to face "
    "(should be applied to vertex source instead).", VL_WARNING, 
    this, "applyTransform"));
clearTransformations();
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::NFace&
	name = scale
	shortDesc = Scale
	longDesc = Scale the object by the specified scale factors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = s
		desc = Vector of scale factors
	}
    impl = TransformableObject::scale(s);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::NFace&
	name = translate
	shortDesc = Translate
	longDesc = Translate the object by the specified vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = t
		desc = Translation vector
	}
    impl = TransformableObject::translate(t);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::NFace&
	name = rotate
	shortDesc = Rotate
	longDesc = Rotate the object by the specified angle around the specified axis.
	param[] = {
		type = double
		name = phi
		desc = Angle
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = axis
		desc = Axis
        default = Ionflux::GeoUtils::AXIS_Z
	}
    impl = TransformableObject::rotate(phi, axis);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::NFace&
	name = normalize
	shortDesc = Normalize
	longDesc = Normalize the object, i.e. scale to unit size.
    impl = TransformableObject::normalize();
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::NFace&
	name = center
	shortDesc = Center
	longDesc = Center the object using the specified method and origin vector.
	param[] = {
		type = Ionflux::GeoUtils::CenteringMethod
		name = method
		desc = Centering method
        default = Ionflux::GeoUtils::CENTER_BARYCENTER
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector3*
		name = origin
		desc = Origin or offset vector
        default = 0
	}
    impl = TransformableObject::center(method, origin);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::NFace&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix4&
		name = matrix
		desc = Transformation matrix
	}
    impl = <<<
log(IFLogMessage("Transforming face.", VL_WARNING, this, 
    "transform"));
TransformableObject::transform(matrix);
>>>
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::NFace&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = matrix
		desc = Transformation matrix
	}
    impl = TransformableObject::transform(matrix);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::NFace&
	name = duplicate
	shortDesc = Duplicate
	longDesc = Create an exact duplicate of the object. The duplicate is a new object which must be managed by the caller.
    impl = 
    return = {
        value = *copy()
        desc = The duplicated object
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object
	impl = <<<
std::ostringstream status;
bool e0 = true;
// vertices
status << "verts: ";
unsigned int numVerts = vertices.size();
if (numVerts > 0)
{
    status << "(";
    for (UIntVector::const_iterator i = vertices.begin(); 
        i != vertices.end(); i++)
    {
        if (!e0)
            status << ", ";
        else
            e0 = false;
        status << *i;
    }
    status << ")";
} else
    status << "<none>";
// face data
if (faceData != 0)
{
    status << "; faceData: [" 
        << faceData->getValueString() << "]";
}
// transformable object data
std::string ts0(TransformableObject::getValueString());
if (ts0.size() > 0)
    status << "; " << ts0;
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}

# Static member functions
function.public[] = {
	spec = static
	type = std::string
	name = getNFaceTypeIDString
	shortDesc = Get N-face type ID string
	longDesc = Get a string representation for an N-face type ID.
    param[] = {
        type = Ionflux::GeoUtils::NFaceTypeID
        name = typeID
        desc = N-face type ID
    }
    impl = <<<
if (typeID == TYPE_FACE)
    return "face";
if (typeID == TYPE_EDGE)
    return "edge";
>>>
    return = {
        value = "<unknown>"
        desc = String representation
    }
}

# Pure virtual member functions.

# operations

# Global functions.

