# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009-2013 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Mesh.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GeoUtils - Ionflux' Geometry Library; if not, write to the 
# Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
# 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
        '"geoutils/Face.hpp"'
        '"geoutils/FaceCompare.hpp"'
        '"geoutils/Polygon3Set.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '<fstream>'
        '<algorithm>'
        '"ifmapping/utils.hpp"'
        '"ifobject/utils.hpp"'
        '"ifobject/objectutils.hpp"'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/Vertex.hpp"'
        '"geoutils/Edge.hpp"'
        '"geoutils/NFaceSet.hpp"'
        '"geoutils/VectorSetSet.hpp"'
        '"geoutils/FaceCompareAxis.hpp"'
        '"geoutils/xmlutils.hpp"'
    }
}

# forward declarations
#forward = {
#}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Mesh
	shortDesc = Mesh
	title = Mesh
	longDesc = A mesh.
	group.name = geoutils
	base = {
		## base classes from the IFObject hierarchy
		#ifobject[] = {
		#	name = IFObject
		#}
        # other base classes
        other[] = {
			name = Ionflux::GeoUtils::BoxBoundsItem
            include = geoutils/BoxBoundsItem.hpp
            inheritanceType = virtual public
            hasClassInfo = true
		}
        other[] = {
			name = Ionflux::GeoUtils::ItemSource
            include = geoutils/ItemSource.hpp
            inheritanceType = virtual public
            hasClassInfo = true
		}
        other[] = {
			name = Ionflux::GeoUtils::TransformableObject
            include = geoutils/TransformableObject.hpp
            inheritanceType = virtual public
            hasClassInfo = true
            xml = {
                enabled = true
                #getFunc = getTransformableObject
                include = geoutils/TransformableObject
            }
		}
	}
    features = {
        'logmessage'
        'classinfo'
        'copy'
        'upcast'
        'create'
        'xmlio'
    }
    create = {
        allocationError = GeoUtilsError("Could not allocate object.")
        extendedCreate = true
    }
    xml.elementName = mesh
}

# Member variables.

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    type = Ionflux::GeoUtils::Vertex3Set*
    setFromType = Ionflux::GeoUtils::Vertex3Set*
    name = vertexSource
    desc = Vertex source
    managed = true
    valueType = object
    xml = {
        child = {
            name = vertex_source
            #elementName = vertex3set
        }
        #createFunc = createVertex3Set
    }
}
property.protected[] = {
    style = vector
    name = vertices
    desc = Vertex vector
    element = {
        type = Ionflux::GeoUtils::Vertex3*
        name = Vertex
        plural = Vertices
        #managed = true
        createExpr = Vertex3::create()
    }
    proxy = true
    proxy.target = vertexSource
    proxy.nullError = GeoUtilsError("Vertex source not set.")
    extendedAddFuncs = true
}
property.protected[] = {
    style = vector
    name = faces
    desc = Face vector
    element = {
        type = Ionflux::GeoUtils::Face*
        name = Face
        managed = true
        valueType = object
        createExpr = Face::create()
    }
    xml.child = {
        name = faces
        #elementName = faceset
        #getFunc = getFaceSet
    }
    extendedAddFuncs = true
}
property.protected[] = {
    style = vector
    name = edges
    desc = Edge vector
    element = {
        type = Ionflux::GeoUtils::NFace*
        name = Edge
        managed = true
        valueType = object
        createExpr = NFace::create()
    }
    xml.child = {
        name = edges
        #elementName = edgeset
        #getFunc = getEdgeSet
    }
    extendedAddFuncs = true
}

# Protected variables.

# Public static constants.
constant.public[] = {
    type = std::string
    name = DEFAULT_ID
    desc = Default ID
    value = "mesh01"
}
constant.public[] = {
    type = Ionflux::GeoUtils::MeshNFaceTypeID
    name = NFACE_TYPE_FACE
    desc = Mesh N-face type: face
    value = 0
}
constant.public[] = {
    type = Ionflux::GeoUtils::MeshNFaceTypeID
    name = NFACE_TYPE_EDGE
    desc = Mesh N-face type: edge
    value = 1
}

# Protected static constants.

# Public constructors.
constructor.copy.impl = *this = other;
constructor.default = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = vertexSource
        value = 0
    }
    impl = setVertexSource(Vertex3Set::create());
}
constructor.public[] = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = vertexSource
        value = 0
    }
    param[] = {
        name = initVerts
        type = Ionflux::GeoUtils::Vertex3Vector*
        desc = Vertex vector
    }
    param[] = {
        name = initFaces
        type = const Ionflux::GeoUtils::FaceVector*
        desc = Face vector
    }
    impl = setVertexSource(Vertex3Set::create());\
if (initVerts != 0)\
    addVertices(*initVerts);\
if (initFaces != 0)\
    addFaces(*initFaces);\
update();
}
constructor.public[] = {
    initializer[] = {
        name = Ionflux::GeoUtils::BoxBoundsItem
        value = Ionflux::GeoUtils::Vector3::ZERO, Ionflux::GeoUtils::Vector3::ZERO, ""
    }
    initializer[] = {
        name = vertexSource
        value = 0
    }
    param[] = {
        name = initVertexSource
        type = Ionflux::GeoUtils::Vertex3Set*
        desc = Vertex source
    }
    param[] = {
        name = initFaces
        type = const Ionflux::GeoUtils::FaceVector*
        desc = Face vector
    }
    impl = if (initVertexSource)\
    setVertexSource(initVertexSource);\
else\
    setVertexSource(Vertex3Set::create());\
if (initFaces != 0)\
    addFaces(*initFaces);\
update();
}

# Destructor.
#destructor.impl = 

# Protected member functions.
function.protected[] = {
	spec = virtual
	type = void
	name = recalculateBounds
	shortDesc = Recalculate bounds
	longDesc = Recalculate the bounds for the polygon set.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "recalculateBounds", "Vertex source");
TransformableObject::recalculateBounds();
if (!useTransform() && !useVI())
{
    *boundsCache = vertexSource->getBounds();
    bounds = *boundsCache;
    return;
}
// Adjust for transformation.
Mesh* m0 = copy();
addLocalRef(m0);
m0->applyTransform();
if (m0->useTransform())
    throw GeoUtilsError(getErrorString(
        "Transform matrix still in use after "
        "applying transformations.", "recalculateBounds"));
*boundsCache = m0->getBounds();
bounds = *boundsCache;
removeLocalRef(m0);
>>>
}

# Public member functions.
function.copy.impl = <<<
if (this == &other)
    return *this;
TransformableObject::operator=(other);
setVertexSource(other.vertexSource);
// faces
FaceVector f0;
for (FaceVector::const_iterator i = other.faces.begin(); 
    i != other.faces.end(); i++)
{
    Face* ft0 = Ionflux::ObjectBase::nullPointerCheck(*i, this, 
        "operator=", "Face");
    f0.push_back(ft0->copy());
}
clearFaces();
addFaces(f0);
// edges
NFaceVector ev0;
for (NFaceVector::const_iterator i = other.edges.begin(); 
    i != other.edges.end(); i++)
{
    NFace* e0 = Ionflux::ObjectBase::nullPointerCheck(*i, this, 
        "operator=", "Edge");
    ev0.push_back(e0->copy());
}
BoxBoundsItem::clear();
TransformableObject::clear();
update();
>>>
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Range3
	name = getBounds
	shortDesc = Get bounds
	longDesc = Get the bounds for the transformable object.
	impl = bounds = TransformableObject::getBounds();
    return = {
        value = bounds
        desc = Bounds
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = copyVertices
	shortDesc = Copy vertices
	longDesc = Create a new vertex set with copies of the current vertices. This makes the mesh the (current) single owner of its vertices.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "copyVertices", "Vertex source");
setVertexSource(vertexSource->copy());
}
function.public[] = {
	spec = virtual
	type = void
	name = update
	shortDesc = Update
	longDesc = Update all state according to the faces of the mesh.
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "update", "Vertex source");
// Determine the bounds.
recalculateBounds();
// update faces.
for (FaceVector::iterator i = faces.begin(); 
    i != faces.end(); i++)
{
    Face* f = *i;
    if (f->getVertexSource() == 0)
    {
        /* If the vertex source is not defined for the face, set it 
           to the vertex source of this mesh. */
        f->setVertexSource(vertexSource);
    }
    f->update();
}
// update edges.
for (NFaceVector::iterator i = edges.begin(); 
    i != edges.end(); i++)
{
    NFace* e = *i;
    if (e->getVertexSource() == 0)
    {
        /* If the vertex source is not defined for the edge, set it 
           to the vertex source of this mesh. */
        e->setVertexSource(vertexSource);
    }
    e->update();
}
updateRadiusAndCenter();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = clear
	shortDesc = Clear
	longDesc = Removes all items and resets state.
    impl = <<<
setVertexSource(0);
clearFaces();
clearEdges();
BoxBoundsItem::clear();
TransformableObject::clear();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = clearData
	shortDesc = Clear data
	longDesc = Clears the mesh data but keeps the vertex source.
    impl = <<<
if (vertexSource != 0)
    vertexSource->clearVertices();
clearFaces();
clearEdges();
BoxBoundsItem::clear();
TransformableObject::clear();
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = setFaceIDs
	shortDesc = Set face IDs
	longDesc = Set the item IDs of the faces. This is useful for saving and restoring the bounding box hierarchy, if one has been created.
    impl = <<<
std::ostringstream fid;
unsigned int k = 0;
for (FaceVector::const_iterator i = faces.begin(); 
    i != faces.end(); i++)
{
    fid.str("");
    fid << "face" << right << setfill('0') << setw(8) << k;
    (*i)->setItemID(fid.str());
    k++;
}
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = setEdgeIDs
	shortDesc = Set edge IDs
	longDesc = Set the item IDs of the edges. This is useful for saving and restoring the bounding box hierarchy, if one has been created.
    impl = <<<
std::ostringstream eid;
unsigned int k = 0;
for (NFaceVector::const_iterator i = edges.begin(); 
    i != edges.end(); i++)
{
    eid.str("");
    eid << "edge" << right << setfill('0') << setw(8) << k;
    (*i)->setItemID(eid.str());
    k++;
}
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::BoxBoundsItem*
	name = getItem
	shortDesc = Get item
	longDesc = Return the item with the specified ID. Throws an error if no valid BoxBoundsItem can be returned. The ItemSource class does not provide a usable implementation of this function, so it has to be provided in a derived class.
    param[] = {
        type = const std::string&
        name = itemID
        desc = Item ID
    }
    impl = <<<
if (itemID.size() < 4)
{
    std::ostringstream status;
    status << "Bad item ID for mesh: '" << itemID << "'";
    throw GeoUtilsError(getErrorString(status.str(), "getItem"));
}
std::string itemType = itemID.substr(0, 4);
if (itemType == "face")
{
    // face
    if (itemID.size() < 12)
    {
        std::ostringstream status;
        status << "Bad item ID for mesh: '" << itemID 
            << "' (itemType = " << itemType << ")";
        throw GeoUtilsError(getErrorString(status.str(), "getItem"));
    }
    size_t i0 = itemID.find_first_not_of("0", 4);
    unsigned int fi = 0;
    if (i0 != string::npos)
        fi = strtol(itemID.substr(i0).c_str(), 0, 10);
    if (fi >= faces.size())
    {
        std::ostringstream status;
        status << "Invalid face index: '" << itemID << "'";
        throw GeoUtilsError(getErrorString(status.str(), "getItem"));
    }
    return faces[fi];
} else
if (itemType == "edge")
{
    // edge
    if (itemID.size() < 12)
    {
        std::ostringstream status;
        status << "Bad item ID for mesh: '" << itemID 
            << "' (itemType = " << itemType << ")";
        throw GeoUtilsError(getErrorString(status.str(), "getItem"));
    }
    size_t i0 = itemID.find_first_not_of("0", 4);
    unsigned int ei = 0;
    if (i0 != string::npos)
        ei = strtol(itemID.substr(i0).c_str(), 0, 10);
    if (ei >= edges.size())
    {
        std::ostringstream status;
        status << "Invalid edge index: '" << itemID << "'";
        throw GeoUtilsError(getErrorString(status.str(), "getItem"));
    }
    return edges[ei];
} else
{
    std::ostringstream status;
    status << "Bad item type for mesh: '" << itemType << "'";
    throw GeoUtilsError(getErrorString(status.str(), "getItem"));
}
>>>
    return = {
        value = 0
        desc = Item with the specified ID, or 0 if no matching item exists
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::NFace*
	name = getNFace
	const = true
	shortDesc = Get N-face
	longDesc = Get the mesh N-face of the specified type with the specified index.
    param[] = {
        type = Ionflux::GeoUtils::MeshNFaceTypeID
        name = typeID
        desc = N-face type ID
    }
    param[] = {
        type = unsigned int
        name = index
        desc = index
    }
    impl = <<<
if (typeID == NFACE_TYPE_FACE)
    return getFace(index);
if (typeID == NFACE_TYPE_EDGE)
    return getEdge(index);
>>>
    return = {
        value = 0
        desc = N-face with the specified type and index, or 0 if no matching N-face exists
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = getNumNFaces
	const = true
	shortDesc = Get number of N-faces
	longDesc = Get the number of mesh N-faces of the specified type.
    param[] = {
        type = Ionflux::GeoUtils::MeshNFaceTypeID
        name = typeID
        desc = N-face type ID
    }
    impl = <<<
if (typeID == NFACE_TYPE_FACE)
    return getNumFaces();
if (typeID == NFACE_TYPE_EDGE)
    return getNumEdges();
>>>
    return = {
        value = 0
        desc = Number of N-faces of the specified type
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkPlaneInner
	shortDesc = Check position relative to plane
	longDesc = Check the object position relative to a plane. Unlike checkPlane(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is above the plane (in direction of the normal of the plane), 0 if the object intersects the plane, and -1 if the object is below the plane.
    param[] = {
        type = const Ionflux::GeoUtils::Plane3&
        name = plane
        desc = Plane
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
bool e0 = true;
int c0 = 0;
int c1 = 1;
for (FaceVector::const_iterator i = faces.begin(); 
    i != faces.end(); i++)
{
    c1 = (*i)->checkPlaneInner(plane, t);
    if (e0)
    {
        // Initialize comparison value on first iteration.
        c0 = c1;
        e0 = false;
    }
    else 
    {
        /* If there are two faces on opposite sides of the plane, 
           there is some intersection for this mesh. */
        if (c0 != c1)
            return 0;
    }
}
>>>
    return = {
        desc = Result of the test
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkSphereInner
	shortDesc = Check position relative to sphere
	longDesc = Check the object position relative to a sphere. Unlike checkSphere(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is inside the sphere, 0 if the object intersects the sphere, and -1 if the object is outside the sphere.
    param[] = {
        type = const Ionflux::GeoUtils::Sphere3&
        name = sphere
        desc = Sphere
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
bool e0 = true;
int c0 = 0;
int c1 = 1;
for (FaceVector::const_iterator i = faces.begin(); 
    i != faces.end(); i++)
{
    c1 = (*i)->checkSphereInner(sphere, t);
    if (e0)
    {
        // Initialize comparison value on first iteration.
        c0 = c1;
        e0 = false;
    }
    else 
    {
        /* If there are two faces on opposite sides of the sphere, 
           there is some intersection for this mesh. */
        if (c0 != c1)
            return 0;
    }
}
>>>
    return = {
        desc = Result of the test
        value = c0
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkLineInner
#    const = true
	shortDesc = Check line intersection
	longDesc = Check whether the specified line intersects the object. Unlike checkLine(), this function considers the inner structure of the object, not just its bounding box. Returns \c true if the line intersects the object, \c false otherwise.
    param[] = {
        type = const Ionflux::GeoUtils::Line3&
        name = line
        desc = Line
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
for (FaceVector::const_iterator i = faces.begin(); 
    i != faces.end(); i++)
{
    if((*i)->checkLineInner(line, t))
        return true;
}
>>>
    return = {
        desc = Result of the test
        value = false
    }
}
function.public[] = {
	spec = virtual
	type = int
	name = checkBoxInner
	shortDesc = Check box intersection.
	longDesc = Check whether the specified box intersects the object. Unlike checkBox(), this function considers the inner structure of the object, not just its bounding box. Returns 1 if the object is inside the other box, 0 if the object intersects the other box, and -1 if the object is outside the other box.
    param[] = {
        type = const Ionflux::GeoUtils::BoxBoundsItem&
        name = other
        desc = Box bounds item
    }
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = <<<
bool e0 = true;
int c0 = 0;
int c1 = 1;
for (FaceVector::const_iterator i = faces.begin(); 
    i != faces.end(); i++)
{
    c1 = (*i)->checkBoxInner(other, t);
    if (e0)
    {
        // Initialize comparison value on first iteration.
        c0 = c1;
        e0 = false;
    }
    else 
    {
        /* If there are two faces on opposite sides of the box, 
           there is some intersection for this mesh. */
        if (c0 != c1)
            return 0;
    }
}
>>>
    return = {
        desc = Result of the comparison
        value = checkBox(other, t)
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator==
	const = true
	shortDesc = Comparison operator: equality
	longDesc = Compare equality.
	param[] = {
		type = const Ionflux::GeoUtils::Mesh&
		name = other
		desc = Mesh
	}
    impl = <<<
if (faces.size() != other.faces.size())
    return false;
bool result = true;
// faces
unsigned int i = 0;
while (result 
    && (i < faces.size()))
{
    if (faces[i] != other.faces[i])
        result = false;
    i++;
}
if (!result)
    return false;
// edges
i = 0;
while (result 
    && (i < edges.size()))
{
    if (edges[i] != other.edges[i])
        result = false;
    i++;
}
if (!result)
    return false;
// vertices
if ((vertexSource == 0) && (other.vertexSource == 0))
    return true;
if ((vertexSource == 0) || (other.vertexSource == 0))
    return false;
unsigned int numVerts = getNumVertices();
if (numVerts != other.getNumVertices())
    return false;
i = 0;
while (result 
    && (i < numVerts))
{
    if ((*getVertex(i)) != (*other.getVertex(i)))
        result = false;
    i++;
}
if (!result)
    return false;
>>>
	return = {
        value = true
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator!=
	const = true
	shortDesc = Comparison operator: inequality
	longDesc = Compare inequality.
	param[] = {
		type = const Ionflux::GeoUtils::Mesh&
		name = other
		desc = Mesh
	}
	return = {
        value = !(*this == other);
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getBarycenter
	shortDesc = Get barycenter
	longDesc = Get the barycenter vector for the polygon.
	impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "getBarycenter", "Vertex source");
if (!useTransform())
    return vertexSource->getBarycenter();
// Adjust for transformation.
Vertex3 v0(vertexSource->getBarycenter());
if (useTransform())
    v0.transform(*getTransformMatrix());
if (useVI())
    v0.transformVI(*getViewMatrix(), getImageMatrix());
>>>
    return = {
        value = v0.getVector()
        desc = Barycenter vector
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = applyTransform
	shortDesc = Apply transformations
	longDesc = Apply transformations that have been accumulated in the transformation matrices.
	param[] = {
	    type = bool
	    name = recursive
	    desc = Apply transformations recursively
	    default = false
	}
    impl = <<<
Ionflux::ObjectBase::nullPointerCheck(vertexSource, this, 
    "applyTransform", "Vertex source");
if (!useTransform() && !useVI())
{
    if (recursive)
        vertexSource->applyTransform(recursive);
    clearTransformations();
    return;
}
Vertex3Set* vs0 = vertexSource;
addLocalRef(vs0);
copyVertices();
if (useTransform())
    vertexSource->transform(*getTransformMatrix());
if (useVI())
    vertexSource->transformVI(*getViewMatrix(), getImageMatrix());
if (useTransform() || useVI())
    vertexSource->applyTransform(recursive);
// update faces.
for (FaceVector::iterator i = faces.begin(); i != faces.end(); i++)
{
    // Update vertex source used by the faces.
    Face* f0 = *i;
    if (f0->getVertexSource() == vs0)
        f0->setVertexSource(vertexSource);
    // Clear face data dependent on transformation.
    f0->clearTangentSpace();
    f0->clearPolygon();
}
// update edges
for (NFaceVector::iterator i = edges.begin(); i != edges.end(); i++)
{
    // Update vertex source used by the edges.
    NFace* e0 = *i;
    if (e0->getVertexSource() == vs0)
        e0->setVertexSource(vertexSource);
    // Clear edge data dependent on transformation.
    e0->clearPolygon();
}
removeLocalRef(vs0);
clearTransformations();
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Mesh&
	name = scale
	shortDesc = Scale
	longDesc = Scale the object by the specified scale factors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = s
		desc = Vector of scale factors
	}
    impl = TransformableObject::scale(s);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Mesh&
	name = translate
	shortDesc = Translate
	longDesc = Translate the object by the specified vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = t
		desc = Translation vector
	}
    impl = TransformableObject::translate(t);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Mesh&
	name = rotate
	shortDesc = Rotate
	longDesc = Rotate the object by the specified angle around the specified axis.
	param[] = {
		type = double
		name = phi
		desc = Angle
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = axis
		desc = Axis
        default = Ionflux::GeoUtils::AXIS_Z
	}
    impl = TransformableObject::rotate(phi, axis);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Mesh&
	name = swapAxes
	shortDesc = Swap axes
	longDesc = Swap axes.
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = x
		desc = Axis (x)
        default = Ionflux::GeoUtils::AXIS_X
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = y
		desc = Axis (y)
        default = Ionflux::GeoUtils::AXIS_Y
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = z
		desc = Axis (z)
        default = Ionflux::GeoUtils::AXIS_Z
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = w
		desc = Axis (w)
        default = Ionflux::GeoUtils::AXIS_W
	}
    impl = TransformableObject::swapAxes(x, y, z, w);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Mesh&
	name = normalize
	shortDesc = Normalize
	longDesc = Normalize the object, i.e. scale to unit size.
    impl = TransformableObject::normalize();
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Mesh&
	name = center
	shortDesc = Center
	longDesc = Center the object using the specified method and origin vector.
	param[] = {
		type = Ionflux::GeoUtils::CenteringMethod
		name = method
		desc = Centering method
        default = Ionflux::GeoUtils::CENTER_BARYCENTER
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector3*
		name = origin
		desc = Origin or offset vector
        default = 0
	}
    impl = TransformableObject::center(method, origin);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Mesh&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix4&
		name = matrix
		desc = Transformation matrix
	}
    impl = TransformableObject::transform(matrix);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Mesh&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = matrix
		desc = Transformation matrix
	}
    impl = TransformableObject::transform(matrix);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Mesh&
	name = duplicate
	shortDesc = Duplicate
	longDesc = Create an exact duplicate of the object. The duplicate is a new object which must be managed by the caller.
    impl = 
    return = {
        value = *copy()
        desc = The duplicated object
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getFacePolygons
	shortDesc = Get face polygons
	longDesc = Get the face polygons of the (transformed) mesh.
	param[] = {
		type = Ionflux::GeoUtils::Polygon3Set&
		name = target
		desc = Where to store the polygons
	}
	impl = <<<
Polygon3Set* ps0 = 0;
bool t0 = false;
if (useTransform() || useVI())
{
    /* Use a temporary polygon set to transform the polygons 
       according to the mesh transformations. */
    ps0 = Polygon3Set::create();
    ps0->copyTransform(*this);
    t0 = true;
} else
    ps0 = &target;
for (FaceVector::iterator i = faces.begin(); 
    i != faces.end(); i++)
{
    // Add face polygons to the target or temporary set.
    Face* f0 = *i;
    ps0->addPolygon(f0->getPolygon());
}
if (t0)
{
    /* Transform polygons in the temporary set, then add them to 
       the target set. */
    ps0->applyTransform();
    target.addPolygons(ps0);
    delete ps0;
}
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getEdgePolygons
	shortDesc = Get edge polygons
	longDesc = Get the edge polygons of the (transformed) mesh.
	param[] = {
		type = Ionflux::GeoUtils::Polygon3Set&
		name = target
		desc = Where to store the polygons
	}
	impl = <<<
Polygon3Set* ps0 = 0;
bool t0 = false;
if (useTransform() || useVI())
{
    /* Use a temporary polygon set to transform the polygons 
       according to the mesh transformations. */
    ps0 = Polygon3Set::create();
    ps0->copyTransform(*this);
    t0 = true;
} else
    ps0 = &target;
for (NFaceVector::iterator i = edges.begin(); 
    i != edges.end(); i++)
{
    // Add edge polygons to the target or temporary set.
    NFace* e0 = *i;
    ps0->addPolygon(e0->getPolygon());
}
if (t0)
{
    /* Transform polygons in the temporary set, then add them to 
       the target set. */
    ps0->applyTransform();
    target.addPolygons(ps0);
    delete ps0;
}
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = removeBackfaces
	shortDesc = Remove backfaces
	longDesc = Remove faces that face backward relative to the specified front vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = front
		desc = Front vector
	}
	impl = <<<
FaceVector keepFaces;
for (FaceVector::iterator i = faces.begin(); i != faces.end(); i++)
{
    Face* f0 = *i;
    if (!f0->isBackface(front))
    {
        keepFaces.push_back(f0);
        addLocalRef(f0);
    }
}
clearFaces();
addFaces(keepFaces);
for (FaceVector::iterator i = keepFaces.begin(); 
    i != keepFaces.end(); i++)
    removeLocalRef(*i);
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = sortFaces
	shortDesc = Sort faces
	longDesc = Sort faces in the set. If no comparison function is specified, faces are sorted according to the Z-axis order of their barycenters. \c compFunc will be managed by a temporary object so it is possible to create a new instance of a comparison function within the call.
	param[] = {
	    type = Ionflux::GeoUtils::FaceCompare*
	    name = compFunc
	    desc = Comparison function
	    default = 0
	}
    impl = FaceCompare wrap0;\
if (compFunc == 0)\
    wrap0.setTarget(FaceCompareAxis::create(AXIS_Z));\
else\
    wrap0.setTarget(compFunc);\
::sort(faces.begin(), faces.end(), wrap0);
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = makePlanar
	shortDesc = Make faces planar
	longDesc = Make the faces with the specified indices planar. If the optional parameter is specified, vertices will be moved only by the specified fraction of the offset required to make the face planar.
	param[] = {
	    type = const Ionflux::ObjectBase::UIntVector&
	    name = indices
	    desc = face indices
	}
	param[] = {
	    type = unsigned int
	    name = maxIterations
	    desc = maximum number of iterations
	    default = 10000
	}
	param[] = {
	    type = double
	    name = p
	    desc = Parameter
	    default = 1.
	}
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = unsigned int numFaces = faces.size();\
unsigned int numIndices = indices.size();\
if (numIndices > numFaces)\
    throw GeoUtilsError("[Mesh::makePlanar] "\
        "Too many face indices specified.");\
unsigned int nonPlanar = numIndices;\
unsigned int i = 0;\
while ((i < maxIterations) && (nonPlanar > 0))\
\{\
    unsigned int k = indices[\
        Ionflux::Mapping::getRandomInt() % numIndices];\
    Face* f0 = getFace(k);\
    if (f0 == 0)\
    \{\
        std::ostringstream status;\
        status << "[Mesh::makePlanar] "\
            "Face index out of range: " << k;\
        throw GeoUtilsError(status.str());\
    \}\
    f0->makePlanar(p, t);\
    nonPlanar = 0;\
    for(unsigned int j = 0; j < numIndices; j++)\
    \{\
        f0 = getFace(indices[j]);\
        f0->update();\
        if (!f0->isPlanar(t))\
            nonPlanar++;\
    \}\
    i++;\
\}\
/* <---- DEBUG ----- //\
std::cerr << "[Mesh::makePlanar] DEBUG: "\
    "Non-planar faces after " << i << " iterations: " << nonPlanar \
    << std::endl;\
// <---- DEBUG ----- */\
update();
    return = {
        value = nonPlanar
        desc = number of non-planar faces remaining
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = makeTris
	shortDesc = Make triangle faces
	longDesc = Convert all faces in the mesh to triangles, creating new faces as necessary. Existing triangle faces will not be changed.
    impl = <<<
unsigned int numFaces = getNumFaces();
unsigned int ntCount = 0;
Mesh m0;
FaceVector nfv;
for (unsigned int i = 0; i < numFaces; i++)
{
    Face* cf = getFace(i);
    if (cf != 0)
    {
        if (cf->isTri())
        {
            // keep existing tri face
            m0.addFace(cf);
        } else
        {
            // not a tri face
            nfv.clear();
            cf->getTris(nfv);
            m0.addFaces(nfv);
            ntCount++;
        }
    }
}
if (ntCount > 0)
{
    clearFaces();
    addFaces(m0.getFaces());
}
>>>
    return = {
        value = ntCount
        desc = Number of new faces that were generated
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setFaceVertexNormals
	shortDesc = Set face vertex normals
	longDesc = Set the vertex normals for all faces to the face normal.
    impl = <<<
unsigned int numFaces = getNumFaces();
for (unsigned int i = 0; i < numFaces; i++)
{
    Face* cf = getFace(i);
    if (cf != 0)
        cf->setFaceVertexNormals();
}
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = setFaceVertexColors
	shortDesc = Set face vertex colors
	longDesc = Set the vertex colors for all faces to the specified color vector.
	param[] = {
	    type = const Ionflux::GeoUtils::Vector4&
	    name = color
	    desc = color vector
	}
    impl = <<<
unsigned int numFaces = getNumFaces();
for (unsigned int i = 0; i < numFaces; i++)
{
    Face* cf = getFace(i);
    if (cf != 0)
        cf->setVertexColors(color);
}
>>>
}
function.public[] = {
	spec = virtual
	type = bool
	const = true
	name = isTriMesh
	shortDesc = Triangle mesh check
	longDesc = Check whether all faces of the mesh are triangles.
    impl = <<<
unsigned int numFaces = getNumFaces();
FaceVector nfv;
unsigned int i = 0;
while (i < numFaces)
{
    Face* cf = getFace(i);
    if (cf != 0)
    {
        if (!cf->isTri())
            return false;
    }
    i++;
}
>>>
    return = {
        value = true
        desc = \c true if the mesh is a triangle mesh, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = unsigned int
	name = createEdges
	shortDesc = Create edges
	longDesc = Create the unique edges defined by the mesh faces and add them to the mesh. Any existing edges will be cleared.
    impl = <<<
unsigned int numFaces = getNumFaces();
unsigned int neCount = 0;
NFaceSet nes;
NFaceSet ces;
EdgeObjSet es0;
for (unsigned int i = 0; i < numFaces; i++)
{
    Face* cf = getFace(i);
    if (cf != 0)
    {
        ces.clearNFaces();
        cf->getEdges(ces, true);
        for (unsigned int k = 0; k < ces.getNumNFaces(); k++)
        {
            NFace* ce0 = Ionflux::ObjectBase::nullPointerCheck(
                ces.getNFace(k), this, "createEdges", "Edge");
            Edge ce1;
            ce0->getEdge(ce1);
            ce1.sort();
            /* <---- DEBUG ----- //
            std::cerr << "[Mesh::createEdges] DEBUG: "
                "N-face: [" << ce0->getValueString() 
                << "], edge: [" << ce1.getValueString() << "]" 
                << std::endl;
            // ----- DEBUG ----> */
            if (es0.count(ce1) == 0)
            {
                // <---- DEBUG ----- //
                std::cerr << "[Mesh::createEdges] DEBUG: "
                    "adding edge: [" << ce0->getValueString() 
                    << "]" << std::endl;
                // ----- DEBUG ----> */
                // new edge
                es0.insert(ce1);
                nes.addNFace(ce0);
                neCount++;
            } else 
            {
                /* <---- DEBUG ----- //
                std::cerr << "[Mesh::createEdges] DEBUG: "
                    "not adding edge to new edge set" 
                    << std::endl;
                // ----- DEBUG ----> */
            }
        }
    }
}
if (neCount > 0)
{
    clearEdges();
    addEdges(nes.getNFaces());
}
>>>
    return = {
        value = neCount
        desc = Number of new edges that were generated
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = merge
	shortDesc = Merge
	longDesc = Merge another mesh into the mesh.
	param[] = {
	    type = const Ionflux::GeoUtils::Mesh&
	    name = other
	    desc = mesh
	}
    impl = <<<
unsigned int numVerts0 = getNumVertices();
unsigned int numVerts1 = other.getNumVertices();
// vertices
for (unsigned int i = 0; i < numVerts1; i++)
{
    Vertex3* cv0 = Ionflux::ObjectBase::nullPointerCheck(
        other.getVertex(i), this, "merge", "Source mesh vertex");
    addVertex(cv0->copy());
}
// faces
unsigned int numFaces1 = other.getNumFaces();
for (unsigned int i = 0; i < numFaces1; i++)
{
    Face* cf0 = Ionflux::ObjectBase::nullPointerCheck(
        other.getFace(i), this, "merge", "Source mesh face");
    Face* nf0 = cf0->copy();
    nf0->applyVertexIndexOffset(numVerts0);
}
// edges
unsigned int numEdges1 = other.getNumEdges();
for (unsigned int i = 0; i < numEdges1; i++)
{
    NFace* ce0 = Ionflux::ObjectBase::nullPointerCheck(
        other.getEdge(i), this, "merge", "Source mesh edge");
    NFace* ne0 = ce0->copy();
    ne0->applyVertexIndexOffset(numVerts0);
}
update();
>>>
}

# public member functions overridden from IFObject
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation of value
	longDesc = Get a string representation of the value of the object.
	impl = <<<
std::ostringstream status;
// vertices
status << "verts: ";
if (vertexSource != 0)
{
    unsigned int numVerts = vertexSource->getNumVertices();
    if (numVerts > 0)
    {
        status << "[";
        bool e0 = true;
        for (unsigned int i = 0; i < numVerts; i++)
        {
            Vertex3* v0 = vertexSource->getVertex(i);
            if (!e0)
                status << ", ";
            else
                e0 = false;
            status << "(" << v0->getValueString() << ")";
        }
        status << "]";
    } else
        status << "<none>";
} else
    status << "<none>";
// faces
status << "; faces: ";
unsigned int numFaces = faces.size();
if (numFaces > 0)
{
    status << "[";
    bool e0 = true;
    for (FaceVector::const_iterator i = faces.begin(); 
        i != faces.end(); i++)
    {
        Face* f0 = *i;
        if (!e0)
            status << ", ";
        else
            e0 = false;
        status << "[" << f0->getValueString() << "]";
    }
    status << "]";
} else
    status << "<none>";
// edges
status << "; edges: ";
unsigned int numEdges = edges.size();
if (numEdges > 0)
{
    status << "[";
    bool ef0 = true;
    for (NFaceVector::const_iterator i = edges.begin(); 
        i != edges.end(); i++)
    {
        NFace* e0 = *i;
        if (!ef0)
            status << ", ";
        else
            ef0 = false;
        status << "[" << e0->getValueString() << "]";
    }
    status << "]";
} else
    status << "<none>";
// transformable object data
std::string ts0(TransformableObject::getValueString());
if (ts0.size() > 0)
    status << "; " << ts0;
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}

# static member functions
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Mesh*
	name = plane
	shortDesc = Create mesh: plane
	longDesc = Create a plane mesh.
    impl = Mesh* m0 = create();\
double s = 0.5;\
// Vertices.\
Vertex3Vector verts0;\
verts0.push_back(Vertex::create(-s, -s, 0));\
verts0.push_back(Vertex::create(-s, s, 0));\
verts0.push_back(Vertex::create(s, s, 0));\
verts0.push_back(Vertex::create(s, -s, 0));\
m0->addVertices(verts0);\
// Faces.\
FaceVector faces0;\
faces0.push_back(Face::create(0, 1, 2, 3, m0->getVertexSource()));\
m0->addFaces(faces0);\
m0->update();
    return = {
        value = m0
        desc = Plane mesh
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Mesh*
	name = cube
	shortDesc = Create mesh: cube
	longDesc = Create a cube mesh.
    impl = <<<
Mesh* m0 = create();
double s = 0.5;
// Vertices.
Vertex3Vector verts0;
verts0.push_back(Vertex::create(-s, -s, -s));
verts0.push_back(Vertex::create(-s, s, -s));
verts0.push_back(Vertex::create(s, s, -s));
verts0.push_back(Vertex::create(s, -s, -s));
verts0.push_back(Vertex::create(s, -s, s));
verts0.push_back(Vertex::create(s, s, s));
verts0.push_back(Vertex::create(-s, s, s));
verts0.push_back(Vertex::create(-s, -s, s));
m0->addVertices(verts0);
// Faces.
/* <---- DEBUG ----- //
std::cerr << "[Mesh::cube] DEBUG: "
    << "Adding faces..." << std::endl;
// <---- DEBUG ----- */
FaceVector faces0;
faces0.push_back(Face::create(0, 3, 4, 7, m0->getVertexSource()));
faces0.push_back(Face::create(3, 2, 5, 4, m0->getVertexSource()));
faces0.push_back(Face::create(1, 6, 5, 2, m0->getVertexSource()));
faces0.push_back(Face::create(0, 7, 6, 1, m0->getVertexSource()));
faces0.push_back(Face::create(4, 5, 6, 7, m0->getVertexSource()));
faces0.push_back(Face::create(0, 1, 2, 3, m0->getVertexSource()));
m0->addFaces(faces0);
/* <---- DEBUG ----- //
std::cerr << "[Mesh::cube] DEBUG: "
    << "Updating mesh..." << std::endl;
// <---- DEBUG ----- */
m0->update();
>>>
    return = {
        value = m0
        desc = Cube mesh
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Mesh*
	name = cylinder
	shortDesc = Create mesh: cylinder
	longDesc = Create a cylinder mesh.
	param[] = {
	    type = unsigned int
	    name = subDivs
	    desc = Angular subdivisions
	    default = 10
	}
	param[] = {
	    type = double
	    name = length
	    desc = Length
	    default = 1.
	}
	param[] = {
	    type = double
	    name = radius
	    desc = Radius
	    default = 0.5
	}
    impl = Mesh* m0 = create();\
double s = 0.5 * length;\
// Vertices.\
Vertex3Vector verts0;\
double dPhi = 2. * M_PI / subDivs;\
// Hull vertices.\
for (unsigned int i = 0; i < subDivs; i++)\
\{\
    double x = radius * ::sin(i * dPhi);\
    double y = radius * ::cos(i * dPhi);\
    verts0.push_back(Vertex::create(x, y, s));\
    verts0.push_back(Vertex::create(x, y, -s));\
\}\
// Center vertices.\
verts0.push_back(Vertex::create(0., 0., s));\
verts0.push_back(Vertex::create(0., 0., -s));\
m0->addVertices(verts0);\
// Faces.\
FaceVector faces0;\
// Hull faces.\
for (unsigned int i = 0; i < subDivs; i++)\
\{\
    if (i < (subDivs - 1))\
        faces0.push_back(Face::create(\
            2 * i, 2 * i + 2, 2 * i + 3, 2 * i + 1, \
            m0->getVertexSource()));\
    else\
        faces0.push_back(Face::create(\
            2 * i, 0, 1, 2 * i + 1, \
            m0->getVertexSource()));\
\}\
// Top faces.\
unsigned int i0 = verts0.size() - 2;\
for (unsigned int i = 0; i < subDivs; i++)\
\{\
    if (i < (subDivs - 1))\
        faces0.push_back(Face::create(\
            i0, 2 * i + 2, 2 * i, Face::VERTEX_INDEX_NONE, \
            m0->getVertexSource()));\
    else\
        faces0.push_back(Face::create(\
            i0, 0, 2 * i, Face::VERTEX_INDEX_NONE, \
            m0->getVertexSource()));\
\}\
// Bottom faces.\
i0 = verts0.size() - 1;\
for (unsigned int i = 0; i < subDivs; i++)\
\{\
    if (i < (subDivs - 1))\
        faces0.push_back(Face::create(\
            i0, 2 * i + 1, 2 * i + 3, Face::VERTEX_INDEX_NONE, \
            m0->getVertexSource()));\
    else\
        faces0.push_back(Face::create(\
            i0, 2 * i + 1, 1, Face::VERTEX_INDEX_NONE, \
            m0->getVertexSource()));\
\}\
m0->addFaces(faces0);\
m0->update();
    return = {
        value = m0
        desc = Cylinder mesh
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Mesh*
	name = arrow
	shortDesc = Create mesh: arrow
	longDesc = Create an arrow mesh.
	param[] = {
	    type = unsigned int
	    name = subDivs
	    desc = Angular subdivisions
	    default = 10
	}
	param[] = {
	    type = double
	    name = length
	    desc = Length
	    default = 1.
	}
	param[] = {
	    type = double
	    name = radius
	    desc = Radius
	    default = 0.005
	}
	param[] = {
	    type = double
	    name = headLength
	    desc = Head length (relative to length)
	    default = 0.1
	}
	param[] = {
	    type = double
	    name = headRadius
	    desc = Head radius (relative to radius)
	    default = 4.
	}
    impl = <<<
Mesh* m0 = create();
// Vertices.
Vertex3Vector verts0;
double dPhi = 2. * M_PI / subDivs;
// Hull vertices.
for (unsigned int i = 0; i < subDivs; i++)
{
    double x = radius * ::sin(i * dPhi);
    double y = radius * ::cos(i * dPhi);
    verts0.push_back(Vertex::create(x * headRadius, y * headRadius, 
        (0.5 - headLength) * length));
    verts0.push_back(Vertex::create(x, y, 
        (0.5 - headLength) * length));
    verts0.push_back(Vertex::create(x, y, -0.5 * length));
}
// Center vertices.
verts0.push_back(Vertex::create(0., 0., 0.5 * length));
verts0.push_back(Vertex::create(0., 0., -0.5 * length));
m0->addVertices(verts0);
// Faces.
FaceVector faces0;
// Hull faces.
for (unsigned int i = 0; i < subDivs; i++)
{
    if (i < (subDivs - 1))
    {
        faces0.push_back(Face::create(
            3 * i, 3 * i + 3, 3 * i + 4, 3 * i + 1, 
            m0->getVertexSource()));
        faces0.push_back(Face::create(
            3 * i + 1, 3 * i + 4, 3 * i + 5, 3 * i + 2, 
            m0->getVertexSource()));
    } else
    {
        faces0.push_back(Face::create(
            3 * i, 0, 1, 3 * i + 1, 
            m0->getVertexSource()));
        faces0.push_back(Face::create(
            3 * i + 1, 1, 2, 3 * i + 2, 
            m0->getVertexSource()));
    }
}
// Top faces.
unsigned int i0 = verts0.size() - 2;
for (unsigned int i = 0; i < subDivs; i++)
{
    if (i < (subDivs - 1))
        faces0.push_back(Face::create(
            i0, 3 * i + 3, 3 * i, Face::VERTEX_INDEX_NONE, 
            m0->getVertexSource()));
    else
        faces0.push_back(Face::create(
            i0, 0, 3 * i, Face::VERTEX_INDEX_NONE, 
            m0->getVertexSource()));
}
// Bottom faces.
i0 = verts0.size() - 1;
for (unsigned int i = 0; i < subDivs; i++)
{
    if (i < (subDivs - 1))
        faces0.push_back(Face::create(
            i0, 3 * i + 2, 3 * i + 5, Face::VERTEX_INDEX_NONE, 
            m0->getVertexSource()));
    else
        faces0.push_back(Face::create(
            i0, 3 * i + 2, 2, Face::VERTEX_INDEX_NONE, 
            m0->getVertexSource()));
}
m0->addFaces(faces0);
m0->update();
>>>
    return = {
        value = m0
        desc = Arrow mesh
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Mesh*
	name = grid
	shortDesc = Create mesh: grid
	longDesc = Create a planar grid mesh.
	param[] = {
	    type = unsigned int
	    name = subDivsX
	    desc = subdivisions (x)
	    default = 10
	}
	param[] = {
	    type = unsigned int
	    name = subDivsY
	    desc = subdivisions (y)
	    default = 10
	}
    impl = <<<
if (subDivsX < 1)
{
    std::ostringstream status;
    status << "[Mesh::grid] "
        "Subdivisions (X) must be at least 1.";
    throw GeoUtilsError(status.str());
}
if (subDivsY < 1)
{
    std::ostringstream status;
    status << "[Mesh::grid] "
        "Subdivisions (Y) must be at least 1.";
    throw GeoUtilsError(status.str());
}
Mesh* m0 = create();
double s = 0.5;
// Vertices.
Vertex3Vector verts0;
double dx = 2. * s / subDivsX;
double dy = 2. * s / subDivsY;
for (unsigned int i = 0; i <= subDivsY; i++)
{
    for (unsigned int j = 0; j <= subDivsX; j++)
    {
        verts0.push_back(Vertex::create(-s + j * dx, 
            -s + i * dy, 0));
    }
}
m0->addVertices(verts0);
// Faces.
FaceVector faces0;
for (unsigned int i = 0; i < subDivsY; i++)
{
    for (unsigned int j = 0; j < subDivsX; j++)
    {
        faces0.push_back(Face::create(
            (j + 1) + i * (subDivsX + 1), 
            (j + 1) + (i + 1) * (subDivsX + 1), 
            j + (i + 1) * (subDivsX + 1), 
            j + i * (subDivsX + 1), 
            /*
            j + i * (subDivsX + 1), 
            j + (i + 1) * (subDivsX + 1), 
            (j + 1) + (i + 1) * (subDivsX + 1), 
            (j + 1) + i * (subDivsX + 1), 
            */
            m0->getVertexSource()));
    }
}
m0->addFaces(faces0);
m0->update();
>>>
    return = {
        value = m0
        desc = Grid mesh
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Mesh*
	name = fiber
	shortDesc = Create mesh: fiber
	longDesc = Create a fiber mesh.
	param[] = {
	    type = unsigned int
	    name = aSubDivs
	    desc = Angular subdivisions
	    default = 10
	}
	param[] = {
	    type = unsigned int
	    name = lSubDivs
	    desc = Length subdivisions
	    default = 10
	}
	param[] = {
	    type = double
	    name = length
	    desc = Length
	    default = 1.
	}
	param[] = {
	    type = double
	    name = radius
	    desc = Radius
	    default = 0.05
	}
    impl = <<<
Mesh* m0 = create();
double s = 0.5 * length;
// Vertices.
Vertex3Vector verts0;
double dPhi = 2. * M_PI / aSubDivs;
double ds = length / lSubDivs;
// Bottom center vertex.
verts0.push_back(Vertex::create(0., 0., -s));
// Hull vertices.
for (unsigned int i = 0; i <= lSubDivs; i++)
{
    double z = -s + i * ds;
    for (unsigned int j = 0; j < aSubDivs; j++)
    {
        double x = radius * ::sin(j * dPhi);
        double y = radius * ::cos(j * dPhi);
        verts0.push_back(Vertex::create(x, y, z));
    }
}
// Top center vertex.
verts0.push_back(Vertex::create(0., 0., s));
m0->addVertices(verts0);
// Faces.
FaceVector faces0;
// Hull faces.
for (unsigned int i = 0; i < lSubDivs; i++)
{
    for (unsigned int j = 0; j < aSubDivs; j++)
    {
        if (j < (aSubDivs - 1))
            faces0.push_back(Face::create(
                1 + i * aSubDivs + j, 
                1 + (i + 1) * aSubDivs + j, 
                1 + (i + 1) * aSubDivs + j + 1, 
                1 + i * aSubDivs + j + 1, 
                m0->getVertexSource()));
        else
            faces0.push_back(Face::create(
                1 + i * aSubDivs + j, 
                1 + (i + 1) * aSubDivs + j, 
                1 + (i + 1) * aSubDivs, 
                1 + i * aSubDivs, 
                m0->getVertexSource()));
    }
}
// Bottom faces.
unsigned int i0 = 0;
for (unsigned int i = 0; i < aSubDivs; i++)
{
    if (i < (aSubDivs - 1))
        faces0.push_back(Face::create(
            i0, i + 1, i + 2, Face::VERTEX_INDEX_NONE, 
            m0->getVertexSource()));
    else
        faces0.push_back(Face::create(
            i0, i + 1, 1, Face::VERTEX_INDEX_NONE, 
            m0->getVertexSource()));
}
// Top faces.
i0 = verts0.size() - 1;
unsigned int k0 = aSubDivs * lSubDivs;
for (unsigned int i = 0; i < aSubDivs; i++)
{
    if (i < (aSubDivs - 1))
        faces0.push_back(Face::create(
            i0, k0 + i + 2, k0 + i + 1, Face::VERTEX_INDEX_NONE, 
            m0->getVertexSource()));
    else
        faces0.push_back(Face::create(
            i0, k0 + 1, k0 + i + 1, Face::VERTEX_INDEX_NONE, 
            m0->getVertexSource()));
}
m0->addFaces(faces0);
m0->update();
>>>
    return = {
        value = m0
        desc = Fiber mesh
    }
}
function.public[] = {
	spec = static
	type = std::string
	name = getNFaceTypeIDString
	shortDesc = Get N-face type ID string
	longDesc = Get a string representation for an N-face type ID.
    param[] = {
        type = Ionflux::GeoUtils::MeshNFaceTypeID
        name = typeID
        desc = N-face type ID
    }
    impl = <<<
if (typeID == NFACE_TYPE_FACE)
    return "face";
if (typeID == NFACE_TYPE_EDGE)
    return "edge";
>>>
    return = {
        value = "<unknown>"
        desc = String representation
    }
}

# Pure virtual member functions.

# operations

# Global functions.

