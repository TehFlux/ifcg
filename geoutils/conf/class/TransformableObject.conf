# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2010-2013 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# TransformableObject.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GeoUtils - Ionflux' Geometry Library; if not, write to the 
# Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
# 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/Range3.hpp"'
        '"geoutils/Vector3.hpp"'
        '"geoutils/Matrix4.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"geoutils/GeoUtilsError.hpp"'
        '"geoutils/Vertex3.hpp"'
    }
}

## forward declarations
#forward = {
#}

# undefine macros

## typedefs
#typedef = {
#}

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = TransformableObject
	shortDesc = Transformable object
	title = Transformable object
	longDesc = Abstract base class for objects that support basic transformations and can be part of a group of such objects.
	group.name = geoutils
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
            inheritanceType = virtual public
		}
        ## other base classes
        #other[] = {
		#	name = Ionflux::GeoUtils::Vertex3Set
        #    include = geoutils/Vertex3Set.hpp
		#}
	}
    features = {
        'copy'
#       'logmessage'
#        'classinfo'
        'upcast'
    }
}

# Member variables.
variable.protected[] = {
    type = bool
    name = useTransform
    desc = Use transform matrix
}
variable.protected[] = {
    type = bool
    name = useVI
    desc = Use view/image transform matrix
}
variable.protected[] = {
    type = bool
    name = transformChanged
    desc = Transform changed flag
}
variable.protected[] = {
    type = bool
    name = viChanged
    desc = View/image transform changed flag
}
variable.protected[] = {
    type = Ionflux::GeoUtils::Range3*
    name = boundsCache
    desc = Bounds cache
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
    type = Ionflux::GeoUtils::Matrix4
    setFromType = const Ionflux::GeoUtils::Matrix4&
    name = transformMatrix
    desc = Transformation matrix
    impl.set = transformMatrix = newTransformMatrix;\
checkTransform();
}
property.protected[] = {
    type = Ionflux::GeoUtils::Matrix4
    setFromType = const Ionflux::GeoUtils::Matrix4&
    name = viewMatrix
    desc = View matrix
    impl.set = viewMatrix = newViewMatrix;\
checkVI();
}
property.protected[] = {
    type = Ionflux::GeoUtils::Matrix4
    setFromType = const Ionflux::GeoUtils::Matrix4&
    name = imageMatrix
    desc = Image transformation matrix
    impl.set = imageMatrix = newImageMatrix;\
checkVI();
}
property.protected[] = {
    type = Ionflux::GeoUtils::Matrix4
    setFromType = const Ionflux::GeoUtils::Matrix4&
    name = lastTransformMatrix
    desc = Transformation matrix before last change
}
property.protected[] = {
    type = Ionflux::GeoUtils::Matrix4
    setFromType = const Ionflux::GeoUtils::Matrix4&
    name = lastViewMatrix
    desc = View matrix before last change
}
property.protected[] = {
    type = Ionflux::GeoUtils::Matrix4
    setFromType = const Ionflux::GeoUtils::Matrix4&
    name = lastImageMatrix
    desc = Image transformation matrix before last change
}

# Public static constants.

# Protected static constants.

# Public constructors.
constructor.default = {
    initializer[] = {
        name = useTransform
        value = false
    }
    initializer[] = {
        name = useVI
        value = false
    }
    initializer[] = {
        name = transformChanged
        value = false
    }
    initializer[] = {
        name = viChanged
        value = false
    }
    initializer[] = {
        name = boundsCache
        value = 0
    }
    initializer[] = {
        name = transformMatrix
        value = Ionflux::GeoUtils::Matrix4::UNIT
    }
    initializer[] = {
        name = viewMatrix
        value = Ionflux::GeoUtils::Matrix4::UNIT
    }
    initializer[] = {
        name = imageMatrix
        value = Ionflux::GeoUtils::Matrix4::UNIT
    }
    initializer[] = {
        name = lastTransformMatrix
        value = Ionflux::GeoUtils::Matrix4::UNIT
    }
    initializer[] = {
        name = lastViewMatrix
        value = Ionflux::GeoUtils::Matrix4::UNIT
    }
    initializer[] = {
        name = lastImageMatrix
        value = Ionflux::GeoUtils::Matrix4::UNIT
    }
    impl = 
}

# Destructor.
#destructor.impl = 

# Protected member functions.
function.protected[] = {
	spec = virtual
	type = void
	name = recalculateBounds
	shortDesc = recalculate bounds
	longDesc = Process a transform change.
	impl = if (boundsCache == 0)\
\{\
    boundsCache = new Range3();\
    addLocalRef(boundsCache);\
\}
}
function.protected[] = {
	spec = virtual
	type = void
	name = processTransformChange
	shortDesc = Process transform change
	longDesc = Process a transform change.
	impl = recalculateBounds();\
transformChanged = false;\
viChanged = false;
    return = {
        value = 
        desc = Bounds
    }
}

# Public member functions.
function.copy.impl = copyTransform(other);
function.public[] = {
	spec = virtual
	type = std::string
	name = getValueString
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	impl = <<<
if (!useTransform && !useVI)
    return "";
ostringstream status;
if (useTransform)
    status << transformMatrix;
if (useVI)
{
    if (useTransform)
        status << ", ";
    status << viewMatrix << ", " << imageMatrix;
}
>>>
    return = {
        value = status.str()
        desc = String representation
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = copyTransform
	shortDesc = copy transform
	longDesc = Copy the transformation matrices from another object.
	param[] = {
		type = const Ionflux::GeoUtils::TransformableObject&
		name = other
		desc = Transformable object
	}
    impl = lastTransformMatrix = transformMatrix;\
lastViewMatrix = viewMatrix;\
lastImageMatrix = imageMatrix;\
transformMatrix = other.transformMatrix;\
viewMatrix = other.viewMatrix;\
imageMatrix = other.imageMatrix;\
checkTransform();\
checkVI();
}
function.public[] = {
	spec = virtual
	type = void
	name = onTransformChanged
	shortDesc = Transform changed handler
	longDesc = This event handler is invoked when the transform matrix changes. The default implementation sets the 'transform changed' flag.
    impl = transformChanged = true;
}
function.public[] = {
	spec = virtual
	type = void
	name = onVIChanged
	shortDesc = Transform changed handler
	longDesc = This event handler is invoked when the view/image transform matrix changes. The default implementation sets the 'view/image transform changed' flag.
    impl = viChanged = true;
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkTransform
	shortDesc = Check transform status
	longDesc = Check the transform matrix. If it is equal to the unit matrix within the tolerance, use of the matrix for object transformations will be disabled. If it is not equal to the unit matrix, check if the transform has changed. If it has changed, call the onTransformChanged() handler.
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::Matrix4::COMPARE_TOLERANCE
	}
    impl = if (transformMatrix.eq(Matrix4::UNIT, t))\
    useTransform = false;\
else\
\{\
    useTransform = true;\
    if (!transformMatrix.eq(lastTransformMatrix, t))\
        onTransformChanged();\
\}
    return = {
        value = useTransform
        desc = The result of the check
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = checkVI
	shortDesc = Check view/image transform status
	longDesc = Check the view/image transform matrices. If both are equal to the unit matrix within the tolerance, use of the matrices for object transformations will be disabled. If the matrices are not equal to the unit matrix, check if the matrices have changed. If either matrix has changed, call the onVIChanged() handler.
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::Matrix4::COMPARE_TOLERANCE
	}
    impl = if (viewMatrix.eq(Matrix4::UNIT, t) \
    && (imageMatrix.eq(Matrix4::UNIT, t)))\
    useVI = false;\
else\
\{\
    useVI = true;\
    if (!(viewMatrix.eq(lastViewMatrix, t) \
        && imageMatrix.eq(lastImageMatrix, t)))\
        onVIChanged();\
\}
    return = {
        value = useTransform
        desc = The result of the check
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::TransformableObject&
	name = scale
	shortDesc = Scale
	longDesc = Scale the object by the specified scale factors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = s
		desc = Vector of scale factors
	}
    impl = Matrix4 s0 = Matrix4::scale(s);\
transform(s0);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::TransformableObject&
	name = translate
	shortDesc = Translate
	longDesc = Translate the object by the specified vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector3&
		name = t
		desc = Translation vector
	}
    impl = Matrix4 t0 = Matrix4::translate(t);\
transform(t0);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::TransformableObject&
	name = rotate
	shortDesc = Rotate
	longDesc = Rotate the object by the specified angle around the specified axis.
	param[] = {
		type = double
		name = phi
		desc = Angle
	}
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = axis
		desc = Axis
        default = Ionflux::GeoUtils::AXIS_Z
	}
    impl = Matrix4 r0 = Matrix4::rotate(phi, axis);\
transform(r0);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::TransformableObject&
	name = normalize
	shortDesc = Normalize
	longDesc = Normalize the object, i.e. scale to unit size.
    impl = Range3 bounds = getBounds();\
Vector3 r = bounds.getRadius();\
/* Scale to half the radius vector so the object has unit size \
   for its largest cross-section. */\
double s = 0.5 / r.norm();\
Vector3 s0(s, s, s);\
scale(s0);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::TransformableObject&
	name = center
	shortDesc = Center
	longDesc = Center the object using the specified method and origin vector.
	param[] = {
		type = Ionflux::GeoUtils::CenteringMethod
		name = method
		desc = Centering method
        default = Ionflux::GeoUtils::CENTER_BARYCENTER
	}
	param[] = {
		type = Ionflux::GeoUtils::Vector3*
		name = origin
		desc = Origin or offset vector
        default = 0
	}
    impl = Vector3 offset;\
if (method == CENTER_BARYCENTER)\
    offset = getBarycenter().flip();\
else\
if (method == CENTER_BOUNDS)\
    offset = getBounds().getCenter().flip();\
if (origin != 0)\
    offset = offset + *origin;\
/* <---- DEBUG ----- //\
std::ostringstream message;\
message << "offset = " << offset;\
log(IFLogMessage(message.str(), VL_DEBUG, this, "center"));\
// ----- DEBUG ----> */\
Matrix4 t0 = Matrix4::translate(offset);\
transform(t0);
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::TransformableObject&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix3&
		name = matrix
		desc = Transformation matrix
	}
    impl = transform(Matrix4(matrix));
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::TransformableObject&
	name = transform
	shortDesc = Matrix transformation
	longDesc = Apply a transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix4&
		name = matrix
		desc = Transformation matrix
	}
    impl = lastTransformMatrix = transformMatrix;\
transformMatrix.multiplyLeft(matrix);\
checkTransform();
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::TransformableObject&
	name = transformVI
	shortDesc = View/image transformation
	longDesc = Apply a view transformation matrix and an optional image transformation matrix to the object.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix4&
		name = view
		desc = View transformation matrix
	}
	param[] = {
		type = const Ionflux::GeoUtils::Matrix4*
		name = image
		desc = Image transformation matrix
        default = 0
	}
    impl = lastViewMatrix = viewMatrix;\
lastImageMatrix = imageMatrix;\
viewMatrix = view;\
if (image != 0)\
    imageMatrix = *image;\
checkVI();
    return = {
        value = *this
        desc = The transformed object
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = applyTransform
	shortDesc = Apply transformations
	longDesc = Apply transformations that have been accumulated in the transformation matrices. This can be used by derived classes that have an internal structure to apply the transformations to that internal structure.
	param[] = {
	    type = bool
	    name = recursive
	    desc = Apply transformations recursively
	    default = false
	}
    impl = 
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector3
	name = getBarycenter
	shortDesc = Get barycenter
	longDesc = Get the barycenter vector for the transformable object.
	impl = if (!useTransform && !useVI)\
    return Vector3::ZERO;\
Vertex3 v0;\
if (useTransform)\
    v0.transform(transformMatrix);\
if (useVI)\
    v0.transformVI(viewMatrix, &imageMatrix);
    return = {
        value = v0.getVector();
        desc = Barycenter vector
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Range3
	name = getBounds
	shortDesc = Get bounds
	longDesc = Get the bounds for the transformable object.
	impl = if ((boundsCache == 0) \
    || transformChanged \
    || viChanged)\
    processTransformChange();
    return = {
        value = *boundsCache
        desc = Bounds
    }
}

# Pure virtual member functions.
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::TransformableObject&
	name = duplicate
    pureVirtual = true
	shortDesc = Duplicate
	longDesc = Create an exact duplicate of the object. The duplicate is a new object which must be managed by the caller.
    impl = 
    return = {
        value = 
        desc = The duplicated object
    }
}

# operations

# Global functions.

