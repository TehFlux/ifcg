# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Matrix2.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/types.hpp"'
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/utils.hpp"'
        '"geoutils/Vector2.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"geoutils/GeoUtilsError.hpp"'
    }
}

# forward declarations
forward = {
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Matrix2
	shortDesc = Matrix (2x2)
	title = Matrix (2x2)
	longDesc = A 2x2 matrix.
	group.name = geoutils
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
		}
	}
    features = {
        'copy'
    }
}

# Public constructors.
constructor.copy.impl = elements = new double[4];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
*this = other;
constructor.default = {
    initializer[] = {
        name = elements
        value = 0
    }
    impl = elements = new double[4];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
*this = ZERO;
}
constructor.public[] = {
    initializer[] = {
        name = elements
        value = 0
    }
    param[] = {
        name = initX00
        type = double
        desc = Element x00
    }
    param[] = {
        name = initX01
        type = double
        desc = Element x01
    }
    param[] = {
        name = initX10
        type = double
        desc = Element x10
    }
    param[] = {
        name = initX11
        type = double
        desc = Element x11
    }
    impl = elements = new double[4];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
elements[0] = initX00;\
elements[1] = initX01;\
elements[2] = initX10;\
elements[3] = initX11;
}
constructor.public[] = {
    initializer[] = {
        name = elements
        value = 0
    }
    param[] = {
        name = initElements
        type = const Ionflux::ObjectBase::DoubleVector&
        desc = Element vector
    }
    impl = elements = new double[4];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
setElements(initElements);
}

# Destructor.
destructor.impl = delete[] elements;

# Member variables.
variable.protected[] = {
	type = double*
	name = elements
	desc = Elements
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
	type = Ionflux::GeoUtils::Vector2
	setFromType = const Ionflux::GeoUtils::Vector2&
	name = r0
	desc = Row vector (0)
    proxy = true
    impl.get = return Vector2(elements[0], elements[1]);
    impl.set = elements[0] = newR0.getX0();\
elements[1] = newR0.getX1();
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector2
	setFromType = const Ionflux::GeoUtils::Vector2&
	name = r1
	desc = Row vector (1)
    proxy = true
    impl.get = return Vector2(elements[2], elements[3]);
    impl.set = elements[2] = newR1.getX0();\
elements[3] = newR1.getX1();
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector2
	setFromType = const Ionflux::GeoUtils::Vector2&
	name = c0
	desc = Column vector (0)
    proxy = true
    impl.get = return Vector2(elements[0], elements[2]);
    impl.set = elements[0] = newC0.getX0();\
elements[2] = newC0.getX1();
}
property.protected[] = {
	type = Ionflux::GeoUtils::Vector2
	setFromType = const Ionflux::GeoUtils::Vector2&
	name = c1
	desc = Column vector (1)
    proxy = true
    impl.get = return Vector2(elements[1], elements[3]);
    impl.set = elements[1] = newC1.getX0();\
elements[3] = newC1.getX1();
}

# Public static constants.
constant.public[] = {
    desc = Zero matrix
    type = Ionflux::GeoUtils::Matrix2
    name = ZERO
    value = Ionflux::GeoUtils::Matrix2(0., 0., 0., 0.)
}
constant.public[] = {
    desc = Unit matrix
    type = Ionflux::GeoUtils::Matrix2
    name = UNIT
    value = Ionflux::GeoUtils::Matrix2(1., 0., 0., 1.)
}

# Protected static constants.

# Protected member functions.

# Public member functions.
function.copy.impl = if ((elements == 0) || (other.elements == 0))\
    return *this;\
for (unsigned int i = 0; i < 4; i++)\
    elements[i] = other.elements[i];\
return *this;
function.public[] = {
	spec = virtual
	type = void
	name = setElements
	shortDesc = Set elements
	longDesc = Set elements from a vector of doubles. If the vector contains fewer than the required number of elements, the remaining elements will be left alone.
	param[] = {
		type = const Ionflux::ObjectBase::DoubleVector&
		name = newElements
		desc = Element vector
	}
    impl = unsigned int i = 0;\
while ((i < 4) && (i < newElements.size()))\
\{\
    elements[i] = newElements[i];\
    i++;\
\}
}
function.public[] = {
	spec = virtual
	type = void
	name = getElements
	const = true
	shortDesc = Get elements
	longDesc = Store the elements of the matrix in a vector of doubles.
	param[] = {
		type = Ionflux::ObjectBase::DoubleVector&
		name = target
		desc = Target vector
	}
    impl = target.clear();\
for (unsigned int i = 0; i < 4; i++)\
    target.push_back(elements[i]);
}
function.public[] = {
	spec = virtual
	type = double
	name = getElement
	const = true
	shortDesc = Get element
	longDesc = Get the element at the specified position.
	param[] = {
		type = int
		name = row
		desc = Row index
	}
	param[] = {
		type = int
		name = column
		desc = Column index
	}
    impl = if ((row < 0) || (row > 1))\
\{\
    ostringstream message;\
    message << "Row index out of range: " << row;\
    throw GeoUtilsError(message.str());\
\}\
if ((column < 0) || (column > 1))\
\{\
    ostringstream message;\
    message << "Column index out of range: " << column;\
    throw GeoUtilsError(message.str());\
\}
    return = {
        value = elements[2 * row + column];
        desc = Element at the specified index
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setElement
	shortDesc = Set element
	longDesc = Set the element at the specified index.
	param[] = {
		type = int
		name = row
		desc = Row index
	}
	param[] = {
		type = int
		name = column
		desc = Column index
	}
	param[] = {
		type = double
		name = value
		desc = Value
	}
    impl = if ((row < 0) || (row > 1))\
\{\
    ostringstream message;\
    message << "Row index out of range: " << row;\
    throw GeoUtilsError(message.str());\
\}\
if ((column < 0) || (column > 1))\
\{\
    ostringstream message;\
    message << "Column index out of range: " << column;\
    throw GeoUtilsError(message.str());\
\}\
elements[2 * row + column] = value;
}
function.public[] = {
	spec = virtual
	type = bool
	name = eq
	shortDesc = Comparison (with tolerance): equal
	longDesc = Compare the matrix with another matrix using the specified tolerance.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix2&
		name = other
		desc = Matrix
	}
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = for (unsigned int i = 0; i < 4; i++)\
    if (!Ionflux::GeoUtils::eq(elements[i], other.elements[i], t))\
        return false;
    return = {
        value = true
        desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix2
	name = transpose
	const = true
	shortDesc = Transpose
	longDesc = Transpose the matrix.
	return = {
        value = Matrix2(elements[0], elements[2], elements[1], elements[3])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix2
	name = swapColumns
	const = true
	shortDesc = Swap columns
	longDesc = Swap the columns.
    impl = 
	return = {
        value = Matrix2(elements[1], elements[0], elements[3], elements[2])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = solve
	const = true
	shortDesc = Solve matrix equation
	longDesc = Solve the matrix equation Mx = v.
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = v
		desc = Vector
	}
    impl = <<<
double y11 = elements[0];
double y12 = elements[1];
double y21 = elements[2];
double y22 = elements[3];
double d = v.getElement(0);
double e = v.getElement(1);
Vector2 result;
if ((y11 != 0.0)
    && ((y22 * y11 - y12 * y21) != 0.0))
{
    double y = (e * y11 - d * y21) / (y22 * y11 - y12 * y21);
    result.setElement(0, (d - y * y12) / y11);
    result.setElement(1, y);
} else
if ((y12 != 0)
    && ((y21 * y12 - y11 * y22) != 0.0))
    result = swapColumns().solve(v).swap();
else
if ((y11 != 0.) && (y12 == 0.) && (y21 == 0.) 
    && (y22 == 0.) && (e == 0))
{
    result.setElement(0, d / y11);
    result.setElement(1, 0.);
}
>>>
	return = {
        value = result
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix2
	name = invert
	const = true
	shortDesc = Invert matrix
	longDesc = Invert the matrix.
    impl = Vector2 x = solve(Vector2::E_X);\
Vector2 y = solve(Vector2::E_Y);\
Matrix2 result;\
result.setC0(x);\
result.setC1(y);
	return = {
        value = result
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator==
	const = true
	shortDesc = Comparison operator: equality
	longDesc = Compare equality.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix2&
		name = other
		desc = Matrix
	}
    impl = for (unsigned int i = 0; i < 4; i++)\
    if (elements[i] != other.elements[i])\
        return false;
	return = {
        value = true
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator!=
	const = true
	shortDesc = Comparison operator: inequality
	longDesc = Compare inequality.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix2&
		name = other
		desc = Matrix
	}
	return.value = !(*this == other);
	return.desc = Result of the comparison
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = operator[]
	const = true
	shortDesc = Subscript operator
	longDesc = Subscript operator.
	param[] = {
		type = int
		name = index
		desc = Index
	}
    impl = if ((index < 0) || (index > 1))\
\{\
    ostringstream message;\
    message << "Index out of range: " << index;\
    throw GeoUtilsError(message.str());\
\}
	return = {
        value = Vector2(elements[2 * index], elements[2 * index + 1])
        desc = Row vector with specified index
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix2
	name = operator*
	const = true
	shortDesc = Multiply matrices
	longDesc = Multiply matrices.
	param[] = {
		type = const Ionflux::GeoUtils::Matrix2&
		name = other
		desc = Matrix
	}
    impl = Matrix2 result;\
for (unsigned int i = 0; i < 2; i++)\
    for (unsigned int j = 0; j < 2; j++)\
    \{\
        double s = 0.0;\
        for (unsigned int k = 0; k < 2; k++)\
            s += elements[2 * i + k] * other.elements[2 * k + j];\
        result.elements[2 * i + j] = s;\
    \}
	return = {
        value = result
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = operator*
	const = true
	shortDesc = Transform vector
	longDesc = Transform a vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = v
		desc = Vector
	}
    impl = double result[2];\
for (unsigned int i = 0; i < 2; i++)\
\{\
    double s = 0.0;\
    for (unsigned int k = 0; k < 2; k++)\
        s += elements[2 * i + k] * v.getElement(k);\
    result[i] = s;\
\}
	return = {
        value = Vector2(result[0], result[1])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix2
	name = operator*
	const = true
	shortDesc = Multiply matrix by scalar
	longDesc = Multiply matrix by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
    impl = Matrix2 result;\
for (unsigned int i = 0; i < 4; i++)\
    result.elements[i] = elements[i] * c;
	return = {
        value = result
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Matrix2
	name = operator/
	const = true
	shortDesc = Divide matrix by scalar
	longDesc = Divide matrix by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
    impl = Matrix2 result;\
for (unsigned int i = 0; i < 4; i++)\
    result.elements[i] = elements[i] / c;
	return = {
        value = result
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getString
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	impl = ostringstream state;\
state << getClassName() << "[[" << elements[0] << ", " \
    << elements[1] << "], [" << elements[2] << ", " \
    << elements[3] << "]]";
    return = {
        value = state.str()
        desc = String representation
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Matrix2
	name = scale
	shortDesc = Create scale matrix
	longDesc = Create a scale matrix.
	param[] = {
		type = double
		name = sx
		desc = Scale factor (x)
        default = 1.
	}
	param[] = {
		type = double
		name = sy
		desc = Scale factor (y)
        default = 1.
	}
	impl = 
    return = {
        value = Matrix2(sx, 0., 0., sy)
        desc = Scale matrix
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Matrix2
	name = rotate
	shortDesc = Create rotation matrix
	longDesc = Create a rotation matrix.
	param[] = {
		type = double
		name = phi
		desc = Angle
        default = 0.
	}
	impl = 
    return = {
        value = Matrix2(::cos(phi), -::sin(phi), ::sin(phi), ::cos(phi));
        desc = Rotation matrix
    }
}

# Pure virtual member functions.

# operations

# Global functions.
function.global[] = {
	type = Ionflux::GeoUtils::Matrix2
	name = operator*
	shortDesc = Multiply matrix by scalar
	longDesc = Multiply matrix by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
	param[] = {
		type = const Ionflux::GeoUtils::Matrix2&
		name = m
		desc = Matrix
	}
    impl = 
	return = {
        value = m * c
	    desc = Result of the calculation
    }
}

