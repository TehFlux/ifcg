# ==========================================================================
# GeoUtils - Ionflux' Geometry Library
# Copyright © 2009 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Vector2.conf              Class configuration.
# ==========================================================================
# 
# This file is part of GeoUtils - Ionflux' Geometry Library.
# 
# GeoUtils - Ionflux' Geometry Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# GeoUtils - Ionflux' Geometry Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Ionflux Star Database; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
	    '"ifobject/types.hpp"'
        '"geoutils/types.hpp"'
        '"geoutils/constants.hpp"'
        '"geoutils/utils.hpp"'
	}
    # these includes will be added in the implementation file
    impl = {
        '<cmath>'
        '<cstdlib>'
        '<sstream>'
        '<iomanip>'
        '"geoutils/GeoUtilsError.hpp"'
    }
}

# forward declarations
forward = {
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Vector2
	shortDesc = Vector (2 elements)
	title = Vector (2 elements)
	longDesc = A vector in two-dimensional space.
	group.name = geoutils
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
		}
	}
    features = {
        'copy'
    }
}

# Public constructors.
constructor.copy.impl = elements = new double[2];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
*this = other;
constructor.default = {
    initializer[] = {
        name = elements
        value = 0
    }
    impl = elements = new double[2];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
*this = ZERO;
}
constructor.public[] = {
    initializer[] = {
        name = elements
        value = 0
    }
    param[] = {
        name = initX0
        type = double
        desc = Element (X0)
    }
    param[] = {
        name = initX1
        type = double
        desc = Element (X1)
    }
    impl = elements = new double[2];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
elements[0] = initX0;\
elements[1] = initX1;
}
constructor.public[] = {
    initializer[] = {
        name = elements
        value = 0
    }
    param[] = {
        name = initElements
        type = const Ionflux::ObjectBase::DoubleVector&
        desc = Element vector
    }
    impl = elements = new double[2];\
if (elements == 0)\
    throw GeoUtilsError("Could not allocate object.");\
setElements(initElements);
}

# Destructor.
destructor.impl = delete[] elements;

# Member variables.
variable.protected[] = {
	type = double*
	name = elements
	desc = Elements
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.
property.protected[] = {
	type = double
	setFromType = double
	name = x0
	desc = Element x0
    copy = true
    proxy = true
    impl.set = elements[0] = newX0;
    impl.get = return elements[0];
}
property.protected[] = {
	type = double
	setFromType = double
	name = x1
	desc = Element x1
    copy = true
    proxy = true
    impl.set = elements[1] = newX1;
    impl.get = return elements[1];
}

# Public static constants.
constant.public[] = {
    desc = Zero vector
    type = Ionflux::GeoUtils::Vector2
    name = ZERO
    value = Ionflux::GeoUtils::Vector2(0., 0.)
}
constant.public[] = {
    desc = Unit vector (X)
    type = Ionflux::GeoUtils::Vector2
    name = E_X
    value = Ionflux::GeoUtils::Vector2(1., 0.)
}
constant.public[] = {
    desc = Unit vector (Y)
    type = Ionflux::GeoUtils::Vector2
    name = E_Y
    value = Ionflux::GeoUtils::Vector2(0., 1.)
}

# Protected static constants.

# Protected member functions.

# Public member functions.
function.copy.impl = if ((elements == 0) || (other.elements == 0))\
    return *this;\
for (unsigned int i = 0; i < 2; i++)\
    elements[i] = other.elements[i];\
return *this;
function.public[] = {
	spec = virtual
	type = void
	name = setElements
	shortDesc = Set elements
	longDesc = Set elements from a vector of doubles. If the vector contains fewer than the required number of elements, the remaining elements will be left alone.
	param[] = {
		type = const Ionflux::ObjectBase::DoubleVector&
		name = newElements
		desc = Element vector
	}
    impl = unsigned int i = 0;\
while ((i < 2) && (i < newElements.size()))\
\{\
    elements[i] = newElements[i];\
    i++;\
\}
}
function.public[] = {
	spec = virtual
	type = void
	name = setElements
	shortDesc = Set elements
	longDesc = Set elements of the vector.
	param[] = {
		type = double
		name = newX0
		desc = Element (x0)
	}
	param[] = {
		type = double
		name = newX1
		desc = Element (x1)
	}
    impl = elements[0] = newX0;\
elements[1] = newX1;
}
function.public[] = {
	spec = virtual
	type = void
	name = getElements
    const = true
	shortDesc = Get elements
	longDesc = Store the elements of the vector in a vector of doubles.
	param[] = {
		type = Ionflux::ObjectBase::DoubleVector&
		name = target
		desc = Target vector
	}
    impl = target.clear();\
for (unsigned int i = 0; i < 2; i++)\
    target.push_back(elements[i]);
}
function.public[] = {
	spec = virtual
	type = double
	name = getElement
    const = true
	shortDesc = Get element
	longDesc = Get the element at the specified index.
	param[] = {
		type = int
		name = index
		desc = Index
	}
    impl = 
    return = {
        value = (*this)[index];
        desc = Element at the specified index
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = setElement
	shortDesc = Set element
	longDesc = Set the element at the specified index.
	param[] = {
		type = int
		name = index
		desc = Index
	}
	param[] = {
		type = double
		name = value
		desc = Value
	}
    impl = if ((index < 0) || (index > 2))\
\{\
    ostringstream message;\
    message << "Index out of range: " << index;\
    throw GeoUtilsError(message.str());\
\}\
elements[index] = value;
}
function.public[] = {
	spec = virtual
	type = bool
	name = eq
	shortDesc = Comparison (with tolerance): equal
	longDesc = Compare the vector with another vector using the specified tolerance.
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = other
		desc = Vector
	}
	param[] = {
		type = double
		name = t
		desc = Tolerance
        default = Ionflux::GeoUtils::DEFAULT_TOLERANCE
	}
    impl = for (unsigned int i = 0; i < 2; i++)\
    if (!Ionflux::GeoUtils::eq(elements[i], other.elements[i], t))\
        return false;
    return = {
        value = true
        desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = flip
	const = true
	shortDesc = Flip vector
	longDesc = Create a new vector which is equal to the original vector multiplied by -1.
    impl = 
	return = {
        value = Vector2(-elements[0], -elements[1])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = double
	name = norm
	const = true
	shortDesc = Norm
	longDesc = Get the norm (length) of the vector.
    impl = 
	return = {
        value = ::sqrt((*this) * (*this))
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = normalize
	const = true
	shortDesc = Normalize vector
	longDesc = Create a new vector which is equal to the normalized original vector.
    impl = 
	return = {
        value = (*this) / norm()
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = project
	const = true
	shortDesc = Projection
	longDesc = Calculate the projection of another vector on the vector.
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = other
		desc = Vector
	}
    impl = const Vector2& v0 = *this;
	return = {
        value = ((v0 * other) * v0) / (v0 * v0)
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = ortho
	const = true
	shortDesc = Orthogonalize vector
	longDesc = Rotate the other vector (v1) within the plane defined by the original vector (v0) and v1, so it is orthogonal to v0.
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = other
		desc = Vector
	}
    impl = const Vector2& v0 = *this;
	return = {
        value = other.norm() * (other - v0.project(other)).normalize()
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = swap
	const = true
	shortDesc = Swap elements
	longDesc = Swap the elements of the vector.
    impl = 
	return = {
        value = Vector2(elements[1], elements[0])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator==
	const = true
	shortDesc = Comparison operator: equality
	longDesc = Compare equality.
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = other
		desc = Vector
	}
    impl = for (unsigned int i = 0; i < 2; i++)\
    if (elements[i] != other.elements[i])\
        return false;
	return = {
        value = true
	    desc = Result of the comparison
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = operator!=
	const = true
	shortDesc = Comparison operator: inequality
	longDesc = Compare inequality.
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = other
		desc = Vector
	}
	return.value = !(*this == other);
	return.desc = Result of the comparison
}
function.public[] = {
	spec = virtual
	type = double
	name = operator[]
	const = true
	shortDesc = Subscript operator
	longDesc = Subscript operator.
	param[] = {
		type = int
		name = index
		desc = Index
	}
    impl = if ((index < 0) || (index > 2))\
\{\
    ostringstream message;\
    message << "Index out of range: " << index;\
    throw GeoUtilsError(message.str());\
\}
	return = {
        value = elements[index]
        desc = Element at specified index
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = operator+
	const = true
	shortDesc = Add vectors
	longDesc = Add vectors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = other
		desc = Vector
	}
    impl = 
	return = {
        value = Vector2(elements[0] + other.elements[0], \
    elements[1] + other.elements[1])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = operator-
	const = true
	shortDesc = Subtract vectors
	longDesc = Subtract vectors.
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = other
		desc = Vector
	}
    impl = 
	return = {
        value = Vector2(elements[0] - other.elements[0], \
    elements[1] - other.elements[1])
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = double
	name = operator*
	const = true
	shortDesc = Multiply vectors
	longDesc = Multiply vectors (dot product).
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = other
		desc = Vector
	}
    impl = 
	return = {
        value = elements[0] * other.elements[0] + elements[1] * other.elements[1]
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = operator*
	const = true
	shortDesc = Multiply vector by scalar
	longDesc = Multiply vector by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
    impl = 
	return = {
        value = Vector2(elements[0] * c, elements[1] * c)
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = Ionflux::GeoUtils::Vector2
	name = operator/
	const = true
	shortDesc = Divide vector by scalar
	longDesc = Divide vector by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
    impl = 
	return = {
        value = Vector2(elements[0] / c, elements[1] / c)
	    desc = Result of the calculation
    }
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getString
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	impl = ostringstream state;\
state << getClassName() << "[" << elements[0] << ", " << elements[1] \
    << "]";
    return = {
        value = state.str()
        desc = String representation
    }
}
function.public[] = {
	spec = static
	type = Ionflux::GeoUtils::Vector2
	name = axis
	shortDesc = Get axis direction vector
	longDesc = Get the direction vector for the specified axis.
	param[] = {
		type = Ionflux::GeoUtils::AxisID
		name = axisID
		desc = Axis
	}
    impl = if (axisID == AXIS_X)\
    return E_X;\
else\
if (axisID == AXIS_Y)\
    return E_Y;\
else\
\{\
    ostringstream status;\
    status << "Invalid axis: " << axisID;\
    throw GeoUtilsError(status.str());\
\}
	return = {
        value = ZERO
	    desc = Axis direction vector
    }
}

# Pure virtual member functions.

# operations

# Global functions.
function.global[] = {
	type = Ionflux::GeoUtils::Vector2
	name = operator*
	shortDesc = Multiply vector by scalar
	longDesc = Multiply vector by a scalar.
	param[] = {
		type = double
		name = c
		desc = Scalar factor
	}
	param[] = {
		type = const Ionflux::GeoUtils::Vector2&
		name = v
		desc = Vector
	}
    impl = 
	return = {
        value = v * c
	    desc = Result of the calculation
    }
}

