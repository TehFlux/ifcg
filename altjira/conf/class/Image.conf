# ==========================================================================
# Altjira - Ionflux' Image Processing Library
# Copyright © 2008-2011 Jörn P. Meier
# mail@ionflux.org
# --------------------------------------------------------------------------
# Image.conf         Class configuration.
# ==========================================================================
# 
# This file is part of Altjira - Ionflux' Image Processing Library.
# 
# Altjira - Ionflux' Image Processing Library is free software; you can 
# redistribute it and/or modify it under the terms of the GNU General 
# Public  License as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later version.
# 
# Altjira - Ionflux' Image Processing Library is distributed in the hope 
# that it will be useful, but WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Altjira - Ionflux' Image Processing Library; if not, write 
# to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307 USA
# 
# ==========================================================================

# Class configuration usable with the Ionflux Object Base System.

# using directives
using = {
	'namespace std'
	'namespace Ionflux::ObjectBase'
}

# include files.
include = {
	# these includes will be added in the header file
	header = {
        '"ifmapping/Mapping.hpp"'
        '"ifmapping/PointSet.hpp"'
        '"altjira/Color.hpp"'
        '"altjira/constants.hpp"'
        '"altjira/ColorBlender.hpp"'
        '"altjira/Matrix.hpp"'
        '"altjira/ColorBand.hpp"'
        '<climits>'
	}
    # these includes will be added in the implementation file
    impl = {
        '<sstream>'
        '<string>'
        '<fstream>'
        '<algorithm>'
        '<iomanip>'
        '<stdint.h>'
        '"ifmapping/utils.hpp"'
        '"altjira/utils.hpp"'
        '"altjira/imageutils.hpp"'
        '"ifobject/serialize.hpp"'
        '"altjira/BlendSrcOver.hpp"'
        '"altjira/BlendChannel.hpp"'
        '"altjira/AltjiraError.hpp"'
        '"altjira/ImageSet.hpp"'
    }
}

# forward declarations
forward = {
    'class ImageSet'
}

# undefine macros

# typedefs

# typedefs (after signals)
#
# Use this feature for typedefs that depend on signals being already declared.

# helper structs
#
# You can use this feature to declare any number of additional structs in a 
# class header.

# class definition
class = {
	name = Image
	shortDesc = Image
	title = Image
	longDesc = An image.
	group.name = altjira
	base = {
		# base classes from the IFObject hierarchy
		ifobject[] = {
			name = IFObject
			inheritanceType = virtual public
		}
	}
	features = {
	    'create'
	    'upcast'
	    'copy'
	    'logmessage'
	}
	create.allocationError = AltjiraError("Could not allocate object.")
}

# Public constructors.
constructor.copy.impl = Ionflux::Altjira::init();\
*this = other;
constructor.default = {
    initializer[] = {
        name = pixBuf
        value = 0
    }
    impl = Ionflux::Altjira::init();
}
constructor.public[] = {
    initializer[] = {
        name = pixBuf
        value = 0
    }
	param[] = {
		type = const std::string&
		name = fileName
		desc = File name of an image to be loaded
	}
    impl = Ionflux::Altjira::init();\
loadFromFile(fileName);
}
constructor.public[] = {
    initializer[] = {
        name = pixBuf
        value = 0
    }
	param[] = {
		type = unsigned int
		name = initWidth
		desc = Width
	}
	param[] = {
		type = unsigned int
		name = initHeight
		desc = Height
	}
	param[] = {
		type = bool
		name = initAlpha
		desc = Create alpha channel
        default = true
	}
	param[] = {
		type = unsigned int
		name = initBitsPerSample
		desc = Bits pers sample
        default = 8
	}
	param[] = {
		type = Ionflux::Altjira::ColorSpace
		name = initColorSpace
		desc = Color space
        default = Ionflux::Altjira::Color::SPACE_RGB
	}
    impl = Ionflux::Altjira::init();\
createNewData(initWidth, initHeight, initAlpha, \
    initBitsPerSample, initColorSpace);
}

# Destructor.
destructor.impl = clear();

# Member variables.
variable.protected[] = {
    type = GdkPixbuf*
    name = pixBuf
    desc = GdkPixBuf structure for internal use
}
variable.protected[] = {
	type = bool
	name = alphaFlag
	desc = Alpha flag
}

# Class properties.
#
# Properties are like member variables, but accessor functions (getters and 
# setters) will be added and implemented automatically for you. Use this for 
# safe access to public properties of a class.
#
# If the 'managed' option is set to 'true', references to IFObject based 
# types will be handled automatically by the default implementation for 
# property accessor functions.

property.protected[] = {
    readOnly = true
	type = unsigned int
	setFromType = unsigned int
	name = numChannels
	desc = Number of channels
}
property.protected[] = {
    readOnly = true
	type = unsigned int
	setFromType = unsigned int
	name = bitsPerSample
	desc = Bits per sample
}
property.protected[] = {
    readOnly = true
	type = Ionflux::Altjira::ColorSpace
	setFromType = Ionflux::Altjira::ColorSpace
	name = colorSpace
	desc = Color space
}
property.protected[] = {
    readOnly = true
	type = unsigned int
	setFromType = unsigned int
	name = width
	desc = Width
}
property.protected[] = {
    readOnly = true
	type = unsigned int
	setFromType = unsigned int
	name = height
	desc = Height
}
property.protected[] = {
    readOnly = true
	type = unsigned int
	setFromType = unsigned int
	name = rowStride
	desc = Row stride
}
property.protected[] = {
    readOnly = true
	type = Ionflux::Altjira::PixelData
	setFromType = Ionflux::Altjira::PixelData
	name = pixels
	desc = Pixels
}

# Public static constants.

constant.public[] = {
	type = Ionflux::Altjira::ImageType
	name = TYPE_PNG
	desc = Image type: PNG
    value = 0
}
constant.public[] = {
	type = Ionflux::Altjira::ImageType
	name = TYPE_JPEG
	desc = Image type: JPEG
    value = 1
}
constant.public[] = {
	type = Ionflux::Altjira::ImageType
	name = TYPE_GBR_GRAYSCALE
	desc = Image type: Gimp Brush (GBR, grayscale)
    value = 2
}
constant.public[] = {
	type = Ionflux::Altjira::ImageType
	name = TYPE_GBR_RGBA
	desc = Image type: Gimp Brush (GBR, RGBA)
    value = 3
}
constant.public[] = {
	type = Ionflux::Altjira::ImageType
	name = TYPE_GIH_GRAYSCALE
	desc = Image type: Gimp Brush Pipe (GIH, grayscale)
    value = 4
}
constant.public[] = {
	type = Ionflux::Altjira::ImageType
	name = TYPE_GIH_RGBA
	desc = Image type: Gimp Brush Pipe (GIH, RGBA)
    value = 5
}
constant.public[] = {
	type = std::string
	name = GIH_DEFAULT_PLACEMENT
	desc = GIMP GIH default placement
    value = "constant"
}
constant.public[] = {
	type = unsigned int
	name = GIH_CELL_SIZE_MAX
	desc = GIMP GIH maximum cell size
    value = UINT_MAX
}
constant.public[] = {
	type = unsigned int
	name = GIH_DEFAULT_CELL_WIDTH
	desc = GIMP GIH default cell width
    value = GIH_CELL_SIZE_MAX
}
constant.public[] = {
	type = unsigned int
	name = GIH_DEFAULT_CELL_HEIGHT
	desc = GIMP GIH default cell height
    value = GIH_CELL_SIZE_MAX
}

# Protected static constants.

# Protected member functions.
function.copy.impl = createNewData(other.getWidth(), other.getHeight(), \
    other.hasAlpha(), other.getBitsPerSample(), other.getColorSpace());\
fill(other);
function.protected[] = {
	spec = virtual
	type = void
	name = update
	shortDesc = Update image data
	longDesc = Update the image data.
    impl = if (pixBuf == 0)\
    return;\
width = static_cast<unsigned int>(gdk_pixbuf_get_width(pixBuf));\
height = static_cast<unsigned int>(gdk_pixbuf_get_height(pixBuf));\
numChannels = gdk_pixbuf_get_n_channels(pixBuf);\
GdkColorspace cs = gdk_pixbuf_get_colorspace(pixBuf);\
if (cs == GDK_COLORSPACE_RGB)\
    colorSpace = Color::SPACE_RGB;\
else\
    colorSpace = Color::SPACE_UNDEFINED;\
bitsPerSample = gdk_pixbuf_get_bits_per_sample(pixBuf);\
alphaFlag = gdk_pixbuf_get_has_alpha(pixBuf);\
rowStride = gdk_pixbuf_get_rowstride(pixBuf);\
pixels = gdk_pixbuf_get_pixels(pixBuf);
}
function.public[] = {
	spec = virtual
	type = void
	name = createNewData
	shortDesc = Create new image data
	longDesc = Create new image data.
	param[] = {
		type = unsigned int
		name = initWidth
		desc = Width
	}
	param[] = {
		type = unsigned int
		name = initHeight
		desc = Height
	}
	param[] = {
		type = bool
		name = initAlpha
		desc = Create alpha channel
        default = true
	}
	param[] = {
		type = unsigned int
		name = initBitsPerSample
		desc = Bits pers sample
        default = 8
	}
	param[] = {
		type = Ionflux::Altjira::ColorSpace
		name = initColorSpace
		desc = Color space
        default = Ionflux::Altjira::Color::SPACE_RGB
	}
    impl = clear();\
/* RGB is the only color space supported by Gdk-Pixbuf and \
   hence, by the Altjira Image. */\
GdkColorspace cs = GDK_COLORSPACE_RGB;\
pixBuf = gdk_pixbuf_new(cs, initAlpha, initBitsPerSample, \
    initWidth, initHeight);\
update();
}

# Public member functions.
function.public[] = {
	spec = virtual
	type = bool
	name = loadFromFile
	shortDesc = Load image from file
	longDesc = Load an image from a file.
	param[] = {
		type = const std::string&
		name = fileName
		desc = File name
	}
    impl = clear();\
pixBuf = gdk_pixbuf_new_from_file(fileName.c_str(), 0);\
if (pixBuf == 0)\
\{\
    std::ostringstream status;\
    status << "[Image::loadFromFile] Could not load image "\
        "from file '" << fileName << "'!";\
    throw AltjiraError(status.str());\
\}\
update();
    return = {
        desc = \c true on success, \c false otherwise
        value = true
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = getGIHData
	shortDesc = Get GIMP brush data (GIH)
	longDesc = Convert the image data to the GIMP brush pipe (GIH) format.
	param[] = {
		type = std::string&
		name = target
		desc = Where to store the GIH data
	}
	param[] = {
		type = unsigned int
		name = cellWidth
		desc = Cell width
		default = GIH_DEFAULT_CELL_WIDTH
	}
	param[] = {
		type = unsigned int
		name = cellHeight
		desc = Cell height
		default = GIH_DEFAULT_CELL_HEIGHT
	}
	param[] = {
		type = const Ionflux::Altjira::GIHRankSpecVector*
		name = ranks
		desc = Rank specification
		default = 0
	}
	param[] = {
		type = const std::string&
		name = placement
		desc = Placement
		default = Ionflux::Altjira::Image::GIH_DEFAULT_PLACEMENT
	}
	param[] = {
		type = Ionflux::Altjira::ImageType
		name = type
		desc = Image type
        default = Ionflux::Altjira::Image::TYPE_GBR_GRAYSCALE
	}
	param[] = {
		type = const std::string&
		name = brushName
		desc = Brush name
        default = Ionflux::Altjira::DEFAULT_BRUSH_NAME
	}
	param[] = {
		type = unsigned int
		name = spacing
		desc = Brush spacing
        default = Ionflux::Altjira::DEFAULT_BRUSH_SPACING
	}
	param[] = {
		type = Ionflux::Altjira::DesaturationMethod
		name = desaturationMethod
		desc = Desaturation method (used for the GBR grayscale format)
        default = Ionflux::Altjira::DEFAULT_DESATURATION_METHOD
	}
	impl = if (cellWidth == GIH_CELL_SIZE_MAX)\
    cellWidth = width;\
if (cellHeight == GIH_CELL_SIZE_MAX)\
    cellHeight = height;\
unsigned int numCellsX = width / cellWidth;\
unsigned int numCellsY = height / cellHeight;\
unsigned int numCells = numCellsX * numCellsY;\
unsigned int numRanks = 0;\
if (ranks != 0)\
    numRanks = ranks->size();\
unsigned int dimension = 1;\
if (numRanks > 0)\
    dimension = numRanks;\
// Create the header.\
ostringstream gih;\
gih << brushName << "\n" << numCells << " ncells:" << numCells \
    << " cellwidth:" << cellWidth << " cellheight:" << cellHeight \
    << " step:" << spacing << " dim:" << dimension \
    << " cols:1 rows:1 placement:" << placement;\
if (numRanks > 0)\
\{\
    // Use rank specifications from the rank vector.\
    for (unsigned int i = 0; i < numRanks; i++)\
    \{\
        GIHRankSpec r0 = (*ranks)[i];\
        gih << " rank" << i << ":" << r0.size << " sel" << i << ":" \
            << r0.selection;\
    \}\
\} else\
\{\
    // Use the default rank specification.\
    GIHRankSpec r0 = GIH_DEFAULT_RANK_SPEC;\
    gih << " rank0:" << numCells << " sel0:" << r0.selection;\
\}\
/* <---- DEBUG ----- //\
ostringstream message;\
message << "Header: " << gih.str();\
log(IFLogMessage(message.str(), VL_DEBUG, this, "getGIHData"));\
// <---- DEBUG ----> */\
gih << '\n';\
// Create the brush frames.\
ImageSet frames;\
createArray(frames, cellWidth, cellHeight);\
if (frames.getNumImages() != numCells)\
\{\
    ostringstream message;\
    message << "[Image::getGIHData] Unexpected number of frames "\
        "in array: " << frames.getNumImages() << " (expected: " \
        << numCells << ")";\
    throw AltjiraError(message.str());\
\}\
for (unsigned int i = 0; i < numCells; i++)\
\{\
    Image* img0 = frames.getImage(i);\
    if (img0 == 0)\
        throw AltjiraError("[Image::getGIHData] Brush frame is null.");\
    ostringstream gbrName;\
    gbrName << setfill('0');\
    gbrName << brushName << " F#" << setw(8) << i;\
    std::string gbr0;\
    img0->getGBRData(gbr0, type, gbrName.str(), spacing, \
        desaturationMethod);\
    gih << gbr0;\
\}\
target = gih.str();
}
function.public[] = {
	spec = virtual
	type = void
	name = getGBRData
	shortDesc = Get GIMP brush data (GBR)
	longDesc = Convert the image data to the GIMP brush (GBR) format.
	param[] = {
		type = std::string&
		name = target
		desc = Where to store the GBR data
	}
	param[] = {
		type = Ionflux::Altjira::ImageType
		name = type
		desc = Image type
        default = Ionflux::Altjira::Image::TYPE_GBR_GRAYSCALE
	}
	param[] = {
		type = const std::string&
		name = brushName
		desc = Brush name
        default = Ionflux::Altjira::DEFAULT_BRUSH_NAME
	}
	param[] = {
		type = unsigned int
		name = spacing
		desc = Brush spacing
        default = Ionflux::Altjira::DEFAULT_BRUSH_SPACING
	}
	param[] = {
		type = Ionflux::Altjira::DesaturationMethod
		name = desaturationMethod
		desc = Desaturation method (used for the GBR grayscale format)
        default = Ionflux::Altjira::DEFAULT_DESATURATION_METHOD
	}
	impl = target.clear();\
uint32_t headerSize = 28 + brushName.size() + 1;\
uint32_t depth = 0;\
if (type == TYPE_GBR_GRAYSCALE)\
    depth = 1;\
else\
    depth = 4;\
pack(headerSize, target);\
pack(static_cast<uint32_t>(2), target);\
pack(static_cast<uint32_t>(width), target);\
pack(static_cast<uint32_t>(height), target);\
pack(static_cast<uint32_t>(depth), target);\
target.append("GIMP");\
pack(static_cast<uint32_t>(spacing), target);\
target.append(brushName);\
pack('\0', target);\
ByteColor p0;\
if (type == TYPE_GBR_GRAYSCALE)\
    if (desaturationMethod == DESATURATION_BY_LUMINANCE)\
        p0.space = Ionflux::Altjira::Color::SPACE_HSL;\
    else\
        p0.space = Ionflux::Altjira::Color::SPACE_HSV;\
else\
    p0.space = Ionflux::Altjira::Color::SPACE_RGB;\
for (unsigned int i = 0; i < height; i++)\
    for (unsigned int j = 0; j < width; j++)\
    \{\
        getPixel(j, i, p0);\
        if (type == TYPE_GBR_GRAYSCALE)\
            pack(static_cast<unsigned char>(255 - p0.c2), target);\
        else\
        \{\
            pack(p0.c0, target);\
            pack(p0.c1, target);\
            pack(p0.c2, target);\
            pack(p0.alpha, target);\
        \}\
    \}
}
function.public[] = {
	spec = virtual
	type = bool
	name = writeGBR
	shortDesc = Write to gimp brush (GBR)
	longDesc = Write the image to a gimp brush file.
	param[] = {
		type = const std::string&
		name = fileName
		desc = File name
	}
	param[] = {
		type = Ionflux::Altjira::ImageType
		name = type
		desc = Image type
        default = Ionflux::Altjira::Image::TYPE_GBR_GRAYSCALE
	}
	param[] = {
		type = const std::string&
		name = brushName
		desc = Brush name (used for the GBR format)
        default = Ionflux::Altjira::DEFAULT_BRUSH_NAME
	}
	param[] = {
		type = unsigned int
		name = spacing
		desc = Brush spacing (used for the GBR format)
        default = Ionflux::Altjira::DEFAULT_BRUSH_SPACING
	}
	param[] = {
		type = Ionflux::Altjira::DesaturationMethod
		name = desaturationMethod
		desc = Desaturation method (used for the GBR grayscale format)
        default = Ionflux::Altjira::DEFAULT_DESATURATION_METHOD
	}
    impl = ofstream f0;\
std::string buf;\
getGBRData(buf, type, brushName, spacing, desaturationMethod);\
f0.open(fileName.c_str(), ios_base::out);\
if (f0.fail())\
\{\
    ostringstream message;\
    message << "[Image::writeGBR] Could not open file '" << fileName \
        << "' for writing!";\
    throw AltjiraError(message.str());\
\}\
f0 << buf;
    return = {
        desc = \c true on success, \c false otherwise
        value = true
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = writeGIH
	shortDesc = Write to gimp brush pipe (GIH)
	longDesc = Write the image to a gimp brush pipe file.
	param[] = {
		type = const std::string&
		name = fileName
		desc = File name
	}
	param[] = {
		type = unsigned int
		name = cellWidth
		desc = Cell width
		default = GIH_DEFAULT_CELL_WIDTH
	}
	param[] = {
		type = unsigned int
		name = cellHeight
		desc = Cell height
		default = GIH_DEFAULT_CELL_HEIGHT
	}
	param[] = {
		type = const Ionflux::Altjira::GIHRankSpecVector*
		name = ranks
		desc = Rank specification
		default = 0
	}
	param[] = {
		type = const std::string&
		name = placement
		desc = Placement
		default = Ionflux::Altjira::Image::GIH_DEFAULT_PLACEMENT
	}
	param[] = {
		type = Ionflux::Altjira::ImageType
		name = type
		desc = Image type
        default = Ionflux::Altjira::Image::TYPE_GBR_GRAYSCALE
	}
	param[] = {
		type = const std::string&
		name = brushName
		desc = Brush name
        default = Ionflux::Altjira::DEFAULT_BRUSH_NAME
	}
	param[] = {
		type = unsigned int
		name = spacing
		desc = Brush spacing (used for the GBR format)
        default = Ionflux::Altjira::DEFAULT_BRUSH_SPACING
	}
	param[] = {
		type = Ionflux::Altjira::DesaturationMethod
		name = desaturationMethod
		desc = Desaturation method (used for the GBR grayscale format)
        default = Ionflux::Altjira::DEFAULT_DESATURATION_METHOD
	}
    impl = ofstream f0;\
std::string buf;\
getGIHData(buf, cellWidth, cellHeight, ranks, placement, type, \
    brushName, spacing, desaturationMethod);\
f0.open(fileName.c_str(), ios_base::out);\
if (f0.fail())\
\{\
    ostringstream message;\
    message << "[Image::writeGIH] Could not open file '" \
        << fileName << "' for writing!";\
    throw AltjiraError(message.str());\
\}\
f0 << buf;
    return = {
        desc = \c true on success, \c false otherwise
        value = true
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = writeToFile
	shortDesc = Write image to file
	longDesc = Write the image to a file.
	param[] = {
		type = const std::string&
		name = fileName
		desc = File name
	}
	param[] = {
		type = Ionflux::Altjira::ImageType
		name = type
		desc = Image type
        default = Ionflux::Altjira::Image::TYPE_PNG
	}
	param[] = {
		type = const std::string&
		name = brushName
		desc = Brush name (used for the GBR format)
        default = Ionflux::Altjira::DEFAULT_BRUSH_NAME
	}
	param[] = {
		type = unsigned int
		name = spacing
		desc = Brush spacing (used for the GBR format)
        default = Ionflux::Altjira::DEFAULT_BRUSH_SPACING
	}
	param[] = {
		type = Ionflux::Altjira::DesaturationMethod
		name = desaturationMethod
		desc = Desaturation method (used for the GBR grayscale format)
        default = Ionflux::Altjira::DEFAULT_DESATURATION_METHOD
	}
	param[] = {
		type = unsigned int
		name = cellWidth
		desc = Cell width (used for the GIH format)
		default = GIH_DEFAULT_CELL_WIDTH
	}
	param[] = {
		type = unsigned int
		name = cellHeight
		desc = Cell height (used for the GIH format)
		default = GIH_DEFAULT_CELL_HEIGHT
	}
	param[] = {
		type = const Ionflux::Altjira::GIHRankSpecVector*
		name = ranks
		desc = Rank specification (used for the GIH format)
		default = 0
	}
	param[] = {
		type = const std::string&
		name = placement
		desc = Placement (used for the GIH format)
		default = Ionflux::Altjira::Image::GIH_DEFAULT_PLACEMENT
	}
    impl = if (pixBuf == 0)\
    return false;\
std::string st;\
if (type == TYPE_PNG)\
    st = "png";\
else\
if (type == TYPE_JPEG)\
    st = "jpeg";\
else\
if ((type == TYPE_GBR_GRAYSCALE) \
    || (type == TYPE_GBR_RGBA))\
    return writeGBR(fileName, type, brushName, spacing);\
else\
if ((type == TYPE_GIH_GRAYSCALE) \
    || (type == TYPE_GIH_RGBA))\
    return writeGIH(fileName, cellWidth, cellHeight, ranks, \
        placement, type, brushName, spacing);\
else\
    return false;\
bool result = gdk_pixbuf_save(pixBuf, fileName.c_str(), st.c_str(), \
    0, NULL);\
if (!result)\
\{\
    std::ostringstream status;\
    status << "[Image::writeToFile] Could not write to file '"\
        << fileName << "'!";\
    throw AltjiraError(status.str());\
\}
    return = {
        desc = \c true on success, \c false otherwise
        value = result
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = clear
	shortDesc = Clear image
	longDesc = Remove all data from the image.
    impl = if (pixBuf != 0)\
\{\
    g_object_unref(pixBuf);\
    pixBuf = 0;\
\}
}
function.public[] = {
	spec = virtual
	type = bool
	name = setPixel
	shortDesc = Set pixel color
	longDesc = Set a pixel to a color value.
	param[] = {
		type = unsigned int
		name = x
		desc = Pixel coordinate (X)
	}
	param[] = {
		type = unsigned int
		name = y
		desc = Pixel coordinate (Y)
	}
	param[] = {
		type = const Ionflux::Altjira::ByteColor&
		name = color
		desc = Color
	}
    impl = if ((x < 0) && (x >= width))\
    return false;\
if ((y < 0) && (y >= height))\
    return false;\
if (numChannels < 3)\
    return false;\
ByteColor bc = color;\
toColorSpace(bc, colorSpace);\
PixelData p = pixels + y * rowStride + x * numChannels;\
p[0] = bc.c0;\
p[1] = bc.c1;\
p[2] = bc.c2;\
if (numChannels >= 4)\
    p[3] = bc.alpha;
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = setPixel
	shortDesc = Set pixel color
	longDesc = Set a pixel to a color value.
	param[] = {
		type = unsigned int
		name = x
		desc = Pixel coordinate (X)
	}
	param[] = {
		type = unsigned int
		name = y
		desc = Pixel coordinate (Y)
	}
	param[] = {
		type = const Ionflux::Altjira::FloatColor&
		name = color
		desc = Color
	}
    impl = if ((x < 0) || (x >= width))\
    return false;\
if ((y < 0) || (y >= height))\
    return false;\
if (numChannels < 3)\
    return false;\
FloatColor fc = color;\
toColorSpace(fc, colorSpace);\
ByteColor bc;\
floatToByte(fc, bc);\
PixelData p = pixels + y * rowStride + x * numChannels;\
p[0] = bc.c0;\
p[1] = bc.c1;\
p[2] = bc.c2;\
if (numChannels >= 4)\
    p[3] = bc.alpha;
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = setPixel
	shortDesc = Set pixel color
	longDesc = Set a pixel to a color value.
	param[] = {
		type = unsigned int
		name = x
		desc = Pixel coordinate (X)
	}
	param[] = {
		type = unsigned int
		name = y
		desc = Pixel coordinate (Y)
	}
	param[] = {
		type = const Ionflux::Altjira::Color&
		name = color
		desc = Color
	}
    impl = ByteColor bc;\
color.getByteColor(bc);\
setPixel(x, y, bc);
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = getPixel
	shortDesc = Get pixel color
	longDesc = Get pixel color.
	param[] = {
		type = unsigned int
		name = x
		desc = Pixel coordinate (X)
	}
	param[] = {
		type = unsigned int
		name = y
		desc = Pixel coordinate (Y)
	}
	param[] = {
		type = Ionflux::Altjira::ByteColor&
		name = color
		desc = Color
	}
    impl = if ((x < 0) && (x >= width))\
    return false;\
if ((y < 0) || (y >= height))\
    return false;\
if (numChannels < 3)\
    return false;\
ColorSpace ts = color.space;\
PixelData p = pixels + y * rowStride + x * numChannels;\
color.c0 = p[0];\
color.c1 = p[1];\
color.c2 = p[2];\
if (numChannels >= 4)\
    color.alpha = p[3];\
else\
    color.alpha = 255;\
color.space = colorSpace;\
toColorSpace(color, ts);
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
    const = true
	name = getPixel
	shortDesc = Get pixel color
	longDesc = Get pixel color.
	param[] = {
		type = unsigned int
		name = x
		desc = Pixel coordinate (X)
	}
	param[] = {
		type = unsigned int
		name = y
		desc = Pixel coordinate (Y)
	}
	param[] = {
		type = Ionflux::Altjira::FloatColor&
		name = color
		desc = Color
	}
    impl = if ((x < 0) || (x >= width))\
    return false;\
if ((y < 0) || (y >= height))\
    return false;\
if (numChannels < 3)\
    return false;\
ColorSpace ts = color.space;\
PixelData p = pixels + y * rowStride + x * numChannels;\
color.c0 = byteToFloat(p[0]);\
color.c1 = byteToFloat(p[1]);\
color.c2 = byteToFloat(p[2]);\
if (numChannels >= 4)\
    color.alpha = byteToFloat(p[3]);\
else\
    color.alpha = 1.;\
color.space = colorSpace;\
toColorSpace(color, ts);
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = getPixel
    const = true
	shortDesc = Get pixel color
	longDesc = Get pixel color.
	param[] = {
		type = unsigned int
		name = x
		desc = Pixel coordinate (X)
	}
	param[] = {
		type = unsigned int
		name = y
		desc = Pixel coordinate (Y)
	}
	param[] = {
		type = Ionflux::Altjira::Color&
		name = color
		desc = Color
	}
    impl = if ((x < 0) || (x >= width))\
    return false;\
if ((y < 0) || (y >= height))\
    return false;\
if (numChannels < 3)\
    return false;\
PixelData p = pixels + y * rowStride + x * numChannels;\
if (numChannels >= 4)\
    color.setComponents(p[0], p[1], p[2], p[3]);\
else\
    color.setComponents(p[0], p[1], p[2], 255);
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = fill
	shortDesc = Fill
	longDesc = Fill the image with a color.
	param[] = {
		type = const Ionflux::Altjira::ByteColor&
		name = color
		desc = Color
	}
    impl = if (numChannels != 4)\
    throw AltjiraError("[Image::fill] "\
        "Operation requires four channels.");\
ByteColor bc = color;\
toColorSpace(bc, colorSpace);\
for (unsigned int x = 0; x < width; x++)\
    for (unsigned int y = 0; y < height; y++)\
    \{\
        PixelData p = pixels + y * rowStride + x * numChannels;\
        p[0] = color.c0;\
        p[1] = color.c1;\
        p[2] = color.c2;\
        p[3] = color.alpha;\
    \}
    return = {
        value = true
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = fill
	shortDesc = Fill
	longDesc = Fill the image with a color.
	param[] = {
		type = const Ionflux::Altjira::FloatColor&
		name = color
		desc = Color
	}
    impl = ByteColor bc;\
floatToByte(color, bc);
    return = {
        value = fill(bc);
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = fill
	shortDesc = Fill
	longDesc = Fill the image with a color.
	param[] = {
		type = const Ionflux::Altjira::Color&
		name = color
		desc = Color
	}
    impl = ByteColor bc;\
color.getByteColor(bc);
    return = {
        value = fill(bc);
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = fill
	shortDesc = Fill
	longDesc = Fill the image using another image as the source.
	param[] = {
		type = const Ionflux::Altjira::Image&
		name = other
		desc = Image
	}
	param[] = {
		type = const Ionflux::Altjira::ImageRect*
		name = sourceRect
		desc = Source rectangle
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetX
		desc = Target offset for filling (X)
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetY
		desc = Target offset for filling (Y)
        default = 0
	}
    impl = if (other.getNumChannels() != numChannels)\
\{\
    std::ostringstream status;\
    status << "[Image::fill] Number of channels does not " \
        "match in source and destination (source: " \
        << other.getNumChannels() << ", dest = " << numChannels << ").";\
    throw AltjiraError(status.str());\
\}\
ImageRect sr;\
if (sourceRect == 0)\
\{\
    sr.x = 0;\
    sr.y = 0;\
    sr.width = other.getWidth();\
    sr.height = other.getHeight();\
\} else\
\{\
    sr = *sourceRect;\
    other.clamp(sr);\
\}\
ImageRect tr;\
tr.x = offsetX;\
tr.y = offsetY;\
tr.width = sr.width;\
tr.height = sr.height;\
clamp(tr);\
/* <---- DEBUG ----- //\
cerr << "[Image.fill] DEBUG: sr = [" << sr.x << ", " << sr.y \
    << ", " << sr.width << ", " << sr.height << "], tr = [" << tr.x \
    << ", " << tr.y << ", " << tr.width << ", " << tr.height << "]" \
    << endl;\
// <---- DEBUG ----- */\
unsigned int srcRowStride = other.getRowStride();\
unsigned int srcNumChannels = other.getNumChannels();\
unsigned int iMax = min(sr.width, tr.width);\
unsigned int jMax = min(sr.height, tr.height);\
PixelData sp = other.getPixels();\
PixelData tp = pixels;\
for (unsigned int i = 0; i < iMax; i++)\
    for (unsigned int j = 0; j < jMax; j++)\
    \{\
        PixelData ps = sp + (sr.y + j) * srcRowStride \
            + (sr.x + i) * srcNumChannels;\
        PixelData pt = tp + (tr.y + j) * rowStride \
            + (tr.x + i) * numChannels;\
        pt[0] = ps[0];\
        pt[1] = ps[1];\
        pt[2] = ps[2];\
        pt[3] = ps[3];\
    \}
    return = {
        value = true;
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = composite
	shortDesc = Composite
	longDesc = Composite another image to this image.
	param[] = {
		type = const Ionflux::Altjira::Image&
		name = other
		desc = Image
	}
	param[] = {
		type = const Ionflux::Altjira::ColorBlender*
		name = blender
		desc = Color blender
        default = 0
	}
	param[] = {
		type = const Ionflux::Altjira::ImageRect*
		name = sourceRect
		desc = Source rectangle
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetX
		desc = Target offset for compositing (X)
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetY
		desc = Target offset for compositing (Y)
        default = 0
	}
    impl = if (other.getNumChannels() != numChannels)\
\{\
    throw AltjiraError("[Image::composite] Number of channels does " \
        "not match in source and destination.");\
\}\
bool ownBlender = false;\
if (blender == 0)\
\{\
    blender = BlendSrcOver::create();\
    ownBlender = true;\
\}\
ImageRect sr;\
if (sourceRect == 0)\
\{\
    sr.x = 0;\
    sr.y = 0;\
    sr.width = other.getWidth();\
    sr.height = other.getHeight();\
\} else\
\{\
    sr = *sourceRect;\
    other.clamp(sr);\
\}\
ImageRect tr;\
tr.x = offsetX;\
tr.y = offsetY;\
tr.width = sr.width;\
tr.height = sr.height;\
clamp(tr);\
/* <---- DEBUG ----- //\
cerr << "[Image.composite] DEBUG: sr = [" << sr.x << ", " << sr.y \
    << ", " << sr.width << ", " << sr.height << "], tr = [" << tr.x \
    << ", " << tr.y << ", " << tr.width << ", " << tr.height << "]" \
    << endl;\
// <---- DEBUG ----- */\
unsigned int srcRowStride = other.getRowStride();\
unsigned int srcNumChannels = other.getNumChannels();\
unsigned int iMax = min(sr.width, tr.width);\
unsigned int jMax = min(sr.height, tr.height);\
PixelData sp = other.getPixels();\
PixelData tp = pixels;\
ByteColor sc;\
ByteColor tc;\
ByteColor rc;\
sc.space = Color::SPACE_RGB;\
tc.space = Color::SPACE_RGB;\
rc.space = Color::SPACE_RGB;\
ByteColorValue so = floatToByte(blender->getSourceOpacity());\
ByteColorValue to = floatToByte(blender->getTargetOpacity());\
for (unsigned int i = 0; i < iMax; i++)\
    for (unsigned int j = 0; j < jMax; j++)\
    \{\
        PixelData ps = sp + (sr.y + j) * srcRowStride \
            + (sr.x + i) * srcNumChannels;\
        PixelData pt = tp + (tr.y + j) * rowStride \
            + (tr.x + i) * numChannels;\
        sc.c0 = ps[0];\
        sc.c1 = ps[1];\
        sc.c2 = ps[2];\
        tc.c0 = pt[0];\
        tc.c1 = pt[1];\
        tc.c2 = pt[2];\
        if (numChannels >= 4)\
        \{\
            sc.alpha = ps[3];\
            tc.alpha = pt[3];\
        \} else\
        \{\
            sc.alpha = 255;\
            tc.alpha = 255;\
        \}\
        blender->blend(rc, sc, tc, so, to);\
        pt[0] = rc.c0;\
        pt[1] = rc.c1;\
        pt[2] = rc.c2;\
        if (numChannels >= 4)\
            pt[3] = rc.alpha;\
    \}\
if (ownBlender)\
    delete blender;
    return = {
        value = true;
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = createArray
    const = true
	shortDesc = Create image array
	longDesc = Create an array of images from this image. This is the inverse operation of compositeArray().
	param[] = {
		type = Ionflux::Altjira::ImageSet&
		name = target
		desc = Where to store the resulting images
	}
	param[] = {
		type = unsigned int
		name = cellWidth
		desc = Cell width
	}
	param[] = {
		type = unsigned int
		name = cellHeight
		desc = Cell height
	}
    impl = unsigned int numCellsX = width / cellWidth;\
unsigned int numCellsY = height / cellHeight;\
ImageRect r0;\
r0.width = cellWidth;\
r0.height = cellHeight;\
for (unsigned int j = 0; j < numCellsY; j++)\
    for (unsigned int i = 0; i < numCellsX; i++)\
    \{\
        r0.x = i * cellWidth;\
        r0.y = j * cellHeight;\
        Image* img0 = Image::create(cellWidth, cellHeight);\
        if (img0 == 0)\
            throw AltjiraError("[Image::createArray] "\
                "Could not allocate image!");\
        img0->fill(*this, &r0);\
        target.addImage(img0);\
    \}
}
function.public[] = {
	spec = virtual
	type = void
	name = compositeArray
	shortDesc = Composite image array
	longDesc = Composite an array of images onto the image. This is the inverse operation to createArray().
	param[] = {
		type = const Ionflux::Altjira::ImageSet&
		name = source
		desc = Source images
	}
	param[] = {
		type = unsigned int
		name = cellWidth
		desc = Cell width
	}
	param[] = {
		type = unsigned int
		name = cellHeight
		desc = Cell height
	}
	param[] = {
		type = unsigned int
		name = numCols
		desc = Number of columns
	}
	param[] = {
		type = unsigned int
		name = numRows
		desc = Number of rows
	}
	param[] = {
		type = const Ionflux::Altjira::ColorBlender*
		name = blender
		desc = Color blender
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetX
		desc = Target offset for compositing (X)
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetY
		desc = Target offset for compositing (Y)
        default = 0
	}
    impl = for (unsigned int j = 0; j < numRows; j++)\
    for (unsigned int i = 0; i < numCols; i++)\
    \{\
        Image* img0 = source.getImage(j * numCols + i);\
        if (img0 == 0)\
            throw AltjiraError("[Image::compositeArray] "\
                "Source image is null!");\
        unsigned int x = offsetX + cellWidth * i;\
        unsigned int y = offsetY + cellHeight * j;\
        composite(*img0, blender, 0, x, y);\
    \}
}
function.public[] = {
	spec = virtual
	type = bool
	name = convolveFill
	shortDesc = Convolve fill
	longDesc = Fill the image using a convolution of the source image.
	param[] = {
		type = const Ionflux::Altjira::Image&
		name = other
		desc = Image
	}
	param[] = {
		type = const Ionflux::Altjira::Matrix&
		name = matrix
		desc = Convolution matrix
	}
	param[] = {
		type = const Ionflux::Altjira::ImageRect*
		name = sourceRect
		desc = Source rectangle
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetX
		desc = Target offset for filling (X)
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetY
		desc = Target offset for filling (Y)
        default = 0
	}
    impl = if (other.getNumChannels() != numChannels)\
    return false;\
unsigned int sw = other.getWidth();\
unsigned int sh = other.getHeight();\
ImageRect sr;\
if (sourceRect == 0)\
\{\
    sr.x = 0;\
    sr.y = 0;\
    sr.width = sw;\
    sr.height = sh;\
\} else\
\{\
    sr = *sourceRect;\
    other.clamp(sr);\
\}\
ImageRect tr;\
tr.x = offsetX;\
tr.y = offsetY;\
tr.width = sr.width;\
tr.height = sr.height;\
clamp(tr);\
/* <---- DEBUG ----- //\
cerr << "[Image.convolveFill] DEBUG: sr = [" << sr.x << ", " << sr.y \
    << ", " << sr.width << ", " << sr.height << "], tr = [" << tr.x \
    << ", " << tr.y << ", " << tr.width << ", " << tr.height << "]" \
    << endl;\
// <---- DEBUG ----- */\
unsigned int iMax = min(sr.width, tr.width);\
unsigned int jMax = min(sr.height, tr.height);\
unsigned int cols = matrix.getNumCols();\
unsigned int rows = matrix.getNumRows();\
unsigned int x0 = cols / 2;\
unsigned int y0 = rows / 2;\
FloatColor sc;\
sc.space = Color::SPACE_RGB;\
FloatColor tc;\
tc.space = Color::SPACE_RGB;\
for (unsigned int i = 0; i < iMax; i++)\
    for (unsigned int j = 0; j < jMax; j++)\
    \{\
        tc.c0 = 0.;\
        tc.c1 = 0.;\
        tc.c2 = 0.;\
        tc.alpha = 0.;\
        for (unsigned int k = 0; k < rows; k++)\
            for (unsigned int l = 0; l < cols; l++)\
            \{\
                int ci = sr.x + i - x0 + l;\
                int cj = sr.y + j - y0 + k;\
                if (ci < 0)\
                    ci = 0;\
                if (static_cast<unsigned int>(ci) >= sw)\
                    ci = sw - 1;\
                if (cj < 0)\
                    cj = 0;\
                if (static_cast<unsigned int>(cj) >= sh)\
                    cj = sh - 1;\
                other.getPixel(ci, cj, sc);\
                tc.c0 += (matrix.v(k, l) * sc.c0);\
                tc.c1 += (matrix.v(k, l) * sc.c1);\
                tc.c2 += (matrix.v(k, l) * sc.c2);\
                tc.alpha += (matrix.v(k, l) * sc.alpha);\
            \}\
        setPixel(tr.x + i, tr.y + j, tc);\
    \}
    return = {
        value = true;
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = setChannel
	shortDesc = Set channel
	longDesc = Set a channel of an image area to the value of a channel of another image area. The function will try to determine the source and target color space automatically from the channels. If the channel specification is ambiguous (such as hue and saturation, which occur in both HSV and HSL color space, or alpha, which occurs in all color spaces), the optional source and target spaces will be used. Otherwise, a default space will be selected.
	param[] = {
		type = Ionflux::Altjira::Image&
		name = other
		desc = Image
	}
	param[] = {
		type = Ionflux::Altjira::ChannelID
		name = source
		desc = Source Channel
	}
	param[] = {
		type = Ionflux::Altjira::ChannelID
		name = target
		desc = Target Channel
	}
	param[] = {
		type = Ionflux::Mapping::Mapping*
		name = mapping
		desc = Source channel mapping
		default = 0
	}
	param[] = {
		type = Ionflux::Altjira::ColorSpace
		name = sourceSpace
		desc = Source color space
		default = Ionflux::Altjira::Color::SPACE_UNDEFINED
	}
	param[] = {
		type = Ionflux::Altjira::ColorSpace
		name = targetSpace
		desc = Target color space
		default = Ionflux::Altjira::Color::SPACE_UNDEFINED
	}
	param[] = {
		type = const Ionflux::Altjira::ImageRect*
		name = sourceRect
		desc = Source rectangle
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetX
		desc = Target offset for filling (X)
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetY
		desc = Target offset for filling (Y)
        default = 0
	}
	impl = if (other.getNumChannels() != numChannels)\
    return false;\
unsigned int sw = other.getWidth();\
unsigned int sh = other.getHeight();\
ImageRect sr;\
if (sourceRect == 0)\
\{\
    sr.x = 0;\
    sr.y = 0;\
    sr.width = sw;\
    sr.height = sh;\
\} else\
\{\
    sr = *sourceRect;\
    other.clamp(sr);\
\}\
ImageRect tr;\
tr.x = offsetX;\
tr.y = offsetY;\
tr.width = sr.width;\
tr.height = sr.height;\
clamp(tr);\
/* <---- DEBUG ----- //\
cerr << "[Image.setChannel] DEBUG: sr = [" << sr.x << ", " << sr.y \
    << ", " << sr.width << ", " << sr.height << "], tr = [" << tr.x \
    << ", " << tr.y << ", " << tr.width << ", " << tr.height << "]" \
    << endl;\
// <---- DEBUG ----- */\
unsigned int iMax = min(sr.width, tr.width);\
unsigned int jMax = min(sr.height, tr.height);\
ByteColor sc;\
sc.space = getColorSpaceForChannel(source, sourceSpace);\
ByteColor tc;\
tc.space = getColorSpaceForChannel(target, targetSpace);\
for (unsigned int i = 0; i < iMax; i++)\
    for (unsigned int j = 0; j < jMax; j++)\
    \{\
        other.getPixel(sr.x + i, sr.y + j, sc);\
        getPixel(tr.x + i, tr.y + j, tc);\
        ByteColorValue v0 = getComponent(sc, source);\
        if (mapping != 0)\
            v0 = floatToByte((*mapping)(byteToFloat(v0)));\
        setComponent(tc, target, v0);\
        setPixel(tr.x + i, tr.y + j, tc);\
    \}
    return = {
        value = true;
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = bool
	name = mask
	shortDesc = Apply alpha mask
	longDesc = Apply an alpha mask, specified by the source channel of the other image, to the image.
	param[] = {
		type = Ionflux::Altjira::Image&
		name = other
		desc = Image
	}
	param[] = {
		type = Ionflux::Altjira::ChannelID
		name = source
		desc = Source Channel
		default = Ionflux::Altjira::CH_VALUE
	}
	param[] = {
		type = Ionflux::Mapping::Mapping*
		name = mapping
		desc = Source channel mapping
		default = 0
	}
	param[] = {
		type = Ionflux::Altjira::ColorSpace
		name = sourceSpace
		desc = Source color space
		default = Ionflux::Altjira::Color::SPACE_HSV
	}
	param[] = {
		type = const Ionflux::Altjira::ImageRect*
		name = sourceRect
		desc = Source rectangle
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetX
		desc = Target offset for filling (X)
        default = 0
	}
	param[] = {
		type = unsigned int
		name = offsetY
		desc = Target offset for filling (Y)
        default = 0
	}
	impl = if (other.getNumChannels() != numChannels)\
    return false;\
unsigned int sw = other.getWidth();\
unsigned int sh = other.getHeight();\
ImageRect sr;\
if (sourceRect == 0)\
\{\
    sr.x = 0;\
    sr.y = 0;\
    sr.width = sw;\
    sr.height = sh;\
\} else\
\{\
    sr = *sourceRect;\
    other.clamp(sr);\
\}\
ImageRect tr;\
tr.x = offsetX;\
tr.y = offsetY;\
tr.width = sr.width;\
tr.height = sr.height;\
clamp(tr);\
/* <---- DEBUG ----- //\
cerr << "[Image.mask] DEBUG: sr = [" << sr.x << ", " << sr.y \
    << ", " << sr.width << ", " << sr.height << "], tr = [" << tr.x \
    << ", " << tr.y << ", " << tr.width << ", " << tr.height << "]" \
    << endl;\
// <---- DEBUG ----- */\
unsigned int iMax = min(sr.width, tr.width);\
unsigned int jMax = min(sr.height, tr.height);\
ByteColor sc;\
sc.space = getColorSpaceForChannel(source, sourceSpace);\
ByteColor tc;\
tc.space = Color::SPACE_RGB;\
for (unsigned int i = 0; i < iMax; i++)\
    for (unsigned int j = 0; j < jMax; j++)\
    \{\
        other.getPixel(sr.x + i, sr.y + j, sc);\
        getPixel(tr.x + i, tr.y + j, tc);\
        ByteColorValue v0 = getComponent(sc, source);\
        if (mapping != 0)\
            v0 = floatToByte((*mapping)(byteToFloat(v0)));\
        tc.alpha = lutMult(v0, tc.alpha);\
        setPixel(tr.x + i, tr.y + j, tc);\
    \}
    return = {
        value = true;
        desc = \c true on success, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = valuesToColor
	shortDesc = Transform values to colors
	longDesc = Transform the values in the image to colors set by a color band.
	param[] = {
	    type = Ionflux::Altjira::ColorBand&
	    name = colors
	    desc = Color band.
	}
	impl = if (numChannels != 4)\
    throw AltjiraError("[Image::valuesToColor] "\
        "Operation requires four channels.");\
ByteColor sc;\
ByteColor tc;\
tc.space = Ionflux::Altjira::Color::SPACE_RGB;\
for (unsigned int x = 0; x < width; x++)\
    for (unsigned int y = 0; y < height; y++)\
    \{\
        PixelData p = pixels + y * rowStride + x * numChannels;\
        sc.c0 = p[0];\
        sc.c1 = p[1];\
        sc.c2 = p[2];\
        sc.alpha = p[3];\
        sc.space = Ionflux::Altjira::Color::SPACE_RGB;\
        toColorSpace(sc, Ionflux::Altjira::Color::SPACE_HSV);\
        colors.eval(byteToFloat(sc.c2), tc);\
        p[0] = tc.c0;\
        p[1] = tc.c1;\
        p[2] = tc.c2;\
        p[3] = tc.alpha;\
    \}
}
function.public[] = {
	spec = virtual
	type = void
	name = colorToAlpha
	shortDesc = Color to alpha
	longDesc = Replace a reference color by transparency.
	param[] = {
	    type = const Ionflux::Altjira::Color&
	    name = color
	    desc = Color.
	}
	impl = FloatColor rc;\
rc.space = Ionflux::Altjira::Color::SPACE_RGB;\
color.getFloatColor(rc);\
FloatColor sc;\
sc.space = Ionflux::Altjira::Color::SPACE_RGB;\
for (unsigned int x = 0; x < width; x++)\
    for (unsigned int y = 0; y < height; y++)\
    \{\
        getPixel(x, y, sc);\
        Ionflux::Altjira::colorToAlpha(sc, rc);\
        setPixel(x, y, sc);\
    \}
}
function.public[] = {
	spec = virtual
	type = void
	name = luminize
	shortDesc = Luminize
	longDesc = Apply the luminance of the source image to the image, keeping hue and saturation information of the original image.
	param[] = {
	    type = const Ionflux::Altjira::Image&
	    name = source
	    desc = Source image.
	}
	param[] = {
	    type = double
	    name = amount
	    desc = Effect strength.
	    default = 1.
	}
	impl = // Luminance blender.\
BlendChannel bl0;\
bl0.setSrcChannel(CH_LUMINANCE);\
bl0.setDestChannel(CH_LUMINANCE);\
bl0.setSourceOpacity(amount);\
bl0.setTargetOpacity(1. - amount);\
/* Saturation blender.\
   Used so we get a valid saturation for high luminance areas. */\
BlendChannel bl1;\
bl1.setSrcChannel(CH_SATURATION);\
bl1.setDestChannel(CH_SATURATION);\
bl1.setSrcSpace(Color::SPACE_HSV);\
bl1.setDestSpace(Color::SPACE_HSL);\
bl1.setSourceOpacity(amount);\
bl1.setTargetOpacity(1. - amount);\
// Make a copy of the original to save the saturation information.\
Image sat(*this);\
composite(source, &bl0);\
composite(sat, &bl1);
}
function.public[] = {
	spec = virtual
	type = bool
    const = true
	name = hasAlpha
	shortDesc = Check alpha channel
	longDesc = Check whether the image has an alpha channel.
	return = {
        value = alphaFlag
	    desc = \c true if the image has an alpha channel, \c false otherwise
    }
}
function.public[] = {
	spec = virtual
	type = void
	name = clamp
    const = true
	shortDesc = Clamp rectangle
	longDesc = Clamp a rectangle to the image boundaries. If the rectangle lies outside the image boundaries, its width and height will be set to 0.
	param[] = {
		type = Ionflux::Altjira::ImageRect&
		name = r0
		desc = Rectangle
	}
    impl = Ionflux::Mapping::Range xRange = { 0, static_cast<double>(width) };\
Ionflux::Mapping::Range yRange = { 0, static_cast<double>(height) };\
unsigned int ex = Ionflux::Mapping::clamp(r0.x + r0.width, xRange);\
unsigned int ey = Ionflux::Mapping::clamp(r0.y + r0.height, yRange);\
if (ex < r0.x)\
    r0.width = 0;\
else\
    r0.width = ex - r0.x;\
if (ey < r0.y)\
    r0.height = 0;\
else\
    r0.height = ey - r0.y;
}
function.public[] = {
	spec = virtual
	type = void
    const = true
	name = getRandomPoints
	shortDesc = Get random points
	longDesc = Get random points sampled from the image. The value channel of the image is used as a two-dimensional random distribution and the specified number of points are sampled from this distribution and stored in the target point set.
	param[] = {
	    type = unsigned int
	    name = numPoints
	    desc = Number of points
	}
	param[] = {
	    type = Ionflux::Mapping::PointSet&
	    name = target
	    desc = Target point set
	}
	param[] = {
	    type = unsigned int
	    name = maxIters
	    desc = Average maximum number of iterations per point
	    default = 100
	}
	impl = FloatColor c0;\
c0.space = Ionflux::Altjira::Color::SPACE_HSV;\
unsigned int pointsOK = 0;\
unsigned int maxItersP = maxIters * numPoints;\
unsigned int i = 0;\
while ((pointsOK < numPoints) \
    && (i <= maxItersP))\
\{\
    Ionflux::Mapping::Point p0 = Ionflux::Mapping::getRandomPointExc();\
    getPixel(static_cast<unsigned int>(p0.getX() * width), \
        static_cast<unsigned int>(p0.getY() * height), c0);\
    if (p0.getZ() <= c0.c2)\
    \{\
        p0.setZ(0.);\
        target.addPoint(p0.copy());\
        pointsOK++;\
    \}\
    i++;\
\}\
if (pointsOK < numPoints)\
    throw AltjiraError("[Image::getRandomPoints] "\
        "Maximum number of iterations exceeded!");
}
function.public[] = {
	spec = virtual
	type = void
	name = getColorDifference
	const = true
	shortDesc = Get color difference
	longDesc = <<<
Calculate the difference of image pixels compared to a reference color and store the result in the target image.
>>>
	param[] = {
	    type = const Ionflux::Altjira::Color&
	    name = refColor
	    desc = Reference color
	}
	param[] = {
	    type = Ionflux::Altjira::Image&
	    name = targetImage
	    desc = Target image
	}
	param[] = {
	    type = Ionflux::Mapping::Mapping*
	    name = mapping
	    desc = Result mapping
		default = 0
	}
	impl = <<<
unsigned int iMax = min(width, targetImage.width);
unsigned int jMax = min(height, targetImage.height);
Color pixel;
Color diffColor(Color::WHITE);

for (unsigned int i = 0; i < iMax; i++)
{
	for (unsigned int j = 0; j < jMax; j++)
	{
		getPixel(i, j, pixel);
		double diff = pixel.getMeanSquaredError(refColor);
		if (mapping != 0)
			diff = Ionflux::Mapping::clamp(mapping->call(diff));
		diffColor.setComponents(diff, diff, diff, 1.);
		targetImage.setPixel(i, j, diffColor);
	}
}
>>>
}
function.public[] = {
	spec = virtual
	type = void
	name = getChannel
	const = true
	shortDesc = Get channel
	longDesc = <<<
Extract an image channel. The channel data will be stored in the target matrix.

The optional \c colorSpace parameter is used as a hint for extracting the channel.
>>>
	param[] = {
		type = Ionflux::Altjira::ChannelID
		name = channel
		desc = Channel
	}
	param[] = {
	    type = Ionflux::Altjira::Matrix&
	    name = target
	    desc = Target matrix
	}
	param[] = {
		type = Ionflux::Altjira::ColorSpace
		name = colorSpace
		desc = Color space
		default = Ionflux::Altjira::Color::SPACE_HSV
	}
	impl = <<<
unsigned int iMax = min(width, target.getNumCols());
unsigned int jMax = min(height, target.getNumRows());
FloatColor pixel;
pixel.space = getColorSpaceForChannel(channel, colorSpace);
for (unsigned int i = 0; i < iMax; i++)
{
	for (unsigned int j = 0; j < jMax; j++)
	{
		getPixel(i, j, pixel);
		double chValue = getComponent(pixel, channel);
		target.setValue(j, i, chValue);
	}
}
>>>
}
function.public[] = {
	spec = virtual
	type = Ionflux::ObjectBase::UInt64
	name = getSize
	const = true
	shortDesc = Get size
	longDesc = Get the size of the image (in bytes).
	impl = 
	return = {
		value = width * height * bitsPerSample * numChannels / 8
		desc = Size of the image
	}
}
function.public[] = {
	spec = virtual
	type = std::string
	name = getString
	const = true
	shortDesc = Get string representation
	longDesc = Get a string representation of the object
	impl = ostringstream state;\
state << getClassName() << "[" << width << " x " << height \
    << " px, " << numChannels << " ch, " << bitsPerSample << " bps]";
    return = {
        value = state.str()
        desc = String representation
    }
}

# Pure virtual member functions.

# Static member functions.
function.public[] = {
	spec = static
	type = Ionflux::Altjira::Image*
	name = create
	shortDesc = Create image
	longDesc = Create a new image object.
	param[] = {
		type = unsigned int
		name = initWidth
		desc = Width
	}
	param[] = {
		type = unsigned int
		name = initHeight
		desc = Height
	}
	param[] = {
		type = bool
		name = initAlpha
		desc = Create alpha channel
        default = true
	}
	param[] = {
		type = unsigned int
		name = initBitsPerSample
		desc = Bits pers sample
        default = 8
	}
	param[] = {
		type = Ionflux::Altjira::ColorSpace
		name = initColorSpace
		desc = Color space
        default = Ionflux::Altjira::Color::SPACE_RGB
	}
	impl = Image* result = create();\
result->createNewData(initWidth, initHeight, initAlpha, \
    initBitsPerSample, initColorSpace);
    return = {
        value = result
        desc = New image
    }
}

# operations

